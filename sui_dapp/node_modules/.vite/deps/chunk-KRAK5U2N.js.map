{
  "version": 3,
  "sources": ["../../@mysten/utils/src/b64.ts", "../../@scure/base/index.ts", "../../@mysten/utils/src/b58.ts", "../../@mysten/utils/src/hex.ts", "../../@mysten/utils/src/chunk.ts", "../../@mysten/utils/src/with-resolver.ts", "../../@mysten/utils/src/dataloader.ts", "../../@mysten/bcs/src/uleb.ts", "../../@mysten/bcs/src/reader.ts", "../../@mysten/bcs/src/utils.ts", "../../@mysten/bcs/src/writer.ts", "../../@mysten/bcs/src/bcs-type.ts", "../../@mysten/bcs/src/bcs.ts", "../../@mysten/sui/src/utils/format.ts", "../../@mysten/sui/src/utils/suins.ts", "../../@mysten/sui/src/utils/move-registry.ts", "../../@mysten/sui/src/utils/sui-types.ts", "../../@mysten/sui/src/utils/constants.ts", "../../@noble/hashes/src/crypto.ts", "../../@noble/hashes/src/utils.ts", "../../@noble/hashes/src/_blake.ts", "../../@noble/hashes/src/_md.ts", "../../@noble/hashes/src/_u64.ts", "../../@noble/hashes/src/blake2.ts", "../../@noble/hashes/src/blake2b.ts", "../../@mysten/sui/src/bcs/type-tag-serializer.ts", "../../@mysten/sui/src/bcs/bcs.ts", "../../@mysten/sui/src/bcs/effects.ts", "../../@mysten/sui/src/bcs/pure.ts", "../../@mysten/sui/src/bcs/index.ts", "../../@mysten/sui/src/utils/dynamic-fields.ts", "../../@mysten/sui/src/transactions/serializer.ts", "../../@mysten/sui/src/transactions/Inputs.ts", "../../valibot/dist/index.js", "../../@mysten/sui/src/transactions/data/internal.ts", "../../@mysten/sui/src/transactions/Commands.ts", "../../@mysten/sui/src/transactions/utils.ts", "../../@mysten/sui/src/transactions/data/v1.ts", "../../@mysten/sui/src/transactions/hash.ts", "../../@mysten/sui/src/transactions/TransactionData.ts", "../../@mysten/sui/src/experimental/cache.ts", "../../@mysten/sui/src/version.ts", "../../@mysten/sui/src/experimental/mvr.ts", "../../@mysten/sui/src/transactions/plugins/NamedPackagesPlugin.ts", "../../@mysten/sui/src/transactions/data/v2.ts", "../../@mysten/sui/src/jsonRpc/json-rpc-resolver.ts", "../../@mysten/sui/src/transactions/resolve.ts", "../../@mysten/sui/src/transactions/object.ts", "../../@mysten/sui/src/transactions/pure.ts", "../../@mysten/sui/src/transactions/Transaction.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array<ArrayBuffer> {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n\r\nexport interface Coder<F, T> {\r\n  encode(from: F): T;\r\n  decode(to: T): F;\r\n}\r\n\r\nexport interface BytesCoder extends Coder<Uint8Array, string> {\r\n  encode: (data: Uint8Array) => string;\r\n  decode: (str: string) => Uint8Array;\r\n}\r\n\r\nfunction isBytes(a: unknown): a is Uint8Array {\r\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\r\n}\r\n/** Asserts something is Uint8Array. */\r\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\r\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\r\n  if (lengths.length > 0 && !lengths.includes(b.length))\r\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\r\n}\r\n\r\nfunction isArrayOf(isString: boolean, arr: any[]) {\r\n  if (!Array.isArray(arr)) return false;\r\n  if (arr.length === 0) return true;\r\n  if (isString) {\r\n    return arr.every((item) => typeof item === 'string');\r\n  } else {\r\n    return arr.every((item) => Number.isSafeInteger(item));\r\n  }\r\n}\r\n\r\n// no abytes: seems to have 10% slowdown. Why?!\r\n\r\nfunction afn(input: Function): input is Function {\r\n  if (typeof input !== 'function') throw new Error('function expected');\r\n  return true;\r\n}\r\n\r\nfunction astr(label: string, input: unknown): input is string {\r\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\r\n  return true;\r\n}\r\n\r\nfunction anumber(n: number): void {\r\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\r\n}\r\n\r\nfunction aArr(input: any[]) {\r\n  if (!Array.isArray(input)) throw new Error('array expected');\r\n}\r\nfunction astrArr(label: string, input: string[]) {\r\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\r\n}\r\nfunction anumArr(label: string, input: number[]) {\r\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\r\n}\r\n\r\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\r\n// like <string, number>, <number, bytes>, <bytes, float>\r\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\r\n// Extract info from Coder type\r\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\r\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\r\n// Generic function for arrays\r\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\r\ntype Last<T> = T extends [...any[], infer U] ? U : never;\r\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\r\n\r\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\r\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\r\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\r\n};\r\n\r\n/**\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\r\n  const id = (a: any) => a;\r\n  // Wrap call in closure so JIT can inline calls\r\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\r\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\r\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\r\n  // Construct chain of args[0].decode(args[1].decode(...))\r\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\r\n  return { encode, decode };\r\n}\r\n\r\n/**\r\n * Encodes integer radix representation to array of strings using alphabet and back.\r\n * Could also be array of strings.\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\r\n  // mapping 1 to \"b\"\r\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\r\n  const len = lettersA.length;\r\n  astrArr('alphabet', lettersA);\r\n\r\n  // mapping \"b\" to 1\r\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\r\n  return {\r\n    encode: (digits: number[]) => {\r\n      aArr(digits);\r\n      return digits.map((i) => {\r\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\r\n          throw new Error(\r\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\r\n          );\r\n        return lettersA[i]!;\r\n      });\r\n    },\r\n    decode: (input: string[]): number[] => {\r\n      aArr(input);\r\n      return input.map((letter) => {\r\n        astr('alphabet.decode', letter);\r\n        const i = indexes.get(letter);\r\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\r\n        return i;\r\n      });\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction join(separator = ''): Coder<string[], string> {\r\n  astr('join', separator);\r\n  return {\r\n    encode: (from) => {\r\n      astrArr('join.decode', from);\r\n      return from.join(separator);\r\n    },\r\n    decode: (to) => {\r\n      astr('join.decode', to);\r\n      return to.split(separator);\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Pad strings array so it has integer number of bits\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\r\n  anumber(bits);\r\n  astr('padding', chr);\r\n  return {\r\n    encode(data: string[]): string[] {\r\n      astrArr('padding.encode', data);\r\n      while ((data.length * bits) % 8) data.push(chr);\r\n      return data;\r\n    },\r\n    decode(input: string[]): string[] {\r\n      astrArr('padding.decode', input);\r\n      let end = input.length;\r\n      if ((end * bits) % 8)\r\n        throw new Error('padding: invalid, string should have whole number of bytes');\r\n      for (; end > 0 && input[end - 1] === chr; end--) {\r\n        const last = end - 1;\r\n        const byte = last * bits;\r\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\r\n      }\r\n      return input.slice(0, end);\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\r\n  afn(fn);\r\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\r\n}\r\n\r\n/**\r\n * Slow: O(n^2) time complexity\r\n */\r\nfunction convertRadix(data: number[], from: number, to: number): number[] {\r\n  // base 1 is impossible\r\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\r\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\r\n  aArr(data);\r\n  if (!data.length) return [];\r\n  let pos = 0;\r\n  const res = [];\r\n  const digits = Array.from(data, (d) => {\r\n    anumber(d);\r\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\r\n    return d;\r\n  });\r\n  const dlen = digits.length;\r\n  while (true) {\r\n    let carry = 0;\r\n    let done = true;\r\n    for (let i = pos; i < dlen; i++) {\r\n      const digit = digits[i]!;\r\n      const fromCarry = from * carry;\r\n      const digitBase = fromCarry + digit;\r\n      if (\r\n        !Number.isSafeInteger(digitBase) ||\r\n        fromCarry / from !== carry ||\r\n        digitBase - digit !== fromCarry\r\n      ) {\r\n        throw new Error('convertRadix: carry overflow');\r\n      }\r\n      const div = digitBase / to;\r\n      carry = digitBase % to;\r\n      const rounded = Math.floor(div);\r\n      digits[i] = rounded;\r\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\r\n        throw new Error('convertRadix: carry overflow');\r\n      if (!done) continue;\r\n      else if (!rounded) pos = i;\r\n      else done = false;\r\n    }\r\n    res.push(carry);\r\n    if (done) break;\r\n  }\r\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\r\n  return res.reverse();\r\n}\r\n\r\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\r\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\r\n  from + (to - gcd(from, to));\r\nconst powers: number[] = /* @__PURE__ */ (() => {\r\n  let res = [];\r\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\r\n  return res;\r\n})();\r\n/**\r\n * Implemented with numbers, because BigInt is 5x slower\r\n */\r\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\r\n  aArr(data);\r\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\r\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\r\n  if (radix2carry(from, to) > 32) {\r\n    throw new Error(\r\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\r\n    );\r\n  }\r\n  let carry = 0;\r\n  let pos = 0; // bitwise position in current element\r\n  const max = powers[from]!;\r\n  const mask = powers[to]! - 1;\r\n  const res: number[] = [];\r\n  for (const n of data) {\r\n    anumber(n);\r\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\r\n    carry = (carry << from) | n;\r\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\r\n    pos += from;\r\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\r\n    const pow = powers[pos];\r\n    if (pow === undefined) throw new Error('invalid carry');\r\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\r\n  }\r\n  carry = (carry << (to - pos)) & mask;\r\n  if (!padding && pos >= from) throw new Error('Excess padding');\r\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\r\n  if (padding && pos > 0) res.push(carry >>> 0);\r\n  return res;\r\n}\r\n\r\n/**\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction radix(num: number): Coder<Uint8Array, number[]> {\r\n  anumber(num);\r\n  const _256 = 2 ** 8;\r\n  return {\r\n    encode: (bytes: Uint8Array) => {\r\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\r\n      return convertRadix(Array.from(bytes), _256, num);\r\n    },\r\n    decode: (digits: number[]) => {\r\n      anumArr('radix.decode', digits);\r\n      return Uint8Array.from(convertRadix(digits, num, _256));\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * If both bases are power of same number (like `2**8 <-> 2**64`),\r\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\r\n  anumber(bits);\r\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\r\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\r\n    throw new Error('radix2: carry overflow');\r\n  return {\r\n    encode: (bytes: Uint8Array) => {\r\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\r\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\r\n    },\r\n    decode: (digits: number[]) => {\r\n      anumArr('radix2.decode', digits);\r\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\r\n    },\r\n  };\r\n}\r\n\r\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\r\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\r\n  afn(fn);\r\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\r\n    try {\r\n      return fn.apply(null, args);\r\n    } catch (e) {}\r\n  };\r\n}\r\n\r\nfunction checksum(\r\n  len: number,\r\n  fn: (data: Uint8Array) => Uint8Array\r\n): Coder<Uint8Array, Uint8Array> {\r\n  anumber(len);\r\n  afn(fn);\r\n  return {\r\n    encode(data: Uint8Array) {\r\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\r\n      const sum = fn(data).slice(0, len);\r\n      const res = new Uint8Array(data.length + len);\r\n      res.set(data);\r\n      res.set(sum, data.length);\r\n      return res;\r\n    },\r\n    decode(data: Uint8Array) {\r\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\r\n      const payload = data.slice(0, -len);\r\n      const oldChecksum = data.slice(-len);\r\n      const newChecksum = fn(payload).slice(0, len);\r\n      for (let i = 0; i < len; i++)\r\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\r\n      return payload;\r\n    },\r\n  };\r\n}\r\n\r\n// prettier-ignore\r\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\r\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\r\n};\r\n\r\n// RFC 4648 aka RFC 3548\r\n// ---------------------\r\n\r\n/**\r\n * base16 encoding from RFC 4648.\r\n * @example\r\n * ```js\r\n * base16.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => '12AB'\r\n * ```\r\n */\r\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\r\n\r\n/**\r\n * base32 encoding from RFC 4648. Has padding.\r\n * Use `base32nopad` for unpadded version.\r\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\r\n * @example\r\n * ```js\r\n * base32.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => 'CKVQ===='\r\n * base32.decode('CKVQ====');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\nexport const base32: BytesCoder = chain(\r\n  radix2(5),\r\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\r\n  padding(5),\r\n  join('')\r\n);\r\n\r\n/**\r\n * base32 encoding from RFC 4648. No padding.\r\n * Use `base32` for padded version.\r\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\r\n * @example\r\n * ```js\r\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => 'CKVQ'\r\n * base32nopad.decode('CKVQ');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\nexport const base32nopad: BytesCoder = chain(\r\n  radix2(5),\r\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\r\n  join('')\r\n);\r\n/**\r\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\r\n * Use `base32hexnopad` for unpadded version.\r\n * @example\r\n * ```js\r\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => '2ALG===='\r\n * base32hex.decode('2ALG====');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\nexport const base32hex: BytesCoder = chain(\r\n  radix2(5),\r\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\r\n  padding(5),\r\n  join('')\r\n);\r\n\r\n/**\r\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\r\n * Use `base32hex` for padded version.\r\n * @example\r\n * ```js\r\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => '2ALG'\r\n * base32hexnopad.decode('2ALG');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\nexport const base32hexnopad: BytesCoder = chain(\r\n  radix2(5),\r\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\r\n  join('')\r\n);\r\n/**\r\n * base32 encoding from RFC 4648. Doug Crockford's version.\r\n * https://www.crockford.com/base32.html\r\n * @example\r\n * ```js\r\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => '2ANG'\r\n * base32crockford.decode('2ANG');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\nexport const base32crockford: BytesCoder = chain(\r\n  radix2(5),\r\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\r\n  join(''),\r\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\r\n);\r\n\r\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\r\n// prettier-ignore\r\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\r\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\r\n  typeof (Uint8Array as any).fromBase64 === 'function')();\r\n\r\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\r\n  astr('base64', s);\r\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\r\n  const alphabet = isUrl ? 'base64url' : 'base64';\r\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\r\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\r\n};\r\n\r\n/**\r\n * base64 from RFC 4648. Padded.\r\n * Use `base64nopad` for unpadded version.\r\n * Also check out `base64url`, `base64urlnopad`.\r\n * Falls back to built-in function, when available.\r\n * @example\r\n * ```js\r\n * base64.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => 'Eqs='\r\n * base64.decode('Eqs=');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\n// prettier-ignore\r\nexport const base64: BytesCoder = hasBase64Builtin ? {\r\n  encode(b) { abytes(b); return (b as any).toBase64(); },\r\n  decode(s) { return decodeBase64Builtin(s, false); },\r\n} : chain(\r\n  radix2(6),\r\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\r\n  padding(6),\r\n  join('')\r\n);\r\n/**\r\n * base64 from RFC 4648. No padding.\r\n * Use `base64` for padded version.\r\n * @example\r\n * ```js\r\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => 'Eqs'\r\n * base64nopad.decode('Eqs');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\nexport const base64nopad: BytesCoder = chain(\r\n  radix2(6),\r\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\r\n  join('')\r\n);\r\n\r\n/**\r\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\r\n * Use `base64urlnopad` for unpadded version.\r\n * Falls back to built-in function, when available.\r\n * @example\r\n * ```js\r\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => 'Eqs='\r\n * base64url.decode('Eqs=');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\n// prettier-ignore\r\nexport const base64url: BytesCoder = hasBase64Builtin ? {\r\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\r\n  decode(s) { return decodeBase64Builtin(s, true); },\r\n} : chain(\r\n  radix2(6),\r\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\r\n  padding(6),\r\n  join('')\r\n);\r\n\r\n/**\r\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\r\n * Use `base64url` for padded version.\r\n * @example\r\n * ```js\r\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\r\n * // => 'Eqs'\r\n * base64urlnopad.decode('Eqs');\r\n * // => Uint8Array.from([0x12, 0xab])\r\n * ```\r\n */\r\nexport const base64urlnopad: BytesCoder = chain(\r\n  radix2(6),\r\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\r\n  join('')\r\n);\r\n\r\n// base58 code\r\n// -----------\r\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\r\n  chain(radix(58), alphabet(abc), join(''));\r\n\r\n/**\r\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\r\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\r\n * @example\r\n * ```js\r\n * base58.decode('01abcdef');\r\n * // => '3UhJW'\r\n * ```\r\n */\r\nexport const base58: BytesCoder = genBase58(\r\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\r\n);\r\n/**\r\n * base58: flickr version. Check out `base58`.\r\n */\r\nexport const base58flickr: BytesCoder = genBase58(\r\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\r\n);\r\n/**\r\n * base58: XRP version. Check out `base58`.\r\n */\r\nexport const base58xrp: BytesCoder = genBase58(\r\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\r\n);\r\n\r\n// Data len (index) -> encoded block len\r\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\r\n\r\n/**\r\n * base58: XMR version. Check out `base58`.\r\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\r\n * Block encoding significantly reduces quadratic complexity of base58.\r\n */\r\nexport const base58xmr: BytesCoder = {\r\n  encode(data: Uint8Array) {\r\n    let res = '';\r\n    for (let i = 0; i < data.length; i += 8) {\r\n      const block = data.subarray(i, i + 8);\r\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\r\n    }\r\n    return res;\r\n  },\r\n  decode(str: string) {\r\n    let res: number[] = [];\r\n    for (let i = 0; i < str.length; i += 11) {\r\n      const slice = str.slice(i, i + 11);\r\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\r\n      const block = base58.decode(slice);\r\n      for (let j = 0; j < block.length - blockLen; j++) {\r\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\r\n      }\r\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\r\n    }\r\n    return Uint8Array.from(res);\r\n  },\r\n};\r\n\r\n/**\r\n * Method, which creates base58check encoder.\r\n * Requires function, calculating sha256.\r\n */\r\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\r\n  chain(\r\n    checksum(4, (data) => sha256(sha256(data))),\r\n    base58\r\n  );\r\n\r\n/**\r\n * Use `createBase58check` instead.\r\n * @deprecated\r\n */\r\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\r\n  createBase58check;\r\n\r\n// Bech32 code\r\n// -----------\r\nexport interface Bech32Decoded<Prefix extends string = string> {\r\n  prefix: Prefix;\r\n  words: number[];\r\n}\r\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\r\n  prefix: Prefix;\r\n  words: number[];\r\n  bytes: Uint8Array;\r\n}\r\n\r\nconst BECH_ALPHABET: Coder<number[], string> = chain(\r\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\r\n  join('')\r\n);\r\n\r\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\r\nfunction bech32Polymod(pre: number): number {\r\n  const b = pre >> 25;\r\n  let chk = (pre & 0x1ffffff) << 5;\r\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\r\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\r\n  }\r\n  return chk;\r\n}\r\n\r\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\r\n  const len = prefix.length;\r\n  let chk = 1;\r\n  for (let i = 0; i < len; i++) {\r\n    const c = prefix.charCodeAt(i);\r\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\r\n    chk = bech32Polymod(chk) ^ (c >> 5);\r\n  }\r\n  chk = bech32Polymod(chk);\r\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\r\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\r\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\r\n  chk ^= encodingConst;\r\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\r\n}\r\n\r\nexport interface Bech32 {\r\n  encode<Prefix extends string>(\r\n    prefix: Prefix,\r\n    words: number[] | Uint8Array,\r\n    limit?: number | false\r\n  ): `${Lowercase<Prefix>}1${string}`;\r\n  decode<Prefix extends string>(\r\n    str: `${Prefix}1${string}`,\r\n    limit?: number | false\r\n  ): Bech32Decoded<Prefix>;\r\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\r\n  decodeToBytes(str: string): Bech32DecodedWithArray;\r\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\r\n  fromWords(to: number[]): Uint8Array;\r\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\r\n  toWords(from: Uint8Array): number[];\r\n}\r\n/**\r\n * @__NO_SIDE_EFFECTS__\r\n */\r\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\r\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\r\n  const _words = radix2(5);\r\n  const fromWords = _words.decode;\r\n  const toWords = _words.encode;\r\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\r\n\r\n  function encode<Prefix extends string>(\r\n    prefix: Prefix,\r\n    words: number[] | Uint8Array,\r\n    limit: number | false = 90\r\n  ): `${Lowercase<Prefix>}1${string}` {\r\n    astr('bech32.encode prefix', prefix);\r\n    if (isBytes(words)) words = Array.from(words);\r\n    anumArr('bech32.encode', words);\r\n    const plen = prefix.length;\r\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\r\n    const actualLength = plen + 7 + words.length;\r\n    if (limit !== false && actualLength > limit)\r\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\r\n    const lowered = prefix.toLowerCase();\r\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\r\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\r\n  }\r\n\r\n  function decode<Prefix extends string>(\r\n    str: `${Prefix}1${string}`,\r\n    limit?: number | false\r\n  ): Bech32Decoded<Prefix>;\r\n  function decode(str: string, limit?: number | false): Bech32Decoded;\r\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\r\n    astr('bech32.decode input', str);\r\n    const slen = str.length;\r\n    if (slen < 8 || (limit !== false && slen > limit))\r\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\r\n    // don't allow mixed case\r\n    const lowered = str.toLowerCase();\r\n    if (str !== lowered && str !== str.toUpperCase())\r\n      throw new Error(`String must be lowercase or uppercase`);\r\n    const sepIndex = lowered.lastIndexOf('1');\r\n    if (sepIndex === 0 || sepIndex === -1)\r\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\r\n    const prefix = lowered.slice(0, sepIndex);\r\n    const data = lowered.slice(sepIndex + 1);\r\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\r\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\r\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\r\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\r\n    return { prefix, words };\r\n  }\r\n\r\n  const decodeUnsafe = unsafeWrapper(decode);\r\n\r\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\r\n    const { prefix, words } = decode(str, false);\r\n    return { prefix, words, bytes: fromWords(words) };\r\n  }\r\n\r\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\r\n    return encode(prefix, toWords(bytes));\r\n  }\r\n\r\n  return {\r\n    encode,\r\n    decode,\r\n    encodeFromBytes,\r\n    decodeToBytes,\r\n    decodeUnsafe,\r\n    fromWords,\r\n    fromWordsUnsafe,\r\n    toWords,\r\n  };\r\n}\r\n\r\n/**\r\n * bech32 from BIP 173. Operates on words.\r\n * For high-level, check out scure-btc-signer:\r\n * https://github.com/paulmillr/scure-btc-signer.\r\n */\r\nexport const bech32: Bech32 = genBech32('bech32');\r\n\r\n/**\r\n * bech32m from BIP 350. Operates on words.\r\n * It was to mitigate `bech32` weaknesses.\r\n * For high-level, check out scure-btc-signer:\r\n * https://github.com/paulmillr/scure-btc-signer.\r\n */\r\nexport const bech32m: Bech32 = genBech32('bech32m');\r\n\r\ndeclare const TextEncoder: any;\r\ndeclare const TextDecoder: any;\r\n\r\n/**\r\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\r\n * @example\r\n * ```js\r\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\r\n * const str = utf8.encode(b); // \"hey\"\r\n * ```\r\n */\r\nexport const utf8: BytesCoder = {\r\n  encode: (data) => new TextDecoder().decode(data),\r\n  decode: (str) => new TextEncoder().encode(str),\r\n};\r\n\r\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\r\n// prettier-ignore\r\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\r\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\r\n  typeof (Uint8Array as any).fromHex === 'function')();\r\n// prettier-ignore\r\nconst hexBuiltin: BytesCoder = {\r\n  encode(data) { abytes(data); return (data as any).toHex(); },\r\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\r\n};\r\n/**\r\n * hex string decoder. Uses built-in function, when available.\r\n * @example\r\n * ```js\r\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\r\n * const str = hex.encode(b); // \"0102ff\"\r\n * ```\r\n */\r\nexport const hex: BytesCoder = hasHexBuiltin\r\n  ? hexBuiltin\r\n  : chain(\r\n      radix2(4),\r\n      alphabet('0123456789abcdef'),\r\n      join(''),\r\n      normalize((s: string) => {\r\n        if (typeof s !== 'string' || s.length % 2 !== 0)\r\n          throw new TypeError(\r\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\r\n          );\r\n        return s.toLowerCase();\r\n      })\r\n    );\r\n\r\nexport type SomeCoders = {\r\n  utf8: BytesCoder;\r\n  hex: BytesCoder;\r\n  base16: BytesCoder;\r\n  base32: BytesCoder;\r\n  base64: BytesCoder;\r\n  base64url: BytesCoder;\r\n  base58: BytesCoder;\r\n  base58xmr: BytesCoder;\r\n};\r\n// prettier-ignore\r\nconst CODERS: SomeCoders = {\r\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\r\n};\r\ntype CoderType = keyof SomeCoders;\r\nconst coderTypeError =\r\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\r\n\r\n/** @deprecated */\r\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\r\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\r\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\r\n  return CODERS[type].encode(bytes);\r\n};\r\n\r\n/** @deprecated */\r\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\r\n\r\n/** @deprecated */\r\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\r\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\r\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\r\n  return CODERS[type].decode(str);\r\n};\r\n/** @deprecated */\r\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { base58 } from '@scure/base';\n\nexport const toBase58 = (buffer: Uint8Array) => base58.encode(buffer);\nexport const fromBase58 = (str: string) => base58.decode(str) as Uint8Array<ArrayBuffer>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array<ArrayBuffer> {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;\n\tconst intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\tif (intArr.length !== padded.length / 2) {\n\t\tthrow new Error(`Invalid hex string ${hexStr}`);\n\t}\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function chunk<T>(array: readonly T[], size: number): T[][] {\n\treturn Array.from({ length: Math.ceil(array.length / size) }, (_, i) => {\n\t\treturn array.slice(i * size, (i + 1) * size);\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface PromiseWithResolvers<T> {\n\tpromise: Promise<T>;\n\tresolve: (value: T) => void;\n\treject: (error: unknown) => void;\n}\n\nexport function promiseWithResolvers<T>(): PromiseWithResolvers<T> {\n\tlet resolver!: (value: T) => void;\n\tlet rejecter!: (error: unknown) => void;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tresolver = resolve;\n\t\trejecter = reject;\n\t});\n\n\treturn {\n\t\tpromise,\n\t\tresolve: resolver,\n\t\treject: rejecter,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Copied from https://github.com/graphql/dataloader/blob/a10773043d41a56bde4219c155fcf5633e6c9bcb/src/index.js */\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nexport class DataLoader<K, V, C = K> {\n\tconstructor(batchLoadFn: DataLoader.BatchLoadFn<K, V>, options?: DataLoader.Options<K, V, C>) {\n\t\tif (typeof batchLoadFn !== 'function') {\n\t\t\tthrow new TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t`Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`,\n\t\t\t);\n\t\t}\n\t\tthis._batchLoadFn = batchLoadFn;\n\t\tthis._maxBatchSize = getValidMaxBatchSize(options);\n\t\tthis._batchScheduleFn = getValidBatchScheduleFn(options);\n\t\tthis._cacheKeyFn = getValidCacheKeyFn(options);\n\t\tthis._cacheMap = getValidCacheMap(options);\n\t\tthis._batch = null;\n\t\tthis.name = getValidName(options);\n\t}\n\n\t// Private\n\t_batchLoadFn: DataLoader.BatchLoadFn<K, V>;\n\t_maxBatchSize: number;\n\t_batchScheduleFn: (cb: () => void) => void;\n\t_cacheKeyFn: (key: K) => C;\n\t_cacheMap: DataLoader.CacheMap<C, Promise<V>> | null;\n\t_batch: Batch<K, V> | null;\n\n\t/**\n\t * Loads a key, returning a `Promise` for the value represented by that key.\n\t */\n\tload(key: K): Promise<V> {\n\t\tif (key === null || key === undefined) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`The loader.load() function must be called with a value, but got: ${String(key)}.`,\n\t\t\t);\n\t\t}\n\n\t\tconst batch = getCurrentBatch(this);\n\t\tconst cacheMap = this._cacheMap;\n\t\tlet cacheKey: C;\n\n\t\t// If caching and there is a cache-hit, return cached Promise.\n\t\tif (cacheMap) {\n\t\t\tcacheKey = this._cacheKeyFn(key);\n\t\t\tconst cachedPromise = cacheMap.get(cacheKey);\n\t\t\tif (cachedPromise) {\n\t\t\t\tconst cacheHits = batch.cacheHits || (batch.cacheHits = []);\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tcacheHits.push(() => {\n\t\t\t\t\t\tresolve(cachedPromise);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise, produce a new Promise for this key, and enqueue it to be\n\t\t// dispatched along with the current batch.\n\t\tbatch.keys.push(key);\n\t\tconst promise = new Promise<V>((resolve, reject) => {\n\t\t\tbatch.callbacks.push({ resolve, reject });\n\t\t});\n\n\t\t// If caching, cache this promise.\n\t\tif (cacheMap) {\n\t\t\tcacheMap.set(cacheKey!, promise);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Loads multiple keys, promising an array of values:\n\t *\n\t *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n\t *\n\t * This is similar to the more verbose:\n\t *\n\t *     var [ a, b ] = await Promise.all([\n\t *       myLoader.load('a'),\n\t *       myLoader.load('b')\n\t *     ]);\n\t *\n\t * However it is different in the case where any load fails. Where\n\t * Promise.all() would reject, loadMany() always resolves, however each result\n\t * is either a value or an Error instance.\n\t *\n\t *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n\t *     // c instanceof Error\n\t *\n\t */\n\tloadMany(keys: ReadonlyArray<K>): Promise<Array<V | Error>> {\n\t\tif (!isArrayLike(keys)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`,\n\t\t\t);\n\t\t}\n\t\t// Support ArrayLike by using only minimal property access\n\t\tconst loadPromises = [];\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tloadPromises.push(this.load(keys[i]).catch((error) => error));\n\t\t}\n\t\treturn Promise.all(loadPromises);\n\t}\n\n\t/**\n\t * Clears the value at `key` from the cache, if it exists. Returns itself for\n\t * method chaining.\n\t */\n\tclear(key: K): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tconst cacheKey = this._cacheKeyFn(key);\n\t\t\tcacheMap.delete(cacheKey);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clears the entire cache. To be used when some event results in unknown\n\t * invalidations across this particular `DataLoader`. Returns itself for\n\t * method chaining.\n\t */\n\tclearAll(): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tcacheMap.clear();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds the provided key and value to the cache. If the key already\n\t * exists, no change is made. Returns itself for method chaining.\n\t *\n\t * To prime the cache with an error at a key, provide an Error instance.\n\t */\n\tprime(key: K, value: V | Promise<V> | Error): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tconst cacheKey = this._cacheKeyFn(key);\n\n\t\t\t// Only add the key if it does not already exist.\n\t\t\tif (cacheMap.get(cacheKey) === undefined) {\n\t\t\t\t// Cache a rejected promise if the value is an Error, in order to match\n\t\t\t\t// the behavior of load(key).\n\t\t\t\tlet promise;\n\t\t\t\tif (value instanceof Error) {\n\t\t\t\t\tpromise = Promise.reject(value);\n\t\t\t\t\t// Since this is a case where an Error is intentionally being primed\n\t\t\t\t\t// for a given key, we want to disable unhandled promise rejection.\n\t\t\t\t\tpromise.catch(() => {});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve(value);\n\t\t\t\t}\n\t\t\t\tcacheMap.set(cacheKey, promise);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The name given to this `DataLoader` instance. Useful for APM tools.\n\t *\n\t * Is `null` if not set in the constructor.\n\t */\n\tname: string | null;\n}\n\n// Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\nconst enqueuePostPromiseJob: (fn: () => void) => void =\n\t/** @ts-ignore */\n\ttypeof process === 'object' && typeof process.nextTick === 'function'\n\t\t? function (fn) {\n\t\t\t\tif (!resolvedPromise) {\n\t\t\t\t\tresolvedPromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\tresolvedPromise.then(() => {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tprocess.nextTick(fn);\n\t\t\t\t});\n\t\t\t}\n\t\t: // @ts-ignore\n\t\t\ttypeof setImmediate === 'function'\n\t\t\t? function (fn) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tsetImmediate(fn);\n\t\t\t\t}\n\t\t\t: function (fn) {\n\t\t\t\t\tsetTimeout(fn);\n\t\t\t\t};\n\n// Private: cached resolved Promise instance\nlet resolvedPromise: Promise<void> | undefined;\n\n// Private: Describes a batch of requests\ntype Batch<K, V> = {\n\thasDispatched: boolean;\n\tkeys: Array<K>;\n\tcallbacks: Array<{\n\t\tresolve: (value: V) => void;\n\t\treject: (error: Error) => void;\n\t}>;\n\tcacheHits?: Array<() => void>;\n};\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch<K, V>(loader: DataLoader<K, V, any>): Batch<K, V> {\n\t// If there is an existing batch which has not yet dispatched and is within\n\t// the limit of the batch size, then return it.\n\tconst existingBatch = loader._batch;\n\tif (\n\t\texistingBatch !== null &&\n\t\t!existingBatch.hasDispatched &&\n\t\texistingBatch.keys.length < loader._maxBatchSize\n\t) {\n\t\treturn existingBatch;\n\t}\n\n\t// Otherwise, create a new batch for this loader.\n\tconst newBatch = { hasDispatched: false, keys: [], callbacks: [] };\n\n\t// Store it on the loader so it may be reused.\n\tloader._batch = newBatch;\n\n\t// Then schedule a task to dispatch this batch of requests.\n\tloader._batchScheduleFn(() => {\n\t\tdispatchBatch(loader, newBatch);\n\t});\n\n\treturn newBatch;\n}\n\nfunction dispatchBatch<K, V>(loader: DataLoader<K, V, any>, batch: Batch<K, V>) {\n\t// Mark this batch as having been dispatched.\n\tbatch.hasDispatched = true;\n\n\t// If there's nothing to load, resolve any cache hits and return early.\n\tif (batch.keys.length === 0) {\n\t\tresolveCacheHits(batch);\n\t\treturn;\n\t}\n\n\t// Call the provided batchLoadFn for this loader with the batch's keys and\n\t// with the loader as the `this` context.\n\tlet batchPromise;\n\ttry {\n\t\tbatchPromise = loader._batchLoadFn(batch.keys);\n\t} catch (e) {\n\t\treturn failedDispatch(\n\t\t\tloader,\n\t\t\tbatch,\n\t\t\tnew TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function ' +\n\t\t\t\t\t`errored synchronously: ${String(e)}.`,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Assert the expected response from batchLoadFn\n\tif (!batchPromise || typeof batchPromise.then !== 'function') {\n\t\treturn failedDispatch(\n\t\t\tloader,\n\t\t\tbatch,\n\t\t\tnew TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t`not return a Promise: ${String(batchPromise)}.`,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Await the resolution of the call to batchLoadFn.\n\tPromise.resolve(batchPromise)\n\t\t.then((values) => {\n\t\t\t// Assert the expected resolution from batchLoadFn.\n\t\t\tif (!isArrayLike(values)) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t\t`not return a Promise of an Array: ${String(values)}.`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (values.length !== batch.keys.length) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t\t'not return a Promise of an Array of the same length as the Array ' +\n\t\t\t\t\t\t'of keys.' +\n\t\t\t\t\t\t`\\n\\nKeys:\\n${String(batch.keys)}` +\n\t\t\t\t\t\t`\\n\\nValues:\\n${String(values)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Resolve all cache hits in the same micro-task as freshly loaded values.\n\t\t\tresolveCacheHits(batch);\n\n\t\t\t// Step through values, resolving or rejecting each Promise in the batch.\n\t\t\tfor (let i = 0; i < batch.callbacks.length; i++) {\n\t\t\t\tconst value = values[i];\n\t\t\t\tif (value instanceof Error) {\n\t\t\t\t\tbatch.callbacks[i].reject(value);\n\t\t\t\t} else {\n\t\t\t\t\tbatch.callbacks[i].resolve(value);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t.catch((error: unknown) => {\n\t\t\tfailedDispatch(loader, batch, error as Error);\n\t\t});\n}\n\n// Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\nfunction failedDispatch<K, V>(loader: DataLoader<K, V, any>, batch: Batch<K, V>, error: Error) {\n\t// Cache hits are resolved, even though the batch failed.\n\tresolveCacheHits(batch);\n\tfor (let i = 0; i < batch.keys.length; i++) {\n\t\tloader.clear(batch.keys[i]);\n\t\tbatch.callbacks[i].reject(error);\n\t}\n}\n\n// Private: Resolves the Promises for any cache hits in this batch.\nfunction resolveCacheHits(batch: Batch<any, any>) {\n\tif (batch.cacheHits) {\n\t\tfor (let i = 0; i < batch.cacheHits.length; i++) {\n\t\t\tbatch.cacheHits[i]();\n\t\t}\n\t}\n}\n\n// Private: given the DataLoader's options, produce a valid max batch size.\nfunction getValidMaxBatchSize<K, V, C>(options?: DataLoader.Options<K, V, C>): number {\n\tconst shouldBatch = !options || options.batch !== false;\n\tif (!shouldBatch) {\n\t\treturn 1;\n\t}\n\tconst maxBatchSize = options && options.maxBatchSize;\n\tif (maxBatchSize === undefined) {\n\t\treturn Infinity;\n\t}\n\tif (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n\t\tthrow new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);\n\t}\n\treturn maxBatchSize;\n}\n\n// Private\nfunction getValidBatchScheduleFn<K, V, C>(\n\toptions?: DataLoader.Options<K, V, C>,\n): (cb: () => void) => void {\n\tconst batchScheduleFn = options && options.batchScheduleFn;\n\tif (batchScheduleFn === undefined) {\n\t\treturn enqueuePostPromiseJob;\n\t}\n\tif (typeof batchScheduleFn !== 'function') {\n\t\tthrow new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);\n\t}\n\treturn batchScheduleFn;\n}\n\n// Private: given the DataLoader's options, produce a cache key function.\nfunction getValidCacheKeyFn<K, V, C>(options?: DataLoader.Options<K, V, C>): (key: K) => C {\n\tconst cacheKeyFn = options && options.cacheKeyFn;\n\tif (cacheKeyFn === undefined) {\n\t\treturn (key: K) => key as unknown as C;\n\t}\n\tif (typeof cacheKeyFn !== 'function') {\n\t\tthrow new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);\n\t}\n\treturn cacheKeyFn;\n}\n\n// Private: given the DataLoader's options, produce a CacheMap to be used.\nfunction getValidCacheMap<K, V, C>(\n\toptions?: DataLoader.Options<K, V, C>,\n): DataLoader.CacheMap<C, Promise<V>> | null {\n\tconst shouldCache = !options || options.cache !== false;\n\tif (!shouldCache) {\n\t\treturn null;\n\t}\n\tconst cacheMap = options && options.cacheMap;\n\tif (cacheMap === undefined) {\n\t\treturn new Map();\n\t}\n\tif (cacheMap !== null) {\n\t\tconst cacheFunctions = ['get', 'set', 'delete', 'clear'] as const;\n\t\tconst missingFunctions = cacheFunctions.filter(\n\t\t\t(fnName) => cacheMap && typeof cacheMap[fnName] !== 'function',\n\t\t);\n\t\tif (missingFunctions.length !== 0) {\n\t\t\tthrow new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n\t\t}\n\t}\n\treturn cacheMap;\n}\n\nfunction getValidName<K, V, C>(options?: DataLoader.Options<K, V, C>): string | null {\n\tif (options && options.name) {\n\t\treturn options.name;\n\t}\n\n\treturn null;\n}\n\nfunction isArrayLike(x: unknown): x is ArrayLike<unknown> {\n\treturn (\n\t\ttypeof x === 'object' &&\n\t\tx !== null &&\n\t\t'length' in x &&\n\t\ttypeof x.length === 'number' &&\n\t\t(x.length === 0 || (x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1)))\n\t);\n}\n\nexport declare namespace DataLoader {\n\t// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\texport type CacheMap<K, V> = {\n\t\tget(key: K): V | void;\n\t\tset(key: K, value: V): any;\n\t\tdelete(key: K): any;\n\t\tclear(): any;\n\t};\n\n\t// A Function, which when given an Array of keys, returns a Promise of an Array\n\t// of values or Errors.\n\texport type BatchLoadFn<K, V> = (keys: ReadonlyArray<K>) => PromiseLike<ArrayLike<V | Error>>;\n\n\t// Optionally turn off batching or caching or provide a cache key function or a\n\t// custom cache instance.\n\texport type Options<K, V, C = K> = {\n\t\t/**\n\t\t * Default `true`. Set to `false` to disable batching, invoking\n\t\t * `batchLoadFn` with a single load key. This is equivalent to setting\n\t\t * `maxBatchSize` to `1`.\n\t\t */\n\t\tbatch?: boolean;\n\n\t\t/**\n\t\t * Default `Infinity`. Limits the number of items that get passed in to the\n\t\t * `batchLoadFn`. May be set to `1` to disable batching.\n\t\t */\n\t\tmaxBatchSize?: number;\n\n\t\t/**\n\t\t * Default see https://github.com/graphql/dataloader#batch-scheduling.\n\t\t * A function to schedule the later execution of a batch. The function is\n\t\t * expected to call the provided callback in the immediate future.\n\t\t */\n\t\tbatchScheduleFn?: (callback: () => void) => void;\n\n\t\t/**\n\t\t * Default `true`. Set to `false` to disable memoization caching, creating a\n\t\t * new Promise and new key in the `batchLoadFn` for every load of the same\n\t\t * key. This is equivalent to setting `cacheMap` to `null`.\n\t\t */\n\t\tcache?: boolean;\n\n\t\t/**\n\t\t * Default `key => key`. Produces cache key for a given load key. Useful\n\t\t * when keys are objects and two objects should be considered equivalent.\n\t\t */\n\t\tcacheKeyFn?: (key: K) => C;\n\n\t\t/**\n\t\t * Default `new Map()`. Instance of `Map` (or an object with a similar API)\n\t\t * to be used as cache. May be set to `null` to disable caching.\n\t\t */\n\t\tcacheMap?: CacheMap<C, Promise<V>> | null;\n\n\t\t/**\n\t\t * The name given to this `DataLoader` instance. Useful for APM tools.\n\t\t *\n\t\t * Is `null` if not set in the constructor.\n\t\t */\n\t\tname?: string | null;\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number | bigint): number[] {\n\tlet bigNum = BigInt(num);\n\tconst arr: number[] = [];\n\tlet len = 0;\n\n\tif (bigNum === 0n) {\n\t\treturn [0];\n\t}\n\n\twhile (bigNum > 0) {\n\t\tarr[len] = Number(bigNum & 0x7fn);\n\t\tbigNum >>= 7n;\n\t\tif (bigNum > 0n) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0n;\n\tlet shift = 0n;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tif (len >= arr.length) {\n\t\t\tthrow new Error('ULEB decode error: buffer overflow');\n\t\t}\n\n\t\tconst byte = arr[len];\n\t\tlen += 1;\n\t\ttotal += BigInt(byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7n;\n\t}\n\n\t// TODO: return bigint in next major version\n\tif (total > BigInt(Number.MAX_SAFE_INTEGER)) {\n\t\tthrow new Error('ULEB decode error: value exceeds MAX_SAFE_INTEGER');\n\t}\n\n\treturn {\n\t\tvalue: Number(total),\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/utils';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @returns {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @returns {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView<ArrayBuffer>;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(\n\t\t\t\tthis.maxSize,\n\t\t\t\tMath.max(this.size + requiredSize, this.size + this.allocateSize),\n\t\t\t);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteBytes(bytes: Uint8Array): this {\n\t\tthis.ensureSizeOrGrow(bytes.length);\n\n\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\tthis.dataView.setUint8(this.bytePosition + i, bytes[i]);\n\t\t}\n\n\t\treturn this.shift(bytes.length);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t// oxlint-disable-next-line require-yields\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tconst result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\nimport type { EnumInputShape, EnumOutputShape, JoinString } from './types.js';\n\nexport interface BcsTypeOptions<T, Input = T, Name extends string = string> {\n\tname?: Name;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T, const Name extends string = string> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: Name;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input, Name>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input, NewName extends string = Name>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2, NewName>) {\n\t\treturn new BcsType<T2, Input2, NewName>({\n\t\t\tname: (name ?? this.name) as NewName,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array<ArrayBuffer>;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(schema: BcsType<T, Input>, bytes: Uint8Array<ArrayBuffer>) {\n\t\tthis.#schema = schema;\n\t\tthis.#bytes = bytes;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T, const Name extends string = string>({\n\tsize,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input, Name>) {\n\treturn new BcsType<T, Input, Name>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number, Name>) {\n\treturn fixedSizeBcsType<number, number, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T, const Name extends string = string>({\n\tserialize,\n\t...options\n}: {\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType<const Name extends string = string>({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: Name;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string, string, Name>) {\n\treturn new BcsType<string, string, Name>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n\nexport interface BcsStructOptions<\n\tT extends Record<string, BcsType<any>>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsType<\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t},\n\tName\n> {\n\tconstructor({ name, fields, ...options }: BcsStructOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\tsuper({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsEnumOptions<\n\tT extends Record<string, BcsType<any> | null>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t}>,\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string = string,\n> extends BcsType<\n\tEnumOutputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t}>,\n\tEnumInputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t}>,\n\tName\n> {\n\tconstructor({ fields, ...options }: BcsEnumOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields as object);\n\t\tsuper({\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${options.name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(fields, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(fields, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${options.name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(fields, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsTupleOptions<T extends readonly BcsType<any>[], Name extends string>\n\textends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname?: Name;\n\tfields: T;\n}\n\nexport class BcsTuple<\n\tconst T extends readonly BcsType<any>[],\n\tconst Name extends\n\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n> extends BcsType<\n\t{\n\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t},\n\tName\n> {\n\tconstructor({ fields, name, ...options }: BcsTupleOptions<T, Name>) {\n\t\tsuper({\n\t\t\tname: name ?? (`(${fields.map((t) => t.name).join(', ')})` as never),\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tconst size = fields[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tresult.push(field.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tfields[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== fields.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsEnum,\n\tBcsStruct,\n\tBcsTuple,\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type {\n\tEnumInputShape,\n\tEnumOutputShape,\n\tInferBcsInput,\n\tInferBcsType,\n\tJoinString,\n} from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nfunction fixedArray<T extends BcsType<any>, Name extends string = string>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction fixedArray<T, Input, Name extends string = string>(\n\tsize: number,\n\ttype: BcsType<T, Input>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, Name>,\n): BcsType<T[], Iterable<Input> & { length: number }, Name>;\nfunction fixedArray<T extends BcsType<any>, Name extends string = `${T['name']}[${number}]`>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst result: InferBcsType<T>[] = new Array(size);\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `${type.name}[${size}]`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t\tif (value.length !== size) {\n\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`>;\nfunction option<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n): BcsType<T | null, Input | null | undefined>;\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`> {\n\treturn bcs\n\t\t.enum(`Option<${type.name}>`, {\n\t\t\tNone: null,\n\t\t\tSome: type,\n\t\t})\n\t\t.transform({\n\t\t\tinput: (value: InferBcsInput<T> | null | undefined) => {\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn { None: true };\n\t\t\t\t}\n\n\t\t\t\treturn { Some: value };\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\treturn value.Some as InferBcsType<T>;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t});\n}\n\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction vector<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>,\n): BcsType<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>;\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst result: InferBcsType<T>[] = new Array(length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\twriter.writeULEB(value.length);\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `vector<${type.name}>`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n>;\nfunction map<K, V, InputK = K, InputV = V>(\n\tkeyType: BcsType<K, InputK>,\n\tvalueType: BcsType<V, InputV>,\n): BcsType<Map<K, V>, Map<InputK, InputV>, `Map<${string}, ${string}>`>;\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n> {\n\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\tinput: (value: Map<InferBcsInput<K>, InferBcsInput<V>>) => {\n\t\t\treturn [...value.entries()];\n\t\t},\n\t\toutput: (value) => {\n\t\t\tconst result = new Map<InferBcsType<K>, InferBcsType<V>>();\n\t\t\tfor (const [key, val] of value) {\n\t\t\t\tresult.set(key, val);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t});\n}\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u8') as 'u8',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u16') as 'u16',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u32') as 'u32',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u64') as 'u64',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u128') as 'u128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u256') as 'u256',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType({\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'bool') as 'bool',\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType({\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'uleb128') as 'uleb128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>, `bytes[${T}]`>({\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeBytes(new Uint8Array(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? `bytes[${size}]`) as `bytes[${T}]`,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>, 'vector<u8>'>({\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\twriter.writeBytes(array);\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'vector<u8>') as 'vector<u8>',\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'string') as 'string',\n\t\t});\n\t},\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray,\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption,\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector,\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<\n\t\tconst T extends readonly BcsType<any, any>[],\n\t\tconst Name extends\n\t\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n\t>(\n\t\tfields: T,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t) {\n\t\treturn new BcsTuple<T, Name>({\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsStruct<T>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t\t}>,\n\t\t\t\tName\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsEnum<T, Name>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap,\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst ELLIPSIS = '\\u{2026}';\n\nexport function formatAddress(address: string) {\n\tif (address.length <= 6) {\n\t\treturn address;\n\t}\n\n\tconst offset = address.startsWith('0x') ? 2 : 0;\n\n\treturn `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;\n}\n\nexport function formatDigest(digest: string) {\n\t// Use 10 first characters\n\treturn `${digest.slice(0, 10)}${ELLIPSIS}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst SUI_NS_NAME_REGEX =\n\t/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\n\nexport function isValidSuiNSName(name: string): boolean {\n\tif (name.length > MAX_SUI_NS_NAME_LENGTH) {\n\t\treturn false;\n\t}\n\n\tif (name.includes('@')) {\n\t\treturn SUI_NS_NAME_REGEX.test(name);\n\t}\n\n\treturn SUI_NS_DOMAIN_REGEX.test(name);\n}\n\nexport function normalizeSuiNSName(name: string, format: 'at' | 'dot' = 'at'): string {\n\tconst lowerCase = name.toLowerCase();\n\tlet parts;\n\n\tif (lowerCase.includes('@')) {\n\t\tif (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tconst [labels, domain] = lowerCase.split('@');\n\t\tparts = [...(labels ? labels.split('.') : []), domain];\n\t} else {\n\t\tif (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tparts = lowerCase.split('.').slice(0, -1);\n\t}\n\n\tif (format === 'dot') {\n\t\treturn `${parts.join('.')}.sui`;\n\t}\n\n\treturn `${parts.slice(0, -1).join('.')}@${parts[parts.length - 1]}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidSuiNSName } from './suins.js';\n\n/** The pattern to find an optionally versioned name */\nconst NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;\n/** The pattern for a valid version number */\nconst VERSION_REGEX = /^\\d+$/;\n/** The maximum size for an app */\nconst MAX_APP_SIZE = 64;\n/** The separator for the name */\nconst NAME_SEPARATOR = '/';\n\nexport const isValidNamedPackage = (name: string): boolean => {\n\tconst parts = name.split(NAME_SEPARATOR);\n\t// The name has to have 2 parts (without-version), or 3 parts (with version).\n\tif (parts.length < 2 || parts.length > 3) return false;\n\n\tconst [org, app, version] = parts; // split by {org} {app} {optional version}\n\n\t// If the version exists, it must be a number.\n\tif (version !== undefined && !VERSION_REGEX.test(version)) return false;\n\t// Check if the org is a valid SuiNS name.\n\tif (!isValidSuiNSName(org)) return false;\n\n\t// Check if the app is a valid name.\n\treturn NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;\n};\n\n/**\n * Checks if a type contains valid named packages.\n * This DOES NOT check if the type is a valid Move type.\n */\nexport const isValidNamedType = (type: string): boolean => {\n\t// split our type by all possible type delimeters.\n\tconst splitType = type.split(/::|<|>|,/);\n\tfor (const t of splitType) {\n\t\tif (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;\n\t}\n\t// TODO: Add `isValidStructTag` check once it's introduced.\n\treturn true;\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nimport { isValidNamedPackage } from './move-registry.js';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst isMvrPackage = isValidNamedPackage(address);\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: isMvrPackage ? address : normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\nexport const SUI_RANDOM_OBJECT_ID = normalizeSuiObjectId('0x8');\n", "/**\r\n * Internal webcrypto alias.\r\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\r\n * See utils.ts for details.\r\n * @module\r\n */\r\ndeclare const globalThis: Record<string, any> | undefined;\r\nexport const crypto: any =\r\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\r\n", "/**\r\n * Utilities for hex, bytes, CSPRNG.\r\n * @module\r\n */\r\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n\r\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\r\n// node.js versions earlier than v19 don't declare it in global scope.\r\n// For node.js, package.json#exports field mapping rewrites import\r\n// from `crypto` to `cryptoNode`, which imports native module.\r\n// Makes the utils un-importable in browsers without a bundler.\r\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\r\nimport { crypto } from '@noble/hashes/crypto';\r\n\r\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\r\nexport function isBytes(a: unknown): a is Uint8Array {\r\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\r\n}\r\n\r\n/** Asserts something is positive integer. */\r\nexport function anumber(n: number): void {\r\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\r\n}\r\n\r\n/** Asserts something is Uint8Array. */\r\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\r\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\r\n  if (lengths.length > 0 && !lengths.includes(b.length))\r\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\r\n}\r\n\r\n/** Asserts something is hash */\r\nexport function ahash(h: IHash): void {\r\n  if (typeof h !== 'function' || typeof h.create !== 'function')\r\n    throw new Error('Hash should be wrapped by utils.createHasher');\r\n  anumber(h.outputLen);\r\n  anumber(h.blockLen);\r\n}\r\n\r\n/** Asserts a hash instance has not been destroyed / finished */\r\nexport function aexists(instance: any, checkFinished = true): void {\r\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\r\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\r\n}\r\n\r\n/** Asserts output is properly-sized byte array */\r\nexport function aoutput(out: any, instance: any): void {\r\n  abytes(out);\r\n  const min = instance.outputLen;\r\n  if (out.length < min) {\r\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\r\n  }\r\n}\r\n\r\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\r\n// prettier-ignore\r\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\r\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\r\n\r\n/** Cast u8 / u16 / u32 to u8. */\r\nexport function u8(arr: TypedArray): Uint8Array {\r\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n}\r\n\r\n/** Cast u8 / u16 / u32 to u32. */\r\nexport function u32(arr: TypedArray): Uint32Array {\r\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\r\n}\r\n\r\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\r\nexport function clean(...arrays: TypedArray[]): void {\r\n  for (let i = 0; i < arrays.length; i++) {\r\n    arrays[i].fill(0);\r\n  }\r\n}\r\n\r\n/** Create DataView of an array for easy byte-level manipulation. */\r\nexport function createView(arr: TypedArray): DataView {\r\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\r\n}\r\n\r\n/** The rotate right (circular right shift) operation for uint32 */\r\nexport function rotr(word: number, shift: number): number {\r\n  return (word << (32 - shift)) | (word >>> shift);\r\n}\r\n\r\n/** The rotate left (circular left shift) operation for uint32 */\r\nexport function rotl(word: number, shift: number): number {\r\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\r\n}\r\n\r\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\r\nexport const isLE: boolean = /* @__PURE__ */ (() =>\r\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\r\n\r\n/** The byte swap operation for uint32 */\r\nexport function byteSwap(word: number): number {\r\n  return (\r\n    ((word << 24) & 0xff000000) |\r\n    ((word << 8) & 0xff0000) |\r\n    ((word >>> 8) & 0xff00) |\r\n    ((word >>> 24) & 0xff)\r\n  );\r\n}\r\n/** Conditionally byte swap if on a big-endian platform */\r\nexport const swap8IfBE: (n: number) => number = isLE\r\n  ? (n: number) => n\r\n  : (n: number) => byteSwap(n);\r\n\r\n/** @deprecated */\r\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\r\n/** In place byte swap for Uint32Array */\r\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    arr[i] = byteSwap(arr[i]);\r\n  }\r\n  return arr;\r\n}\r\n\r\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\r\n  ? (u: Uint32Array) => u\r\n  : byteSwap32;\r\n\r\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\r\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\r\n  // @ts-ignore\r\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\r\n\r\n// Array where index 0xf0 (240) is mapped to string 'f0'\r\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\r\n  i.toString(16).padStart(2, '0')\r\n);\r\n\r\n/**\r\n * Convert byte array to hex string. Uses built-in function, when available.\r\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\r\n */\r\nexport function bytesToHex(bytes: Uint8Array): string {\r\n  abytes(bytes);\r\n  // @ts-ignore\r\n  if (hasHexBuiltin) return bytes.toHex();\r\n  // pre-caching improves the speed 6x\r\n  let hex = '';\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    hex += hexes[bytes[i]];\r\n  }\r\n  return hex;\r\n}\r\n\r\n// We use optimized technique to convert hex string to byte array\r\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\r\nfunction asciiToBase16(ch: number): number | undefined {\r\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\r\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\r\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\r\n  return;\r\n}\r\n\r\n/**\r\n * Convert hex string to byte array. Uses built-in function, when available.\r\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\r\n */\r\nexport function hexToBytes(hex: string): Uint8Array {\r\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\r\n  // @ts-ignore\r\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\r\n  const hl = hex.length;\r\n  const al = hl / 2;\r\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\r\n  const array = new Uint8Array(al);\r\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\r\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\r\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\r\n    if (n1 === undefined || n2 === undefined) {\r\n      const char = hex[hi] + hex[hi + 1];\r\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\r\n    }\r\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * There is no setImmediate in browser and setTimeout is slow.\r\n * Call of async fn will return Promise, which will be fullfiled only on\r\n * next scheduler queue processing step and this is exactly what we need.\r\n */\r\nexport const nextTick = async (): Promise<void> => {};\r\n\r\n/** Returns control to thread each 'tick' ms to avoid blocking. */\r\nexport async function asyncLoop(\r\n  iters: number,\r\n  tick: number,\r\n  cb: (i: number) => void\r\n): Promise<void> {\r\n  let ts = Date.now();\r\n  for (let i = 0; i < iters; i++) {\r\n    cb(i);\r\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\r\n    const diff = Date.now() - ts;\r\n    if (diff >= 0 && diff < tick) continue;\r\n    await nextTick();\r\n    ts += diff;\r\n  }\r\n}\r\n\r\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\r\ndeclare const TextEncoder: any;\r\ndeclare const TextDecoder: any;\r\n\r\n/**\r\n * Converts string to bytes using UTF8 encoding.\r\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\r\n */\r\nexport function utf8ToBytes(str: string): Uint8Array {\r\n  if (typeof str !== 'string') throw new Error('string expected');\r\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\r\n}\r\n\r\n/**\r\n * Converts bytes to string using UTF8 encoding.\r\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\r\n */\r\nexport function bytesToUtf8(bytes: Uint8Array): string {\r\n  return new TextDecoder().decode(bytes);\r\n}\r\n\r\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\r\nexport type Input = string | Uint8Array;\r\n/**\r\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\r\n * Warning: when Uint8Array is passed, it would NOT get copied.\r\n * Keep in mind for future mutable operations.\r\n */\r\nexport function toBytes(data: Input): Uint8Array {\r\n  if (typeof data === 'string') data = utf8ToBytes(data);\r\n  abytes(data);\r\n  return data;\r\n}\r\n\r\n/** KDFs can accept string or Uint8Array for user convenience. */\r\nexport type KDFInput = string | Uint8Array;\r\n/**\r\n * Helper for KDFs: consumes uint8array or string.\r\n * When string is passed, does utf8 decoding, using TextDecoder.\r\n */\r\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\r\n  if (typeof data === 'string') data = utf8ToBytes(data);\r\n  abytes(data);\r\n  return data;\r\n}\r\n\r\n/** Copies several Uint8Arrays into one. */\r\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\r\n  let sum = 0;\r\n  for (let i = 0; i < arrays.length; i++) {\r\n    const a = arrays[i];\r\n    abytes(a);\r\n    sum += a.length;\r\n  }\r\n  const res = new Uint8Array(sum);\r\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\r\n    const a = arrays[i];\r\n    res.set(a, pad);\r\n    pad += a.length;\r\n  }\r\n  return res;\r\n}\r\n\r\ntype EmptyObj = {};\r\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\r\n  defaults: T1,\r\n  opts?: T2\r\n): T1 & T2 {\r\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\r\n    throw new Error('options should be object or undefined');\r\n  const merged = Object.assign(defaults, opts);\r\n  return merged as T1 & T2;\r\n}\r\n\r\n/** Hash interface. */\r\nexport type IHash = {\r\n  (data: Uint8Array): Uint8Array;\r\n  blockLen: number;\r\n  outputLen: number;\r\n  create: any;\r\n};\r\n\r\n/** For runtime check if class implements interface */\r\nexport abstract class Hash<T extends Hash<T>> {\r\n  abstract blockLen: number; // Bytes per block\r\n  abstract outputLen: number; // Bytes in output\r\n  abstract update(buf: Input): this;\r\n  // Writes digest into buf\r\n  abstract digestInto(buf: Uint8Array): void;\r\n  abstract digest(): Uint8Array;\r\n  /**\r\n   * Resets internal state. Makes Hash instance unusable.\r\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\r\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\r\n   */\r\n  abstract destroy(): void;\r\n  /**\r\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\r\n   * when no options are passed.\r\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\r\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\r\n   * There are no guarantees for clean-up because it's impossible in JS.\r\n   */\r\n  abstract _cloneInto(to?: T): T;\r\n  // Safe version that clones internal state\r\n  abstract clone(): T;\r\n}\r\n\r\n/**\r\n * XOF: streaming API to read digest in chunks.\r\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\r\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\r\n * destroy state, next call can require more bytes.\r\n */\r\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\r\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\r\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\r\n};\r\n\r\n/** Hash function */\r\nexport type CHash = ReturnType<typeof createHasher>;\r\n/** Hash function with output */\r\nexport type CHashO = ReturnType<typeof createOptHasher>;\r\n/** XOF with output */\r\nexport type CHashXO = ReturnType<typeof createXOFer>;\r\n\r\n/** Wraps hash function, creating an interface on top of it */\r\nexport function createHasher<T extends Hash<T>>(\r\n  hashCons: () => Hash<T>\r\n): {\r\n  (msg: Input): Uint8Array;\r\n  outputLen: number;\r\n  blockLen: number;\r\n  create(): Hash<T>;\r\n} {\r\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\r\n  const tmp = hashCons();\r\n  hashC.outputLen = tmp.outputLen;\r\n  hashC.blockLen = tmp.blockLen;\r\n  hashC.create = () => hashCons();\r\n  return hashC;\r\n}\r\n\r\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\r\n  hashCons: (opts?: T) => Hash<H>\r\n): {\r\n  (msg: Input, opts?: T): Uint8Array;\r\n  outputLen: number;\r\n  blockLen: number;\r\n  create(opts?: T): Hash<H>;\r\n} {\r\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\r\n  const tmp = hashCons({} as T);\r\n  hashC.outputLen = tmp.outputLen;\r\n  hashC.blockLen = tmp.blockLen;\r\n  hashC.create = (opts?: T) => hashCons(opts);\r\n  return hashC;\r\n}\r\n\r\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\r\n  hashCons: (opts?: T) => HashXOF<H>\r\n): {\r\n  (msg: Input, opts?: T): Uint8Array;\r\n  outputLen: number;\r\n  blockLen: number;\r\n  create(opts?: T): HashXOF<H>;\r\n} {\r\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\r\n  const tmp = hashCons({} as T);\r\n  hashC.outputLen = tmp.outputLen;\r\n  hashC.blockLen = tmp.blockLen;\r\n  hashC.create = (opts?: T) => hashCons(opts);\r\n  return hashC;\r\n}\r\nexport const wrapConstructor: typeof createHasher = createHasher;\r\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\r\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\r\n\r\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\r\nexport function randomBytes(bytesLength = 32): Uint8Array {\r\n  if (crypto && typeof crypto.getRandomValues === 'function') {\r\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\r\n  }\r\n  // Legacy Node.js compatibility\r\n  if (crypto && typeof crypto.randomBytes === 'function') {\r\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\r\n  }\r\n  throw new Error('crypto.getRandomValues must be defined');\r\n}\r\n", "/**\r\n * Internal helpers for blake hash.\r\n * @module\r\n */\r\nimport { rotr } from './utils.ts';\r\n\r\n/**\r\n * Internal blake variable.\r\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\r\n */\r\n// prettier-ignore\r\nexport const BSIGMA: Uint8Array = /* @__PURE__ */ Uint8Array.from([\r\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\r\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\r\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\r\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\r\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\r\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\r\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\r\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\r\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\r\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\r\n  // Blake1, unused in others\r\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\r\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\r\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\r\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\r\n]);\r\n\r\n// prettier-ignore\r\nexport type Num4 = { a: number; b: number; c: number; d: number; };\r\n\r\n// Mixing function G splitted in two halfs\r\nexport function G1s(a: number, b: number, c: number, d: number, x: number): Num4 {\r\n  a = (a + b + x) | 0;\r\n  d = rotr(d ^ a, 16);\r\n  c = (c + d) | 0;\r\n  b = rotr(b ^ c, 12);\r\n  return { a, b, c, d };\r\n}\r\n\r\nexport function G2s(a: number, b: number, c: number, d: number, x: number): Num4 {\r\n  a = (a + b + x) | 0;\r\n  d = rotr(d ^ a, 8);\r\n  c = (c + d) | 0;\r\n  b = rotr(b ^ c, 7);\r\n  return { a, b, c, d };\r\n}\r\n", "/**\r\n * Internal Merkle-Damgard hash utils.\r\n * @module\r\n */\r\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\r\n\r\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\r\nexport function setBigUint64(\r\n  view: DataView,\r\n  byteOffset: number,\r\n  value: bigint,\r\n  isLE: boolean\r\n): void {\r\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\r\n  const _32n = BigInt(32);\r\n  const _u32_max = BigInt(0xffffffff);\r\n  const wh = Number((value >> _32n) & _u32_max);\r\n  const wl = Number(value & _u32_max);\r\n  const h = isLE ? 4 : 0;\r\n  const l = isLE ? 0 : 4;\r\n  view.setUint32(byteOffset + h, wh, isLE);\r\n  view.setUint32(byteOffset + l, wl, isLE);\r\n}\r\n\r\n/** Choice: a ? b : c */\r\nexport function Chi(a: number, b: number, c: number): number {\r\n  return (a & b) ^ (~a & c);\r\n}\r\n\r\n/** Majority function, true if any two inputs is true. */\r\nexport function Maj(a: number, b: number, c: number): number {\r\n  return (a & b) ^ (a & c) ^ (b & c);\r\n}\r\n\r\n/**\r\n * Merkle-Damgard hash construction base class.\r\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\r\n */\r\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\r\n  protected abstract process(buf: DataView, offset: number): void;\r\n  protected abstract get(): number[];\r\n  protected abstract set(...args: number[]): void;\r\n  abstract destroy(): void;\r\n  protected abstract roundClean(): void;\r\n\r\n  readonly blockLen: number;\r\n  readonly outputLen: number;\r\n  readonly padOffset: number;\r\n  readonly isLE: boolean;\r\n\r\n  // For partial updates less than block size\r\n  protected buffer: Uint8Array;\r\n  protected view: DataView;\r\n  protected finished = false;\r\n  protected length = 0;\r\n  protected pos = 0;\r\n  protected destroyed = false;\r\n\r\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\r\n    super();\r\n    this.blockLen = blockLen;\r\n    this.outputLen = outputLen;\r\n    this.padOffset = padOffset;\r\n    this.isLE = isLE;\r\n    this.buffer = new Uint8Array(blockLen);\r\n    this.view = createView(this.buffer);\r\n  }\r\n  update(data: Input): this {\r\n    aexists(this);\r\n    data = toBytes(data);\r\n    abytes(data);\r\n    const { view, buffer, blockLen } = this;\r\n    const len = data.length;\r\n    for (let pos = 0; pos < len; ) {\r\n      const take = Math.min(blockLen - this.pos, len - pos);\r\n      // Fast path: we have at least one block in input, cast it to view and process\r\n      if (take === blockLen) {\r\n        const dataView = createView(data);\r\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\r\n        continue;\r\n      }\r\n      buffer.set(data.subarray(pos, pos + take), this.pos);\r\n      this.pos += take;\r\n      pos += take;\r\n      if (this.pos === blockLen) {\r\n        this.process(view, 0);\r\n        this.pos = 0;\r\n      }\r\n    }\r\n    this.length += data.length;\r\n    this.roundClean();\r\n    return this;\r\n  }\r\n  digestInto(out: Uint8Array): void {\r\n    aexists(this);\r\n    aoutput(out, this);\r\n    this.finished = true;\r\n    // Padding\r\n    // We can avoid allocation of buffer for padding completely if it\r\n    // was previously not allocated here. But it won't change performance.\r\n    const { buffer, view, blockLen, isLE } = this;\r\n    let { pos } = this;\r\n    // append the bit '1' to the message\r\n    buffer[pos++] = 0b10000000;\r\n    clean(this.buffer.subarray(pos));\r\n    // we have less than padOffset left in buffer, so we cannot put length in\r\n    // current block, need process it and pad again\r\n    if (this.padOffset > blockLen - pos) {\r\n      this.process(view, 0);\r\n      pos = 0;\r\n    }\r\n    // Pad until full block byte with zeros\r\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\r\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\r\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\r\n    // So we just write lowest 64 bits of that value.\r\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\r\n    this.process(view, 0);\r\n    const oview = createView(out);\r\n    const len = this.outputLen;\r\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\r\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\r\n    const outLen = len / 4;\r\n    const state = this.get();\r\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\r\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\r\n  }\r\n  digest(): Uint8Array {\r\n    const { buffer, outputLen } = this;\r\n    this.digestInto(buffer);\r\n    const res = buffer.slice(0, outputLen);\r\n    this.destroy();\r\n    return res;\r\n  }\r\n  _cloneInto(to?: T): T {\r\n    to ||= new (this.constructor as any)() as T;\r\n    to.set(...this.get());\r\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\r\n    to.destroyed = destroyed;\r\n    to.finished = finished;\r\n    to.length = length;\r\n    to.pos = pos;\r\n    if (length % blockLen) to.buffer.set(buffer);\r\n    return to;\r\n  }\r\n  clone(): T {\r\n    return this._cloneInto();\r\n  }\r\n}\r\n\r\n/**\r\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\r\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\r\n */\r\n\r\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\r\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\r\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\r\n]);\r\n\r\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\r\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\r\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\r\n]);\r\n\r\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\r\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\r\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\r\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\r\n]);\r\n\r\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\r\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\r\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\r\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\r\n]);\r\n", "/**\r\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\r\n * @todo re-check https://issues.chromium.org/issues/42212588\r\n * @module\r\n */\r\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\r\nconst _32n = /* @__PURE__ */ BigInt(32);\r\n\r\nfunction fromBig(\r\n  n: bigint,\r\n  le = false\r\n): {\r\n  h: number;\r\n  l: number;\r\n} {\r\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\r\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\r\n}\r\n\r\nfunction split(lst: bigint[], le = false): Uint32Array[] {\r\n  const len = lst.length;\r\n  let Ah = new Uint32Array(len);\r\n  let Al = new Uint32Array(len);\r\n  for (let i = 0; i < len; i++) {\r\n    const { h, l } = fromBig(lst[i], le);\r\n    [Ah[i], Al[i]] = [h, l];\r\n  }\r\n  return [Ah, Al];\r\n}\r\n\r\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\r\n// for Shift in [0, 32)\r\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\r\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in [1, 32)\r\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\r\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\r\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\r\n// Right rotate for shift===32 (just swaps l&h)\r\nconst rotr32H = (_h: number, l: number): number => l;\r\nconst rotr32L = (h: number, _l: number): number => h;\r\n// Left rotate for Shift in [1, 32)\r\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\r\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\r\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\r\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\r\n\r\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\r\n// simple take carry out of low bit sum by shift, we need to use division.\r\nfunction add(\r\n  Ah: number,\r\n  Al: number,\r\n  Bh: number,\r\n  Bl: number\r\n): {\r\n  h: number;\r\n  l: number;\r\n} {\r\n  const l = (Al >>> 0) + (Bl >>> 0);\r\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\r\n}\r\n// Addition with more than 2 elements\r\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\r\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\r\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\r\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\r\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\r\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\r\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\r\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\r\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\r\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\r\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\r\n\r\n// prettier-ignore\r\nexport {\r\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\r\n};\r\n// prettier-ignore\r\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\r\n  fromBig, split, toBig,\r\n  shrSH, shrSL,\r\n  rotrSH, rotrSL, rotrBH, rotrBL,\r\n  rotr32H, rotr32L,\r\n  rotlSH, rotlSL, rotlBH, rotlBL,\r\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\r\n};\r\nexport default u64;\r\n", "/**\r\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\r\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\r\n * @module\r\n */\r\nimport { BSIGMA, G1s, G2s } from './_blake.ts';\r\nimport { SHA256_IV } from './_md.ts';\r\nimport * as u64 from './_u64.ts';\r\n// prettier-ignore\r\nimport {\r\n  abytes, aexists, anumber, aoutput,\r\n  clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32,\r\n  type CHashO, type Input\r\n} from './utils.ts';\r\n\r\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\r\nexport type Blake2Opts = {\r\n  dkLen?: number;\r\n  key?: Input;\r\n  salt?: Input;\r\n  personalization?: Input;\r\n};\r\n\r\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\r\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\r\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\r\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\r\n]);\r\n// Temporary buffer\r\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\r\n\r\n// Mixing function G splitted in two halfs\r\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\r\n  // NOTE: V is LE here\r\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\r\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\r\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\r\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\r\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\r\n  // v[a] = (v[a] + v[b] + x) | 0;\r\n  let ll = u64.add3L(Al, Bl, Xl);\r\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\r\n  Al = ll | 0;\r\n  // v[d] = rotr(v[d] ^ v[a], 32)\r\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\r\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\r\n  // v[c] = (v[c] + v[d]) | 0;\r\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\r\n  // v[b] = rotr(v[b] ^ v[c], 24)\r\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\r\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\r\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\r\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\r\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\r\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\r\n}\r\n\r\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\r\n  // NOTE: V is LE here\r\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\r\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\r\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\r\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\r\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\r\n  // v[a] = (v[a] + v[b] + x) | 0;\r\n  let ll = u64.add3L(Al, Bl, Xl);\r\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\r\n  Al = ll | 0;\r\n  // v[d] = rotr(v[d] ^ v[a], 16)\r\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\r\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\r\n  // v[c] = (v[c] + v[d]) | 0;\r\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\r\n  // v[b] = rotr(v[b] ^ v[c], 63)\r\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\r\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\r\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\r\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\r\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\r\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\r\n}\r\n\r\nfunction checkBlake2Opts(\r\n  outputLen: number,\r\n  opts: Blake2Opts | undefined = {},\r\n  keyLen: number,\r\n  saltLen: number,\r\n  persLen: number\r\n) {\r\n  anumber(keyLen);\r\n  if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\r\n  const { key, salt, personalization } = opts;\r\n  if (key !== undefined && (key.length < 1 || key.length > keyLen))\r\n    throw new Error('key length must be undefined or 1..' + keyLen);\r\n  if (salt !== undefined && salt.length !== saltLen)\r\n    throw new Error('salt must be undefined or ' + saltLen);\r\n  if (personalization !== undefined && personalization.length !== persLen)\r\n    throw new Error('personalization must be undefined or ' + persLen);\r\n}\r\n\r\n/** Class, from which others are subclassed. */\r\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\r\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\r\n  protected abstract get(): number[];\r\n  protected abstract set(...args: number[]): void;\r\n  abstract destroy(): void;\r\n  protected buffer: Uint8Array;\r\n  protected buffer32: Uint32Array;\r\n  protected finished = false;\r\n  protected destroyed = false;\r\n  protected length: number = 0;\r\n  protected pos: number = 0;\r\n  readonly blockLen: number;\r\n  readonly outputLen: number;\r\n\r\n  constructor(blockLen: number, outputLen: number) {\r\n    super();\r\n    anumber(blockLen);\r\n    anumber(outputLen);\r\n    this.blockLen = blockLen;\r\n    this.outputLen = outputLen;\r\n    this.buffer = new Uint8Array(blockLen);\r\n    this.buffer32 = u32(this.buffer);\r\n  }\r\n  update(data: Input): this {\r\n    aexists(this);\r\n    data = toBytes(data);\r\n    abytes(data);\r\n    // Main difference with other hashes: there is flag for last block,\r\n    // so we cannot process current block before we know that there\r\n    // is the next one. This significantly complicates logic and reduces ability\r\n    // to do zero-copy processing\r\n    const { blockLen, buffer, buffer32 } = this;\r\n    const len = data.length;\r\n    const offset = data.byteOffset;\r\n    const buf = data.buffer;\r\n    for (let pos = 0; pos < len; ) {\r\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\r\n      if (this.pos === blockLen) {\r\n        swap32IfBE(buffer32);\r\n        this.compress(buffer32, 0, false);\r\n        swap32IfBE(buffer32);\r\n        this.pos = 0;\r\n      }\r\n      const take = Math.min(blockLen - this.pos, len - pos);\r\n      const dataOffset = offset + pos;\r\n      // full block && aligned to 4 bytes && not last in input\r\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\r\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\r\n        swap32IfBE(data32);\r\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\r\n          this.length += blockLen;\r\n          this.compress(data32, pos32, false);\r\n        }\r\n        swap32IfBE(data32);\r\n        continue;\r\n      }\r\n      buffer.set(data.subarray(pos, pos + take), this.pos);\r\n      this.pos += take;\r\n      this.length += take;\r\n      pos += take;\r\n    }\r\n    return this;\r\n  }\r\n  digestInto(out: Uint8Array): void {\r\n    aexists(this);\r\n    aoutput(out, this);\r\n    const { pos, buffer32 } = this;\r\n    this.finished = true;\r\n    // Padding\r\n    clean(this.buffer.subarray(pos));\r\n    swap32IfBE(buffer32);\r\n    this.compress(buffer32, 0, true);\r\n    swap32IfBE(buffer32);\r\n    const out32 = u32(out);\r\n    this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\r\n  }\r\n  digest(): Uint8Array {\r\n    const { buffer, outputLen } = this;\r\n    this.digestInto(buffer);\r\n    const res = buffer.slice(0, outputLen);\r\n    this.destroy();\r\n    return res;\r\n  }\r\n  _cloneInto(to?: T): T {\r\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\r\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\r\n    to.set(...this.get());\r\n    to.buffer.set(buffer);\r\n    to.destroyed = destroyed;\r\n    to.finished = finished;\r\n    to.length = length;\r\n    to.pos = pos;\r\n    // @ts-ignore\r\n    to.outputLen = outputLen;\r\n    return to;\r\n  }\r\n  clone(): T {\r\n    return this._cloneInto();\r\n  }\r\n}\r\n\r\nexport class BLAKE2b extends BLAKE2<BLAKE2b> {\r\n  // Same as SHA-512, but LE\r\n  private v0l = B2B_IV[0] | 0;\r\n  private v0h = B2B_IV[1] | 0;\r\n  private v1l = B2B_IV[2] | 0;\r\n  private v1h = B2B_IV[3] | 0;\r\n  private v2l = B2B_IV[4] | 0;\r\n  private v2h = B2B_IV[5] | 0;\r\n  private v3l = B2B_IV[6] | 0;\r\n  private v3h = B2B_IV[7] | 0;\r\n  private v4l = B2B_IV[8] | 0;\r\n  private v4h = B2B_IV[9] | 0;\r\n  private v5l = B2B_IV[10] | 0;\r\n  private v5h = B2B_IV[11] | 0;\r\n  private v6l = B2B_IV[12] | 0;\r\n  private v6h = B2B_IV[13] | 0;\r\n  private v7l = B2B_IV[14] | 0;\r\n  private v7h = B2B_IV[15] | 0;\r\n\r\n  constructor(opts: Blake2Opts = {}) {\r\n    const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\r\n    super(128, olen);\r\n    checkBlake2Opts(olen, opts, 64, 16, 16);\r\n    let { key, personalization, salt } = opts;\r\n    let keyLength = 0;\r\n    if (key !== undefined) {\r\n      key = toBytes(key);\r\n      keyLength = key.length;\r\n    }\r\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\r\n    if (salt !== undefined) {\r\n      salt = toBytes(salt);\r\n      const slt = u32(salt);\r\n      this.v4l ^= swap8IfBE(slt[0]);\r\n      this.v4h ^= swap8IfBE(slt[1]);\r\n      this.v5l ^= swap8IfBE(slt[2]);\r\n      this.v5h ^= swap8IfBE(slt[3]);\r\n    }\r\n    if (personalization !== undefined) {\r\n      personalization = toBytes(personalization);\r\n      const pers = u32(personalization);\r\n      this.v6l ^= swap8IfBE(pers[0]);\r\n      this.v6h ^= swap8IfBE(pers[1]);\r\n      this.v7l ^= swap8IfBE(pers[2]);\r\n      this.v7h ^= swap8IfBE(pers[3]);\r\n    }\r\n    if (key !== undefined) {\r\n      // Pad to blockLen and update\r\n      const tmp = new Uint8Array(this.blockLen);\r\n      tmp.set(key);\r\n      this.update(tmp);\r\n    }\r\n  }\r\n  // prettier-ignore\r\n  protected get(): [\r\n    number, number, number, number, number, number, number, number,\r\n    number, number, number, number, number, number, number, number\r\n  ] {\r\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\r\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\r\n  }\r\n  // prettier-ignore\r\n  protected set(\r\n    v0l: number, v0h: number, v1l: number, v1h: number,\r\n    v2l: number, v2h: number, v3l: number, v3h: number,\r\n    v4l: number, v4h: number, v5l: number, v5h: number,\r\n    v6l: number, v6h: number, v7l: number, v7h: number\r\n  ): void {\r\n    this.v0l = v0l | 0;\r\n    this.v0h = v0h | 0;\r\n    this.v1l = v1l | 0;\r\n    this.v1h = v1h | 0;\r\n    this.v2l = v2l | 0;\r\n    this.v2h = v2h | 0;\r\n    this.v3l = v3l | 0;\r\n    this.v3h = v3h | 0;\r\n    this.v4l = v4l | 0;\r\n    this.v4h = v4h | 0;\r\n    this.v5l = v5l | 0;\r\n    this.v5h = v5h | 0;\r\n    this.v6l = v6l | 0;\r\n    this.v6h = v6h | 0;\r\n    this.v7l = v7l | 0;\r\n    this.v7h = v7h | 0;\r\n  }\r\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\r\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\r\n    BBUF.set(B2B_IV, 16); // Second half from IV.\r\n    let { h, l } = u64.fromBig(BigInt(this.length));\r\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\r\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\r\n    // Invert all bits for last block\r\n    if (isLast) {\r\n      BBUF[28] = ~BBUF[28];\r\n      BBUF[29] = ~BBUF[29];\r\n    }\r\n    let j = 0;\r\n    const s = BSIGMA;\r\n    for (let i = 0; i < 12; i++) {\r\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\r\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\r\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\r\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\r\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\r\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\r\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\r\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\r\n\r\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\r\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\r\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\r\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\r\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\r\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\r\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\r\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\r\n    }\r\n    this.v0l ^= BBUF[0] ^ BBUF[16];\r\n    this.v0h ^= BBUF[1] ^ BBUF[17];\r\n    this.v1l ^= BBUF[2] ^ BBUF[18];\r\n    this.v1h ^= BBUF[3] ^ BBUF[19];\r\n    this.v2l ^= BBUF[4] ^ BBUF[20];\r\n    this.v2h ^= BBUF[5] ^ BBUF[21];\r\n    this.v3l ^= BBUF[6] ^ BBUF[22];\r\n    this.v3h ^= BBUF[7] ^ BBUF[23];\r\n    this.v4l ^= BBUF[8] ^ BBUF[24];\r\n    this.v4h ^= BBUF[9] ^ BBUF[25];\r\n    this.v5l ^= BBUF[10] ^ BBUF[26];\r\n    this.v5h ^= BBUF[11] ^ BBUF[27];\r\n    this.v6l ^= BBUF[12] ^ BBUF[28];\r\n    this.v6h ^= BBUF[13] ^ BBUF[29];\r\n    this.v7l ^= BBUF[14] ^ BBUF[30];\r\n    this.v7h ^= BBUF[15] ^ BBUF[31];\r\n    clean(BBUF);\r\n  }\r\n  destroy(): void {\r\n    this.destroyed = true;\r\n    clean(this.buffer32);\r\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n  }\r\n}\r\n\r\n/**\r\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\r\n * @param msg - message that would be hashed\r\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\r\n */\r\nexport const blake2b: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2b, Blake2Opts>(\r\n  (opts) => new BLAKE2b(opts)\r\n);\r\n\r\n// =================\r\n// Blake2S\r\n// =================\r\n\r\n// prettier-ignore\r\nexport type Num16 = {\r\n  v0: number; v1: number; v2: number; v3: number;\r\n  v4: number; v5: number; v6: number; v7: number;\r\n  v8: number; v9: number; v10: number; v11: number;\r\n  v12: number; v13: number; v14: number; v15: number;\r\n};\r\n\r\n// prettier-ignore\r\nexport function compress(s: Uint8Array, offset: number, msg: Uint32Array, rounds: number,\r\n  v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number,\r\n  v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\r\n): Num16 {\r\n  let j = 0;\r\n  for (let i = 0; i < rounds; i++) {\r\n    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\r\n    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\r\n    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\r\n    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\r\n    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\r\n    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\r\n    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\r\n    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\r\n\r\n    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\r\n    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\r\n    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\r\n    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\r\n    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\r\n    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\r\n    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\r\n    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\r\n  }\r\n  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\r\n}\r\n\r\nconst B2S_IV = SHA256_IV;\r\nexport class BLAKE2s extends BLAKE2<BLAKE2s> {\r\n  // Internal state, same as SHA-256\r\n  private v0 = B2S_IV[0] | 0;\r\n  private v1 = B2S_IV[1] | 0;\r\n  private v2 = B2S_IV[2] | 0;\r\n  private v3 = B2S_IV[3] | 0;\r\n  private v4 = B2S_IV[4] | 0;\r\n  private v5 = B2S_IV[5] | 0;\r\n  private v6 = B2S_IV[6] | 0;\r\n  private v7 = B2S_IV[7] | 0;\r\n\r\n  constructor(opts: Blake2Opts = {}) {\r\n    const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\r\n    super(64, olen);\r\n    checkBlake2Opts(olen, opts, 32, 8, 8);\r\n    let { key, personalization, salt } = opts;\r\n    let keyLength = 0;\r\n    if (key !== undefined) {\r\n      key = toBytes(key);\r\n      keyLength = key.length;\r\n    }\r\n    this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\r\n    if (salt !== undefined) {\r\n      salt = toBytes(salt);\r\n      const slt = u32(salt as Uint8Array);\r\n      this.v4 ^= swap8IfBE(slt[0]);\r\n      this.v5 ^= swap8IfBE(slt[1]);\r\n    }\r\n    if (personalization !== undefined) {\r\n      personalization = toBytes(personalization);\r\n      const pers = u32(personalization as Uint8Array);\r\n      this.v6 ^= swap8IfBE(pers[0]);\r\n      this.v7 ^= swap8IfBE(pers[1]);\r\n    }\r\n    if (key !== undefined) {\r\n      // Pad to blockLen and update\r\n      abytes(key);\r\n      const tmp = new Uint8Array(this.blockLen);\r\n      tmp.set(key);\r\n      this.update(tmp);\r\n    }\r\n  }\r\n  protected get(): [number, number, number, number, number, number, number, number] {\r\n    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\r\n    return [v0, v1, v2, v3, v4, v5, v6, v7];\r\n  }\r\n  // prettier-ignore\r\n  protected set(\r\n    v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number\r\n  ): void {\r\n    this.v0 = v0 | 0;\r\n    this.v1 = v1 | 0;\r\n    this.v2 = v2 | 0;\r\n    this.v3 = v3 | 0;\r\n    this.v4 = v4 | 0;\r\n    this.v5 = v5 | 0;\r\n    this.v6 = v6 | 0;\r\n    this.v7 = v7 | 0;\r\n  }\r\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\r\n    const { h, l } = u64.fromBig(BigInt(this.length));\r\n    // prettier-ignore\r\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\r\n      compress(\r\n        BSIGMA, offset, msg, 10,\r\n        this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7,\r\n        B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]\r\n      );\r\n    this.v0 ^= v0 ^ v8;\r\n    this.v1 ^= v1 ^ v9;\r\n    this.v2 ^= v2 ^ v10;\r\n    this.v3 ^= v3 ^ v11;\r\n    this.v4 ^= v4 ^ v12;\r\n    this.v5 ^= v5 ^ v13;\r\n    this.v6 ^= v6 ^ v14;\r\n    this.v7 ^= v7 ^ v15;\r\n  }\r\n  destroy(): void {\r\n    this.destroyed = true;\r\n    clean(this.buffer32);\r\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\r\n  }\r\n}\r\n\r\n/**\r\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\r\n * @param msg - message that would be hashed\r\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\r\n */\r\nexport const blake2s: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2s, Blake2Opts>(\r\n  (opts) => new BLAKE2s(opts)\r\n);\r\n", "/**\r\n * Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.\r\n * @module\r\n * @deprecated\r\n */\r\nimport { BLAKE2b as B2B, blake2b as b2b } from './blake2.ts';\r\n/** @deprecated Use import from `noble/hashes/blake2` module */\r\nexport const BLAKE2b: typeof B2B = B2B;\r\n/** @deprecated Use import from `noble/hashes/blake2` module */\r\nexport const blake2b: typeof b2b = b2b;\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n\nexport function normalizeTypeTag(type: string): string {\n\treturn TypeTagSerializer.tagToString(TypeTagSerializer.parseFromStr(type));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.byteVector().transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n\tConsensusAddressOwner: bcs.struct('ConsensusAddressOwner', {\n\t\towner: Address,\n\t\tstartVersion: bcs.u64(),\n\t}),\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.byteVector().transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.bytes(64),\n\tSecp256k1: bcs.bytes(64),\n\tSecp256r1: bcs.bytes(64),\n\tZkLogin: bcs.byteVector(),\n\tPasskey: bcs.byteVector(),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.bytes(32),\n\tSecp256k1: bcs.bytes(33),\n\tSecp256r1: bcs.bytes(33),\n\tZkLogin: bcs.byteVector(),\n\tPasskey: bcs.bytes(33),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.byteVector().transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.byteVector(),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.byteVector(),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, Owner, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.byteVector() }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n\tExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n\t\t'ExecutionCancelledDueToSharedObjectCongestion',\n\t\t{\n\t\t\tcongestedObjects: bcs.vector(Address),\n\t\t},\n\t),\n\tAddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n\t\taddress: Address,\n\t\tcoinType: bcs.string(),\n\t}),\n\tCoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n\tExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\t// TODO: these have been renamed to MutateConsensusStreamEnded and ReadConsensusStreamEnded\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n\tCancelled: bcs.u64(),\n\tPerEpochConfig: null,\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { BcsType } from '@mysten/bcs';\n\nimport { Address } from './bcs.js';\n\nexport type BasePureType =\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| 'bool'\n\t| 'id'\n\t| 'string'\n\t| 'address';\n\ninterface PureShapeByType {\n\tu8: number;\n\tu16: number;\n\tu32: number;\n\tu64: bigint | string | number;\n\tu128: bigint | string | number;\n\tu256: bigint | string | number;\n\tbool: boolean;\n\tstring: string;\n\tid: string | Uint8Array;\n\taddress: string | Uint8Array;\n}\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n\t? PureTypeName\n\t: T extends `vector<${infer U}>`\n\t\t? ValidPureTypeName<U>\n\t\t: T extends `option<${infer U}>`\n\t\t\t? ValidPureTypeName<U>\n\t\t\t: PureTypeValidationError<T>;\n\nexport type ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n\t? PureShapeByType[T]\n\t: T extends `vector<${infer U extends PureTypeName}>`\n\t\t? ShapeFromPureTypeName<U>[]\n\t\t: T extends `option<${infer U extends PureTypeName}>`\n\t\t\t? ShapeFromPureTypeName<U> | null\n\t\t\t: never;\n\ntype PureTypeValidationError<T extends string> = {\n\terror: `Invalid Pure type name: ${T}`;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\nexport function pureBcsSchemaFromTypeName<T extends PureTypeName>(\n\tname: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n\tswitch (name) {\n\t\tcase 'u8':\n\t\t\treturn bcs.u8() as never;\n\t\tcase 'u16':\n\t\t\treturn bcs.u16() as never;\n\t\tcase 'u32':\n\t\t\treturn bcs.u32() as never;\n\t\tcase 'u64':\n\t\t\treturn bcs.u64() as never;\n\t\tcase 'u128':\n\t\t\treturn bcs.u128() as never;\n\t\tcase 'u256':\n\t\t\treturn bcs.u256() as never;\n\t\tcase 'bool':\n\t\t\treturn bcs.bool() as never;\n\t\tcase 'string':\n\t\t\treturn bcs.string() as never;\n\t\tcase 'id':\n\t\tcase 'address':\n\t\t\treturn Address as never;\n\t}\n\n\tconst generic = (name as string).match(/^(vector|option)<(.+)>$/);\n\tif (generic) {\n\t\tconst [kind, inner] = generic.slice(1);\n\t\tif (kind === 'vector') {\n\t\t\treturn bcs.vector(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t} else {\n\t\t\treturn bcs.option(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t}\n\t}\n\n\tthrow new Error(`Invalid Pure type name: ${name}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, BcsStruct, BcsEnum, BcsTuple, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionEffects,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n};\nexport {\n\tpureBcsSchemaFromTypeName,\n\ttype ShapeFromPureTypeName,\n\ttype PureTypeName,\n} from './pure.js';\n\nexport { suiBcs as bcs };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toHex } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nimport type { TypeTag } from '../bcs/bcs.js';\nimport { bcs } from '../bcs/index.js';\n\nexport function deriveDynamicFieldID(\n\tparentId: string,\n\ttypeTag: typeof TypeTag.$inferInput,\n\tkey: Uint8Array,\n) {\n\tconst address = bcs.Address.serialize(parentId).toBytes();\n\tconst tag = bcs.TypeTag.serialize(typeTag).toBytes();\n\tconst keyLength = bcs.u64().serialize(key.length).toBytes();\n\n\tconst hash = blake2b.create({\n\t\tdkLen: 32,\n\t});\n\n\thash.update(new Uint8Array([0xf0]));\n\thash.update(address);\n\thash.update(keyLength);\n\thash.update(key);\n\thash.update(tag);\n\n\treturn `0x${toHex(hash.digest().slice(0, 32))}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n\tconst struct =\n\t\ttypeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n\treturn (\n\t\t!!struct &&\n\t\tnormalizeSuiAddress(struct.package) === normalizeSuiAddress('0x2') &&\n\t\tstruct.module === 'tx_context' &&\n\t\tstruct.type === 'TxContext'\n\t);\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\tif (typeSignature.vector === 'u8') {\n\t\t\treturn bcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) =>\n\t\t\t\t\ttypeof val === 'string' ? new TextEncoder().encode(val) : val,\n\t\t\t\toutput: (val) => val,\n\t\t\t});\n\t\t}\n\t\tconst type = getPureBcsSchema(typeSignature.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t}\n\n\tif ('datatype' in typeSignature) {\n\t\tconst pkg = normalizeSuiAddress(typeSignature.datatype.package);\n\n\t\tif (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n\t\t\t) {\n\t\t\t\tconst type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tpkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) &&\n\t\t\ttypeSignature.datatype.module === OBJECT_MODULE_NAME &&\n\t\t\ttypeSignature.datatype.type === ID_STRUCT_NAME\n\t\t) {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignature {\n\tif (typeof type === 'object' && 'Reference' in type) {\n\t\treturn {\n\t\t\tref: '&',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n\t\t};\n\t}\n\tif (typeof type === 'object' && 'MutableReference' in type) {\n\t\treturn {\n\t\t\tref: '&mut',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n\t\t};\n\t}\n\n\treturn {\n\t\tref: null,\n\t\tbody: normalizedTypeToMoveTypeSignatureBody(type),\n\t};\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n\t}\n\n\tif ('Struct' in type) {\n\t\treturn {\n\t\t\tdatatype: {\n\t\t\t\tpackage: type.Struct.address,\n\t\t\t\tmodule: type.Struct.module,\n\t\t\t\ttype: type.Struct.name,\n\t\t\t\ttypeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody),\n\t\t\t},\n\t\t};\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\treturn { typeParameter: type.TypeParameter };\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n\ttypeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\treturn bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n\t}\n\n\tthrow new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n\treturn {\n\t\t$kind: 'Pure',\n\t\tPure: {\n\t\t\tbytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n\t\t},\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'ImmOrOwnedObject',\n\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({\n\t\tobjectId,\n\t\tmutable,\n\t\tinitialSharedVersion,\n\t}: {\n\t\tobjectId: string;\n\t\tmutable: boolean;\n\t\tinitialSharedVersion: number | string;\n\t}): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'SharedObject',\n\t\t\t\tSharedObject: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'Receiving',\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n", "// src/actions/await/awaitAsync.ts\r\nfunction awaitAsync() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"await\",\r\n    reference: awaitAsync,\r\n    async: true,\r\n    async _run(dataset) {\r\n      dataset.value = await dataset.value;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/regex.ts\r\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\r\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\r\nvar DECIMAL_REGEX = /^\\d+$/u;\r\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\r\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\r\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\r\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\r\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\r\nvar IPV4_REGEX = (\r\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\r\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\r\n);\r\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\r\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\r\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\r\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\r\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\r\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\r\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\r\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\r\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\r\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\r\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\r\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\r\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\r\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\r\n\r\n// src/storages/globalConfig/globalConfig.ts\r\nvar store;\r\nfunction setGlobalConfig(config2) {\r\n  store = { ...store, ...config2 };\r\n}\r\nfunction getGlobalConfig(config2) {\r\n  return {\r\n    lang: config2?.lang ?? store?.lang,\r\n    message: config2?.message,\r\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\r\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\r\n  };\r\n}\r\nfunction deleteGlobalConfig() {\r\n  store = void 0;\r\n}\r\n\r\n// src/storages/globalMessage/globalMessage.ts\r\nvar store2;\r\nfunction setGlobalMessage(message, lang) {\r\n  if (!store2) store2 = /* @__PURE__ */ new Map();\r\n  store2.set(lang, message);\r\n}\r\nfunction getGlobalMessage(lang) {\r\n  return store2?.get(lang);\r\n}\r\nfunction deleteGlobalMessage(lang) {\r\n  store2?.delete(lang);\r\n}\r\n\r\n// src/storages/schemaMessage/schemaMessage.ts\r\nvar store3;\r\nfunction setSchemaMessage(message, lang) {\r\n  if (!store3) store3 = /* @__PURE__ */ new Map();\r\n  store3.set(lang, message);\r\n}\r\nfunction getSchemaMessage(lang) {\r\n  return store3?.get(lang);\r\n}\r\nfunction deleteSchemaMessage(lang) {\r\n  store3?.delete(lang);\r\n}\r\n\r\n// src/storages/specificMessage/specificMessage.ts\r\nvar store4;\r\nfunction setSpecificMessage(reference, message, lang) {\r\n  if (!store4) store4 = /* @__PURE__ */ new Map();\r\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\r\n  store4.get(reference).set(lang, message);\r\n}\r\nfunction getSpecificMessage(reference, lang) {\r\n  return store4?.get(reference)?.get(lang);\r\n}\r\nfunction deleteSpecificMessage(reference, lang) {\r\n  store4?.get(reference)?.delete(lang);\r\n}\r\n\r\n// src/utils/_stringify/_stringify.ts\r\nfunction _stringify(input) {\r\n  const type = typeof input;\r\n  if (type === \"string\") {\r\n    return `\"${input}\"`;\r\n  }\r\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\r\n    return `${input}`;\r\n  }\r\n  if (type === \"object\" || type === \"function\") {\r\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\r\n  }\r\n  return type;\r\n}\r\n\r\n// src/utils/_addIssue/_addIssue.ts\r\nfunction _addIssue(context, label, dataset, config2, other) {\r\n  const input = other && \"input\" in other ? other.input : dataset.value;\r\n  const expected = other?.expected ?? context.expects ?? null;\r\n  const received = other?.received ?? _stringify(input);\r\n  const issue = {\r\n    kind: context.kind,\r\n    type: context.type,\r\n    input,\r\n    expected,\r\n    received,\r\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\r\n    // @ts-expect-error\r\n    requirement: context.requirement,\r\n    path: other?.path,\r\n    issues: other?.issues,\r\n    lang: config2.lang,\r\n    abortEarly: config2.abortEarly,\r\n    abortPipeEarly: config2.abortPipeEarly\r\n  };\r\n  const isSchema = context.kind === \"schema\";\r\n  const message = other?.message ?? // @ts-expect-error\r\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\r\n  if (message) {\r\n    issue.message = typeof message === \"function\" ? message(issue) : message;\r\n  }\r\n  if (isSchema) {\r\n    dataset.typed = false;\r\n  }\r\n  if (dataset.issues) {\r\n    dataset.issues.push(issue);\r\n  } else {\r\n    dataset.issues = [issue];\r\n  }\r\n}\r\n\r\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\r\nvar NON_DIGIT_REGEX = /\\D/gu;\r\nfunction _isLuhnAlgo(input) {\r\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\r\n  let length2 = number2.length;\r\n  let bit = 1;\r\n  let sum = 0;\r\n  while (length2) {\r\n    const value2 = +number2[--length2];\r\n    bit ^= 1;\r\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\r\n  }\r\n  return sum % 10 === 0;\r\n}\r\n\r\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\r\nfunction _isValidObjectKey(object2, key) {\r\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\r\n}\r\n\r\n// src/utils/entriesFromList/entriesFromList.ts\r\nfunction entriesFromList(list, schema) {\r\n  const entries = {};\r\n  for (const key of list) {\r\n    entries[key] = schema;\r\n  }\r\n  return entries;\r\n}\r\n\r\n// src/utils/getDotPath/getDotPath.ts\r\nfunction getDotPath(issue) {\r\n  if (issue.path) {\r\n    let key = \"\";\r\n    for (const item of issue.path) {\r\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\r\n        if (key) {\r\n          key += `.${item.key}`;\r\n        } else {\r\n          key += item.key;\r\n        }\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    return key;\r\n  }\r\n  return null;\r\n}\r\n\r\n// src/utils/isOfKind/isOfKind.ts\r\nfunction isOfKind(kind, object2) {\r\n  return object2.kind === kind;\r\n}\r\n\r\n// src/utils/isOfType/isOfType.ts\r\nfunction isOfType(type, object2) {\r\n  return object2.type === type;\r\n}\r\n\r\n// src/utils/isValiError/isValiError.ts\r\nfunction isValiError(error) {\r\n  return error instanceof ValiError;\r\n}\r\n\r\n// src/utils/ValiError/ValiError.ts\r\nvar ValiError = class extends Error {\r\n  /**\r\n   * The error issues.\r\n   */\r\n  issues;\r\n  /**\r\n   * Creates a Valibot error with useful information.\r\n   *\r\n   * @param issues The error issues.\r\n   */\r\n  constructor(issues) {\r\n    super(issues[0].message);\r\n    this.name = \"ValiError\";\r\n    this.issues = issues;\r\n  }\r\n};\r\n\r\n// src/actions/bic/bic.ts\r\nfunction bic(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"bic\",\r\n    reference: bic,\r\n    async: false,\r\n    expects: null,\r\n    requirement: BIC_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"BIC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/brand/brand.ts\r\nfunction brand(name) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"brand\",\r\n    reference: brand,\r\n    async: false,\r\n    name,\r\n    _run(dataset) {\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/bytes/bytes.ts\r\nfunction bytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"bytes\",\r\n    reference: bytes,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 !== this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/check/check.ts\r\nfunction check(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"check\",\r\n    reference: check,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/check/checkAsync.ts\r\nfunction checkAsync(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"check\",\r\n    reference: checkAsync,\r\n    async: true,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.typed && !await this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/checkItems/checkItems.ts\r\nfunction checkItems(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"check_items\",\r\n    reference: checkItems,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        for (let index = 0; index < dataset.value.length; index++) {\r\n          const item = dataset.value[index];\r\n          if (!this.requirement(item, index, dataset.value)) {\r\n            _addIssue(this, \"item\", dataset, config2, {\r\n              input: item,\r\n              path: [\r\n                {\r\n                  type: \"array\",\r\n                  origin: \"value\",\r\n                  input: dataset.value,\r\n                  key: index,\r\n                  value: item\r\n                }\r\n              ]\r\n            });\r\n          }\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/creditCard/creditCard.ts\r\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\r\nvar SANITIZE_REGEX = /[- ]/gu;\r\nvar PROVIDER_REGEX_LIST = [\r\n  // American Express\r\n  /^3[47]\\d{13}$/u,\r\n  // Diners Club\r\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\r\n  // Discover\r\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\r\n  // JCB\r\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\r\n  // Mastercard\r\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\r\n  // UnionPay\r\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\r\n  // Visa\r\n  /^4\\d{12}(?:\\d{3,6})?$/u\r\n];\r\nfunction creditCard(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"credit_card\",\r\n    reference: creditCard,\r\n    async: false,\r\n    expects: null,\r\n    requirement(input) {\r\n      let sanitized;\r\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\r\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\r\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\r\n      _isLuhnAlgo(sanitized);\r\n    },\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"credit card\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/cuid2/cuid2.ts\r\nfunction cuid2(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"cuid2\",\r\n    reference: cuid2,\r\n    async: false,\r\n    expects: null,\r\n    requirement: CUID2_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"Cuid2\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/decimal/decimal.ts\r\nfunction decimal(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"decimal\",\r\n    reference: decimal,\r\n    async: false,\r\n    expects: null,\r\n    requirement: DECIMAL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"decimal\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/email/email.ts\r\nfunction email(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"email\",\r\n    reference: email,\r\n    expects: null,\r\n    async: false,\r\n    requirement: EMAIL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"email\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/emoji/emoji.ts\r\nfunction emoji(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"emoji\",\r\n    reference: emoji,\r\n    async: false,\r\n    expects: null,\r\n    requirement: EMOJI_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"emoji\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/empty/empty.ts\r\nfunction empty(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"empty\",\r\n    reference: empty,\r\n    async: false,\r\n    expects: \"0\",\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length > 0) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/endsWith/endsWith.ts\r\nfunction endsWith(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ends_with\",\r\n    reference: endsWith,\r\n    async: false,\r\n    expects: `\"${requirement}\"`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\r\n        _addIssue(this, \"end\", dataset, config2, {\r\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/everyItem/everyItem.ts\r\nfunction everyItem(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"every_item\",\r\n    reference: everyItem,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\r\n        _addIssue(this, \"item\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/excludes/excludes.ts\r\nfunction excludes(requirement, message) {\r\n  const received = _stringify(requirement);\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"excludes\",\r\n    reference: excludes,\r\n    async: false,\r\n    expects: `!${received}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\r\n        _addIssue(this, \"content\", dataset, config2, { received });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/filterItems/filterItems.ts\r\nfunction filterItems(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"filter_items\",\r\n    reference: filterItems,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.filter(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/findItem/findItem.ts\r\nfunction findItem(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"find_item\",\r\n    reference: findItem,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.find(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/finite/finite.ts\r\nfunction finite(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"finite\",\r\n    reference: finite,\r\n    async: false,\r\n    expects: null,\r\n    requirement: Number.isFinite,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"finite\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/hash/hash.ts\r\nvar HASH_LENGTHS = {\r\n  md4: 32,\r\n  md5: 32,\r\n  sha1: 40,\r\n  sha256: 64,\r\n  sha384: 96,\r\n  sha512: 128,\r\n  ripemd128: 32,\r\n  ripemd160: 40,\r\n  tiger128: 32,\r\n  tiger160: 40,\r\n  tiger192: 48,\r\n  crc32: 8,\r\n  crc32b: 8,\r\n  adler32: 8\r\n};\r\nfunction hash(types, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"hash\",\r\n    reference: hash,\r\n    expects: null,\r\n    async: false,\r\n    requirement: RegExp(\r\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\r\n      \"iu\"\r\n    ),\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"hash\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/hexadecimal/hexadecimal.ts\r\nfunction hexadecimal(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"hexadecimal\",\r\n    reference: hexadecimal,\r\n    async: false,\r\n    expects: null,\r\n    requirement: HEXADECIMAL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"hexadecimal\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/hexColor/hexColor.ts\r\nfunction hexColor(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"hex_color\",\r\n    reference: hexColor,\r\n    async: false,\r\n    expects: null,\r\n    requirement: HEX_COLOR_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"hex color\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/imei/imei.ts\r\nfunction imei(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"imei\",\r\n    reference: imei,\r\n    async: false,\r\n    expects: null,\r\n    requirement(input) {\r\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\r\n    },\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"IMEI\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/includes/includes.ts\r\nfunction includes(requirement, message) {\r\n  const expects = _stringify(requirement);\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"includes\",\r\n    reference: includes,\r\n    async: false,\r\n    expects,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\r\n        _addIssue(this, \"content\", dataset, config2, {\r\n          received: `!${expects}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/integer/integer.ts\r\nfunction integer(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"integer\",\r\n    reference: integer,\r\n    async: false,\r\n    expects: null,\r\n    requirement: Number.isInteger,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"integer\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ip/ip.ts\r\nfunction ip(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ip\",\r\n    reference: ip,\r\n    async: false,\r\n    expects: null,\r\n    requirement: IP_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"IP\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ipv4/ipv4.ts\r\nfunction ipv4(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ipv4\",\r\n    reference: ipv4,\r\n    async: false,\r\n    expects: null,\r\n    requirement: IPV4_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"IPv4\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ipv6/ipv6.ts\r\nfunction ipv6(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ipv6\",\r\n    reference: ipv6,\r\n    async: false,\r\n    expects: null,\r\n    requirement: IPV6_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"IPv6\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoDate/isoDate.ts\r\nfunction isoDate(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_date\",\r\n    reference: isoDate,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_DATE_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"date\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoDateTime/isoDateTime.ts\r\nfunction isoDateTime(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_date_time\",\r\n    reference: isoDateTime,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_DATE_TIME_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"date-time\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoTime/isoTime.ts\r\nfunction isoTime(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_time\",\r\n    reference: isoTime,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_TIME_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"time\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoTimeSecond/isoTimeSecond.ts\r\nfunction isoTimeSecond(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_time_second\",\r\n    reference: isoTimeSecond,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_TIME_SECOND_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"time-second\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoTimestamp/isoTimestamp.ts\r\nfunction isoTimestamp(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_timestamp\",\r\n    reference: isoTimestamp,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_TIMESTAMP_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"timestamp\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoWeek/isoWeek.ts\r\nfunction isoWeek(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_week\",\r\n    reference: isoWeek,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_WEEK_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"week\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/length/length.ts\r\nfunction length(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"length\",\r\n    reference: length,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length !== this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mac/mac.ts\r\nfunction mac(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mac\",\r\n    reference: mac,\r\n    async: false,\r\n    expects: null,\r\n    requirement: MAC_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"MAC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mac48/mac48.ts\r\nfunction mac48(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mac48\",\r\n    reference: mac48,\r\n    async: false,\r\n    expects: null,\r\n    requirement: MAC48_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mac64/mac64.ts\r\nfunction mac64(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mac64\",\r\n    reference: mac64,\r\n    async: false,\r\n    expects: null,\r\n    requirement: MAC64_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mapItems/mapItems.ts\r\nfunction mapItems(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"map_items\",\r\n    reference: mapItems,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.map(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxBytes/maxBytes.ts\r\nfunction maxBytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_bytes\",\r\n    reference: maxBytes,\r\n    async: false,\r\n    expects: `<=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 > this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxLength/maxLength.ts\r\nfunction maxLength(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_length\",\r\n    reference: maxLength,\r\n    async: false,\r\n    expects: `<=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length > this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxSize/maxSize.ts\r\nfunction maxSize(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_size\",\r\n    reference: maxSize,\r\n    async: false,\r\n    expects: `<=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size > this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxValue/maxValue.ts\r\nfunction maxValue(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_value\",\r\n    reference: maxValue,\r\n    async: false,\r\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value > this.requirement) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mimeType/mimeType.ts\r\nfunction mimeType(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mime_type\",\r\n    reference: mimeType,\r\n    async: false,\r\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\r\n        _addIssue(this, \"MIME type\", dataset, config2, {\r\n          received: `\"${dataset.value.type}\"`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minBytes/minBytes.ts\r\nfunction minBytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_bytes\",\r\n    reference: minBytes,\r\n    async: false,\r\n    expects: `>=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 < this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minLength/minLength.ts\r\nfunction minLength(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_length\",\r\n    reference: minLength,\r\n    async: false,\r\n    expects: `>=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length < this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minSize/minSize.ts\r\nfunction minSize(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_size\",\r\n    reference: minSize,\r\n    async: false,\r\n    expects: `>=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size < this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minValue/minValue.ts\r\nfunction minValue(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_value\",\r\n    reference: minValue,\r\n    async: false,\r\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value < this.requirement) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/multipleOf/multipleOf.ts\r\nfunction multipleOf(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"multiple_of\",\r\n    reference: multipleOf,\r\n    async: false,\r\n    expects: `%${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\r\n        _addIssue(this, \"multiple\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/nonEmpty/nonEmpty.ts\r\nfunction nonEmpty(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"non_empty\",\r\n    reference: nonEmpty,\r\n    async: false,\r\n    expects: \"!0\",\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length === 0) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: \"0\"\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/normalize/normalize.ts\r\nfunction normalize(form) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"normalize\",\r\n    reference: normalize,\r\n    async: false,\r\n    form,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.normalize(this.form);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notBytes/notBytes.ts\r\nfunction notBytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_bytes\",\r\n    reference: notBytes,\r\n    async: false,\r\n    expects: `!${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 === this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notLength/notLength.ts\r\nfunction notLength(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_length\",\r\n    reference: notLength,\r\n    async: false,\r\n    expects: `!${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length === this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notSize/notSize.ts\r\nfunction notSize(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_size\",\r\n    reference: notSize,\r\n    async: false,\r\n    expects: `!${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size === this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notValue/notValue.ts\r\nfunction notValue(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_value\",\r\n    reference: notValue,\r\n    async: false,\r\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/octal/octal.ts\r\nfunction octal(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"octal\",\r\n    reference: octal,\r\n    async: false,\r\n    expects: null,\r\n    requirement: OCTAL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"octal\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\r\nfunction _isPartiallyTyped(dataset, pathList) {\r\n  if (dataset.issues) {\r\n    for (const path of pathList) {\r\n      for (const issue of dataset.issues) {\r\n        let typed = false;\r\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\r\n        for (let index = 0; index < bound; index++) {\r\n          if (path[index] !== issue.path[index].key) {\r\n            typed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!typed) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// src/actions/partialCheck/partialCheck.ts\r\nfunction partialCheck(pathList, requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"partial_check\",\r\n    reference: partialCheck,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\r\n      !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/partialCheck/partialCheckAsync.ts\r\nfunction partialCheckAsync(pathList, requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"partial_check\",\r\n    reference: partialCheckAsync,\r\n    async: true,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\r\n      !await this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawCheck/rawCheck.ts\r\nfunction rawCheck(action) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"raw_check\",\r\n    reference: rawCheck,\r\n    async: false,\r\n    expects: null,\r\n    _run(dataset, config2) {\r\n      action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\r\n      });\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawCheck/rawCheckAsync.ts\r\nfunction rawCheckAsync(action) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"raw_check\",\r\n    reference: rawCheckAsync,\r\n    async: true,\r\n    expects: null,\r\n    async _run(dataset, config2) {\r\n      await action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\r\n      });\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawTransform/rawTransform.ts\r\nfunction rawTransform(action) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"raw_transform\",\r\n    reference: rawTransform,\r\n    async: false,\r\n    _run(dataset, config2) {\r\n      const output = action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\r\n        NEVER: null\r\n      });\r\n      if (dataset.issues) {\r\n        dataset.typed = false;\r\n      } else {\r\n        dataset.value = output;\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawTransform/rawTransformAsync.ts\r\nfunction rawTransformAsync(action) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"raw_transform\",\r\n    reference: rawTransformAsync,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      const output = await action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\r\n        NEVER: null\r\n      });\r\n      if (dataset.issues) {\r\n        dataset.typed = false;\r\n      } else {\r\n        dataset.value = output;\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/readonly/readonly.ts\r\nfunction readonly() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"readonly\",\r\n    reference: readonly,\r\n    async: false,\r\n    _run(dataset) {\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/reduceItems/reduceItems.ts\r\nfunction reduceItems(operation, initial) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"reduce_items\",\r\n    reference: reduceItems,\r\n    async: false,\r\n    operation,\r\n    initial,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/regex/regex.ts\r\nfunction regex(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"regex\",\r\n    reference: regex,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"format\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/safeInteger/safeInteger.ts\r\nfunction safeInteger(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"safe_integer\",\r\n    reference: safeInteger,\r\n    async: false,\r\n    expects: null,\r\n    requirement: Number.isSafeInteger,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"safe integer\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/size/size.ts\r\nfunction size(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"size\",\r\n    reference: size,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size !== this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/someItem/someItem.ts\r\nfunction someItem(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"some_item\",\r\n    reference: someItem,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\r\n        _addIssue(this, \"item\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/sortItems/sortItems.ts\r\nfunction sortItems(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"sort_items\",\r\n    reference: sortItems,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.sort(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/startsWith/startsWith.ts\r\nfunction startsWith(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"starts_with\",\r\n    reference: startsWith,\r\n    async: false,\r\n    expects: `\"${requirement}\"`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\r\n        _addIssue(this, \"start\", dataset, config2, {\r\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toLowerCase/toLowerCase.ts\r\nfunction toLowerCase() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_lower_case\",\r\n    reference: toLowerCase,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.toLowerCase();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toMaxValue/toMaxValue.ts\r\nfunction toMaxValue(requirement) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_max_value\",\r\n    reference: toMaxValue,\r\n    async: false,\r\n    requirement,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toMinValue/toMinValue.ts\r\nfunction toMinValue(requirement) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_min_value\",\r\n    reference: toMinValue,\r\n    async: false,\r\n    requirement,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toUpperCase/toUpperCase.ts\r\nfunction toUpperCase() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_upper_case\",\r\n    reference: toUpperCase,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.toUpperCase();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/transform/transform.ts\r\nfunction transform(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"transform\",\r\n    reference: transform,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = this.operation(dataset.value);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/transform/transformAsync.ts\r\nfunction transformAsync(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"transform\",\r\n    reference: transformAsync,\r\n    async: true,\r\n    operation,\r\n    async _run(dataset) {\r\n      dataset.value = await this.operation(dataset.value);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/trim/trim.ts\r\nfunction trim() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"trim\",\r\n    reference: trim,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.trim();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/trimEnd/trimEnd.ts\r\nfunction trimEnd() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"trim_end\",\r\n    reference: trimEnd,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.trimEnd();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/trimStart/trimStart.ts\r\nfunction trimStart() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"trim_start\",\r\n    reference: trimStart,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.trimStart();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ulid/ulid.ts\r\nfunction ulid(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ulid\",\r\n    reference: ulid,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ULID_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"ULID\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/url/url.ts\r\nfunction url(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"url\",\r\n    reference: url,\r\n    async: false,\r\n    expects: null,\r\n    requirement(input) {\r\n      try {\r\n        new URL(input);\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    },\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"URL\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/uuid/uuid.ts\r\nfunction uuid(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"uuid\",\r\n    reference: uuid,\r\n    async: false,\r\n    expects: null,\r\n    requirement: UUID_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"UUID\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/value/value.ts\r\nfunction value(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"value\",\r\n    reference: value,\r\n    async: false,\r\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/config/config.ts\r\nfunction config(schema, config2) {\r\n  return {\r\n    ...schema,\r\n    _run(dataset, config_) {\r\n      return schema._run(dataset, { ...config_, ...config2 });\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/getFallback/getFallback.ts\r\nfunction getFallback(schema, dataset, config2) {\r\n  return typeof schema.fallback === \"function\" ? (\r\n    // @ts-expect-error\r\n    schema.fallback(dataset, config2)\r\n  ) : (\r\n    // @ts-expect-error\r\n    schema.fallback\r\n  );\r\n}\r\n\r\n// src/methods/fallback/fallback.ts\r\nfunction fallback(schema, fallback2) {\r\n  return {\r\n    ...schema,\r\n    fallback: fallback2,\r\n    _run(dataset, config2) {\r\n      schema._run(dataset, config2);\r\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/fallback/fallbackAsync.ts\r\nfunction fallbackAsync(schema, fallback2) {\r\n  return {\r\n    ...schema,\r\n    fallback: fallback2,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      schema._run(dataset, config2);\r\n      return dataset.issues ? (\r\n        // @ts-expect-error\r\n        { typed: true, value: await getFallback(this, dataset, config2) }\r\n      ) : dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/flatten/flatten.ts\r\nfunction flatten(issues) {\r\n  const flatErrors = {};\r\n  for (const issue of issues) {\r\n    if (issue.path) {\r\n      const dotPath = getDotPath(issue);\r\n      if (dotPath) {\r\n        if (!flatErrors.nested) {\r\n          flatErrors.nested = {};\r\n        }\r\n        if (flatErrors.nested[dotPath]) {\r\n          flatErrors.nested[dotPath].push(issue.message);\r\n        } else {\r\n          flatErrors.nested[dotPath] = [issue.message];\r\n        }\r\n      } else {\r\n        if (flatErrors.other) {\r\n          flatErrors.other.push(issue.message);\r\n        } else {\r\n          flatErrors.other = [issue.message];\r\n        }\r\n      }\r\n    } else {\r\n      if (flatErrors.root) {\r\n        flatErrors.root.push(issue.message);\r\n      } else {\r\n        flatErrors.root = [issue.message];\r\n      }\r\n    }\r\n  }\r\n  return flatErrors;\r\n}\r\n\r\n// src/methods/forward/forward.ts\r\nfunction forward(action, pathKeys) {\r\n  return {\r\n    ...action,\r\n    _run(dataset, config2) {\r\n      const prevIssues = dataset.issues && [...dataset.issues];\r\n      action._run(dataset, config2);\r\n      if (dataset.issues) {\r\n        for (const issue of dataset.issues) {\r\n          if (!prevIssues?.includes(issue)) {\r\n            let pathInput = dataset.value;\r\n            for (const key of pathKeys) {\r\n              const pathValue = pathInput[key];\r\n              const pathItem = {\r\n                type: \"unknown\",\r\n                origin: \"value\",\r\n                input: pathInput,\r\n                key,\r\n                value: pathValue\r\n              };\r\n              if (issue.path) {\r\n                issue.path.push(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              if (!pathValue) {\r\n                break;\r\n              }\r\n              pathInput = pathValue;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/forward/forwardAsync.ts\r\nfunction forwardAsync(action, pathKeys) {\r\n  return {\r\n    ...action,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      const prevIssues = dataset.issues && [...dataset.issues];\r\n      await action._run(dataset, config2);\r\n      if (dataset.issues) {\r\n        for (const issue of dataset.issues) {\r\n          if (!prevIssues?.includes(issue)) {\r\n            let pathInput = dataset.value;\r\n            for (const key of pathKeys) {\r\n              const pathValue = pathInput[key];\r\n              const pathItem = {\r\n                type: \"unknown\",\r\n                origin: \"value\",\r\n                input: pathInput,\r\n                key,\r\n                value: pathValue\r\n              };\r\n              if (issue.path) {\r\n                issue.path.push(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              if (!pathValue) {\r\n                break;\r\n              }\r\n              pathInput = pathValue;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/getDefault/getDefault.ts\r\nfunction getDefault(schema, dataset, config2) {\r\n  return typeof schema.default === \"function\" ? (\r\n    // @ts-expect-error\r\n    schema.default(dataset, config2)\r\n  ) : (\r\n    // @ts-expect-error\r\n    schema.default\r\n  );\r\n}\r\n\r\n// src/methods/getDefaults/getDefaults.ts\r\nfunction getDefaults(schema) {\r\n  if (\"entries\" in schema) {\r\n    const object2 = {};\r\n    for (const key in schema.entries) {\r\n      object2[key] = getDefaults(schema.entries[key]);\r\n    }\r\n    return object2;\r\n  }\r\n  if (\"items\" in schema) {\r\n    return schema.items.map(getDefaults);\r\n  }\r\n  return getDefault(schema);\r\n}\r\n\r\n// src/methods/getDefaults/getDefaultsAsync.ts\r\nasync function getDefaultsAsync(schema) {\r\n  if (\"entries\" in schema) {\r\n    return Object.fromEntries(\r\n      await Promise.all(\r\n        Object.entries(schema.entries).map(async ([key, value2]) => [\r\n          key,\r\n          await getDefaultsAsync(value2)\r\n        ])\r\n      )\r\n    );\r\n  }\r\n  if (\"items\" in schema) {\r\n    return Promise.all(schema.items.map(getDefaultsAsync));\r\n  }\r\n  return getDefault(schema);\r\n}\r\n\r\n// src/methods/getFallbacks/getFallbacks.ts\r\nfunction getFallbacks(schema) {\r\n  if (\"entries\" in schema) {\r\n    const object2 = {};\r\n    for (const key in schema.entries) {\r\n      object2[key] = getFallbacks(schema.entries[key]);\r\n    }\r\n    return object2;\r\n  }\r\n  if (\"items\" in schema) {\r\n    return schema.items.map(getFallbacks);\r\n  }\r\n  return getFallback(schema);\r\n}\r\n\r\n// src/methods/getFallbacks/getFallbacksAsync.ts\r\nasync function getFallbacksAsync(schema) {\r\n  if (\"entries\" in schema) {\r\n    return Object.fromEntries(\r\n      await Promise.all(\r\n        Object.entries(schema.entries).map(async ([key, value2]) => [\r\n          key,\r\n          await getFallbacksAsync(value2)\r\n        ])\r\n      )\r\n    );\r\n  }\r\n  if (\"items\" in schema) {\r\n    return Promise.all(schema.items.map(getFallbacksAsync));\r\n  }\r\n  return getFallback(schema);\r\n}\r\n\r\n// src/methods/is/is.ts\r\nfunction is(schema, input) {\r\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\r\n}\r\n\r\n// src/schemas/any/any.ts\r\nfunction any() {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"any\",\r\n    reference: any,\r\n    expects: \"any\",\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.typed = true;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/array/array.ts\r\nfunction array(item, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"array\",\r\n    reference: array,\r\n    expects: \"Array\",\r\n    async: false,\r\n    item,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < input.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/array/arrayAsync.ts\r\nfunction arrayAsync(item, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"array\",\r\n    reference: arrayAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    item,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\r\n        );\r\n        for (let key = 0; key < itemDatasets.length; key++) {\r\n          const itemDataset = itemDatasets[key];\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: input[key]\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/bigint/bigint.ts\r\nfunction bigint(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"bigint\",\r\n    reference: bigint,\r\n    expects: \"bigint\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"bigint\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/blob/blob.ts\r\nfunction blob(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"blob\",\r\n    reference: blob,\r\n    expects: \"Blob\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof Blob) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/boolean/boolean.ts\r\nfunction boolean(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"boolean\",\r\n    reference: boolean,\r\n    expects: \"boolean\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"boolean\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/custom/custom.ts\r\nfunction custom(check2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"custom\",\r\n    reference: custom,\r\n    expects: \"unknown\",\r\n    async: false,\r\n    check: check2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.check(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/custom/customAsync.ts\r\nfunction customAsync(check2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"custom\",\r\n    reference: customAsync,\r\n    expects: \"unknown\",\r\n    async: true,\r\n    check: check2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (await this.check(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/date/date.ts\r\nfunction date(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"date\",\r\n    reference: date,\r\n    expects: \"Date\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof Date) {\r\n        if (!isNaN(dataset.value)) {\r\n          dataset.typed = true;\r\n        } else {\r\n          _addIssue(this, \"type\", dataset, config2, {\r\n            received: '\"Invalid Date\"'\r\n          });\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/enum/enum.ts\r\nfunction enum_(enum__, message) {\r\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"enum\",\r\n    reference: enum_,\r\n    expects: options.map(_stringify).join(\" | \") || \"never\",\r\n    async: false,\r\n    enum: enum__,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.options.includes(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/file/file.ts\r\nfunction file(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"file\",\r\n    reference: file,\r\n    expects: \"File\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof File) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/function/function.ts\r\nfunction function_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"function\",\r\n    reference: function_,\r\n    expects: \"Function\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"function\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/instance/instance.ts\r\nfunction instance(class_, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"instance\",\r\n    reference: instance,\r\n    expects: class_.name,\r\n    async: false,\r\n    class: class_,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof this.class) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/intersect/utils/_merge/_merge.ts\r\nfunction _merge(value1, value2) {\r\n  if (typeof value1 === typeof value2) {\r\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\r\n      return { value: value1 };\r\n    }\r\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\r\n      for (const key in value2) {\r\n        if (key in value1) {\r\n          const dataset = _merge(value1[key], value2[key]);\r\n          if (dataset.issue) {\r\n            return dataset;\r\n          }\r\n          value1[key] = dataset.value;\r\n        } else {\r\n          value1[key] = value2[key];\r\n        }\r\n      }\r\n      return { value: value1 };\r\n    }\r\n    if (Array.isArray(value1) && Array.isArray(value2)) {\r\n      if (value1.length === value2.length) {\r\n        for (let index = 0; index < value1.length; index++) {\r\n          const dataset = _merge(value1[index], value2[index]);\r\n          if (dataset.issue) {\r\n            return dataset;\r\n          }\r\n          value1[index] = dataset.value;\r\n        }\r\n        return { value: value1 };\r\n      }\r\n    }\r\n  }\r\n  return { issue: true };\r\n}\r\n\r\n// src/schemas/intersect/intersect.ts\r\nfunction intersect(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"intersect\",\r\n    reference: intersect,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\r\n    async: false,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.options.length) {\r\n        const input = dataset.value;\r\n        let outputs;\r\n        dataset.typed = true;\r\n        for (const schema of this.options) {\r\n          const optionDataset = schema._run(\r\n            { typed: false, value: input },\r\n            config2\r\n          );\r\n          if (optionDataset.issues) {\r\n            if (dataset.issues) {\r\n              dataset.issues.push(...optionDataset.issues);\r\n            } else {\r\n              dataset.issues = optionDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!optionDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (dataset.typed) {\r\n            if (outputs) {\r\n              outputs.push(optionDataset.value);\r\n            } else {\r\n              outputs = [optionDataset.value];\r\n            }\r\n          }\r\n        }\r\n        if (dataset.typed) {\r\n          dataset.value = outputs[0];\r\n          for (let index = 1; index < outputs.length; index++) {\r\n            const mergeDataset = _merge(dataset.value, outputs[index]);\r\n            if (mergeDataset.issue) {\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                received: \"unknown\"\r\n              });\r\n              break;\r\n            }\r\n            dataset.value = mergeDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/intersect/intersectAsync.ts\r\nfunction intersectAsync(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"intersect\",\r\n    reference: intersectAsync,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\r\n    async: true,\r\n    options,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (this.options.length) {\r\n        const input = dataset.value;\r\n        let outputs;\r\n        dataset.typed = true;\r\n        const optionDatasets = await Promise.all(\r\n          this.options.map(\r\n            (schema) => schema._run({ typed: false, value: input }, config2)\r\n          )\r\n        );\r\n        for (const optionDataset of optionDatasets) {\r\n          if (optionDataset.issues) {\r\n            if (dataset.issues) {\r\n              dataset.issues.push(...optionDataset.issues);\r\n            } else {\r\n              dataset.issues = optionDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!optionDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (dataset.typed) {\r\n            if (outputs) {\r\n              outputs.push(optionDataset.value);\r\n            } else {\r\n              outputs = [optionDataset.value];\r\n            }\r\n          }\r\n        }\r\n        if (dataset.typed) {\r\n          dataset.value = outputs[0];\r\n          for (let index = 1; index < outputs.length; index++) {\r\n            const mergeDataset = _merge(dataset.value, outputs[index]);\r\n            if (mergeDataset.issue) {\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                received: \"unknown\"\r\n              });\r\n              break;\r\n            }\r\n            dataset.value = mergeDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/lazy/lazy.ts\r\nfunction lazy(getter) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"lazy\",\r\n    reference: lazy,\r\n    expects: \"unknown\",\r\n    async: false,\r\n    getter,\r\n    _run(dataset, config2) {\r\n      return this.getter(dataset.value)._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/lazy/lazyAsync.ts\r\nfunction lazyAsync(getter) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"lazy\",\r\n    reference: lazyAsync,\r\n    expects: \"unknown\",\r\n    async: true,\r\n    getter,\r\n    async _run(dataset, config2) {\r\n      return (await this.getter(dataset.value))._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/literal/literal.ts\r\nfunction literal(literal_, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"literal\",\r\n    reference: literal,\r\n    expects: _stringify(literal_),\r\n    async: false,\r\n    literal: literal_,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === this.literal) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseObject/looseObject.ts\r\nfunction looseObject(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_object\",\r\n    reference: looseObject,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\r\n              dataset.value[key] = input[key];\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseObject/looseObjectAsync.ts\r\nfunction looseObjectAsync(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_object\",\r\n    reference: looseObjectAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const valueDatasets = await Promise.all(\r\n          Object.entries(this.entries).map(async ([key, schema]) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await schema._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\r\n              dataset.value[key] = input[key];\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseTuple/looseTuple.ts\r\nfunction looseTuple(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_tuple\",\r\n    reference: looseTuple,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (let key = this.items.length; key < input.length; key++) {\r\n            dataset.value.push(input[key]);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseTuple/looseTupleAsync.ts\r\nfunction looseTupleAsync(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_tuple\",\r\n    reference: looseTupleAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          this.items.map(async (item, key) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await item._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, itemDataset] of itemDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (let key = this.items.length; key < input.length; key++) {\r\n            dataset.value.push(input[key]);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/map/map.ts\r\nfunction map(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"map\",\r\n    reference: map,\r\n    expects: \"Map\",\r\n    async: false,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Map) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Map();\r\n        for (const [inputKey, inputValue] of input) {\r\n          const keyDataset = this.key._run(\r\n            { typed: false, value: inputKey },\r\n            config2\r\n          );\r\n          if (keyDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"key\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of keyDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = keyDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          const valueDataset = this.value._run(\r\n            { typed: false, value: inputValue },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"value\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!keyDataset.typed || !valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.set(keyDataset.value, valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/map/mapAsync.ts\r\nfunction mapAsync(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"map\",\r\n    reference: mapAsync,\r\n    expects: \"Map\",\r\n    async: true,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Map) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Map();\r\n        const datasets = await Promise.all(\r\n          [...input].map(\r\n            ([inputKey, inputValue]) => Promise.all([\r\n              inputKey,\r\n              inputValue,\r\n              this.key._run({ typed: false, value: inputKey }, config2),\r\n              this.value._run({ typed: false, value: inputValue }, config2)\r\n            ])\r\n          )\r\n        );\r\n        for (const [\r\n          inputKey,\r\n          inputValue,\r\n          keyDataset,\r\n          valueDataset\r\n        ] of datasets) {\r\n          if (keyDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"key\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of keyDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = keyDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"value\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!keyDataset.typed || !valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.set(keyDataset.value, valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nan/nan.ts\r\nfunction nan(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"nan\",\r\n    reference: nan,\r\n    expects: \"NaN\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (Number.isNaN(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/never/never.ts\r\nfunction never(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"never\",\r\n    reference: never,\r\n    expects: \"never\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      _addIssue(this, \"type\", dataset, config2);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullable/nonNullable.ts\r\nfunction nonNullable(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullable\",\r\n    reference: nonNullable,\r\n    expects: \"!null\",\r\n    async: false,\r\n    wrapped,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullable/nonNullableAsync.ts\r\nfunction nonNullableAsync(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullable\",\r\n    reference: nonNullableAsync,\r\n    expects: \"!null\",\r\n    async: true,\r\n    wrapped,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullish/nonNullish.ts\r\nfunction nonNullish(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullish\",\r\n    reference: nonNullish,\r\n    expects: \"!null & !undefined\",\r\n    async: false,\r\n    wrapped,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullish/nonNullishAsync.ts\r\nfunction nonNullishAsync(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullish\",\r\n    reference: nonNullishAsync,\r\n    expects: \"!null & !undefined\",\r\n    async: true,\r\n    wrapped,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonOptional/nonOptional.ts\r\nfunction nonOptional(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_optional\",\r\n    reference: nonOptional,\r\n    expects: \"!undefined\",\r\n    async: false,\r\n    wrapped,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonOptional/nonOptionalAsync.ts\r\nfunction nonOptionalAsync(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_optional\",\r\n    reference: nonOptionalAsync,\r\n    expects: \"!undefined\",\r\n    async: true,\r\n    wrapped,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/null/null.ts\r\nfunction null_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"null\",\r\n    reference: null_,\r\n    expects: \"null\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nullable/nullable.ts\r\nfunction nullable(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullable\",\r\n    reference: nullable,\r\n    expects: `${wrapped.expects} | null`,\r\n    async: false,\r\n    wrapped,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        if (\"default\" in this) {\r\n          dataset.value = getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/nullable/nullableAsync.ts\r\nfunction nullableAsync(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullable\",\r\n    reference: nullableAsync,\r\n    expects: `${wrapped.expects} | null`,\r\n    async: true,\r\n    wrapped,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        if (\"default\" in this) {\r\n          dataset.value = await getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/nullish/nullish.ts\r\nfunction nullish(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullish\",\r\n    reference: nullish,\r\n    expects: `${wrapped.expects} | null | undefined`,\r\n    async: false,\r\n    wrapped,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null || dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/nullish/nullishAsync.ts\r\nfunction nullishAsync(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullish\",\r\n    reference: nullishAsync,\r\n    expects: `${wrapped.expects} | null | undefined`,\r\n    async: true,\r\n    wrapped,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = await getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null || dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/number/number.ts\r\nfunction number(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"number\",\r\n    reference: number,\r\n    expects: \"number\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/object/object.ts\r\nfunction object(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object\",\r\n    reference: object,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/object/objectAsync.ts\r\nfunction objectAsync(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object\",\r\n    reference: objectAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const valueDatasets = await Promise.all(\r\n          Object.entries(this.entries).map(async ([key, schema]) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await schema._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/objectWithRest/objectWithRest.ts\r\nfunction objectWithRest(entries, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object_with_rest\",\r\n    reference: objectWithRest,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    rest,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\r\n              const value2 = input[key];\r\n              const valueDataset = this.rest._run(\r\n                { typed: false, value: value2 },\r\n                config2\r\n              );\r\n              if (valueDataset.issues) {\r\n                const pathItem = {\r\n                  type: \"object\",\r\n                  origin: \"value\",\r\n                  input,\r\n                  key,\r\n                  value: value2\r\n                };\r\n                for (const issue of valueDataset.issues) {\r\n                  if (issue.path) {\r\n                    issue.path.unshift(pathItem);\r\n                  } else {\r\n                    issue.path = [pathItem];\r\n                  }\r\n                  dataset.issues?.push(issue);\r\n                }\r\n                if (!dataset.issues) {\r\n                  dataset.issues = valueDataset.issues;\r\n                }\r\n                if (config2.abortEarly) {\r\n                  dataset.typed = false;\r\n                  break;\r\n                }\r\n              }\r\n              if (!valueDataset.typed) {\r\n                dataset.typed = false;\r\n              }\r\n              dataset.value[key] = valueDataset.value;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/objectWithRest/objectWithRestAsync.ts\r\nfunction objectWithRestAsync(entries, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object_with_rest\",\r\n    reference: objectWithRestAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    rest,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const [normalDatasets, restDatasets] = await Promise.all([\r\n          // Parse schema of each normal entry\r\n          Promise.all(\r\n            Object.entries(this.entries).map(async ([key, schema]) => {\r\n              const value2 = input[key];\r\n              return [\r\n                key,\r\n                value2,\r\n                await schema._run({ typed: false, value: value2 }, config2)\r\n              ];\r\n            })\r\n          ),\r\n          // Parse other entries with rest schema\r\n          Promise.all(\r\n            Object.entries(input).filter(\r\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\r\n            ).map(\r\n              async ([key, value2]) => [\r\n                key,\r\n                value2,\r\n                await this.rest._run({ typed: false, value: value2 }, config2)\r\n              ]\r\n            )\r\n          )\r\n        ]);\r\n        for (const [key, value2, valueDataset] of normalDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const [key, value2, valueDataset] of restDatasets) {\r\n            if (valueDataset.issues) {\r\n              const pathItem = {\r\n                type: \"object\",\r\n                origin: \"value\",\r\n                input,\r\n                key,\r\n                value: value2\r\n              };\r\n              for (const issue of valueDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = valueDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!valueDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/optional/optional.ts\r\nfunction optional(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"optional\",\r\n    reference: optional,\r\n    expects: `${wrapped.expects} | undefined`,\r\n    async: false,\r\n    wrapped,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/optional/optionalAsync.ts\r\nfunction optionalAsync(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"optional\",\r\n    reference: optionalAsync,\r\n    expects: `${wrapped.expects} | undefined`,\r\n    async: true,\r\n    wrapped,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = await getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/picklist/picklist.ts\r\nfunction picklist(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"picklist\",\r\n    reference: picklist,\r\n    expects: options.map(_stringify).join(\" | \") || \"never\",\r\n    async: false,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.options.includes(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/promise/promise.ts\r\nfunction promise(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"promise\",\r\n    reference: promise,\r\n    expects: \"Promise\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof Promise) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/record/record.ts\r\nfunction record(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"record\",\r\n    reference: record,\r\n    expects: \"Object\",\r\n    async: false,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const entryKey in input) {\r\n          if (_isValidObjectKey(input, entryKey)) {\r\n            const entryValue = input[entryKey];\r\n            const keyDataset = this.key._run(\r\n              { typed: false, value: entryKey },\r\n              config2\r\n            );\r\n            if (keyDataset.issues) {\r\n              const pathItem = {\r\n                type: \"object\",\r\n                origin: \"key\",\r\n                input,\r\n                key: entryKey,\r\n                value: entryValue\r\n              };\r\n              for (const issue of keyDataset.issues) {\r\n                issue.path = [pathItem];\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = keyDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            const valueDataset = this.value._run(\r\n              { typed: false, value: entryValue },\r\n              config2\r\n            );\r\n            if (valueDataset.issues) {\r\n              const pathItem = {\r\n                type: \"object\",\r\n                origin: \"value\",\r\n                input,\r\n                key: entryKey,\r\n                value: entryValue\r\n              };\r\n              for (const issue of valueDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = valueDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!keyDataset.typed || !valueDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            if (keyDataset.typed) {\r\n              dataset.value[keyDataset.value] = valueDataset.value;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/record/recordAsync.ts\r\nfunction recordAsync(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"record\",\r\n    reference: recordAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const datasets = await Promise.all(\r\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\r\n            ([entryKey, entryValue]) => Promise.all([\r\n              entryKey,\r\n              entryValue,\r\n              this.key._run({ typed: false, value: entryKey }, config2),\r\n              this.value._run({ typed: false, value: entryValue }, config2)\r\n            ])\r\n          )\r\n        );\r\n        for (const [\r\n          entryKey,\r\n          entryValue,\r\n          keyDataset,\r\n          valueDataset\r\n        ] of datasets) {\r\n          if (keyDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"key\",\r\n              input,\r\n              key: entryKey,\r\n              value: entryValue\r\n            };\r\n            for (const issue of keyDataset.issues) {\r\n              issue.path = [pathItem];\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = keyDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key: entryKey,\r\n              value: entryValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!keyDataset.typed || !valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (keyDataset.typed) {\r\n            dataset.value[keyDataset.value] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/set/set.ts\r\nfunction set(value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"set\",\r\n    reference: set,\r\n    expects: \"Set\",\r\n    async: false,\r\n    value: value2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Set) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Set();\r\n        for (const inputValue of input) {\r\n          const valueDataset = this.value._run(\r\n            { typed: false, value: inputValue },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"set\",\r\n              origin: \"value\",\r\n              input,\r\n              key: null,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.add(valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/set/setAsync.ts\r\nfunction setAsync(value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"set\",\r\n    reference: setAsync,\r\n    expects: \"Set\",\r\n    async: true,\r\n    value: value2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Set) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Set();\r\n        const valueDatasets = await Promise.all(\r\n          [...input].map(\r\n            async (inputValue) => [\r\n              inputValue,\r\n              await this.value._run(\r\n                { typed: false, value: inputValue },\r\n                config2\r\n              )\r\n            ]\r\n          )\r\n        );\r\n        for (const [inputValue, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"set\",\r\n              origin: \"value\",\r\n              input,\r\n              key: null,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.add(valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictObject/strictObject.ts\r\nfunction strictObject(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_object\",\r\n    reference: strictObject,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (!(key in this.entries)) {\r\n              const value2 = input[key];\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                input: value2,\r\n                expected: \"never\",\r\n                path: [\r\n                  {\r\n                    type: \"object\",\r\n                    origin: \"value\",\r\n                    input,\r\n                    key,\r\n                    value: value2\r\n                  }\r\n                ]\r\n              });\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictObject/strictObjectAsync.ts\r\nfunction strictObjectAsync(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_object\",\r\n    reference: strictObjectAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const valueDatasets = await Promise.all(\r\n          Object.entries(this.entries).map(async ([key, schema]) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await schema._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (!(key in this.entries)) {\r\n              const value2 = input[key];\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                input: value2,\r\n                expected: \"never\",\r\n                path: [\r\n                  {\r\n                    type: \"object\",\r\n                    origin: \"value\",\r\n                    input,\r\n                    key,\r\n                    value: value2\r\n                  }\r\n                ]\r\n              });\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictTuple/strictTuple.ts\r\nfunction strictTuple(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_tuple\",\r\n    reference: strictTuple,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\r\n          const value2 = input[items.length];\r\n          _addIssue(this, \"type\", dataset, config2, {\r\n            input: value2,\r\n            expected: \"never\",\r\n            path: [\r\n              {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key: this.items.length,\r\n                value: value2\r\n              }\r\n            ]\r\n          });\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictTuple/strictTupleAsync.ts\r\nfunction strictTupleAsync(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_tuple\",\r\n    reference: strictTupleAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          this.items.map(async (item, key) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await item._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, itemDataset] of itemDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\r\n          const value2 = input[items.length];\r\n          _addIssue(this, \"type\", dataset, config2, {\r\n            input: value2,\r\n            expected: \"never\",\r\n            path: [\r\n              {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key: this.items.length,\r\n                value: value2\r\n              }\r\n            ]\r\n          });\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/string/string.ts\r\nfunction string(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"string\",\r\n    reference: string,\r\n    expects: \"string\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"string\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/symbol/symbol.ts\r\nfunction symbol(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"symbol\",\r\n    reference: symbol,\r\n    expects: \"symbol\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"symbol\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tuple/tuple.ts\r\nfunction tuple(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple\",\r\n    reference: tuple,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tuple/tupleAsync.ts\r\nfunction tupleAsync(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple\",\r\n    reference: tupleAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          this.items.map(async (item, key) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await item._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, itemDataset] of itemDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tupleWithRest/tupleWithRest.ts\r\nfunction tupleWithRest(items, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple_with_rest\",\r\n    reference: tupleWithRest,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    rest,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (let key = this.items.length; key < input.length; key++) {\r\n            const value2 = input[key];\r\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\r\n            if (itemDataset.issues) {\r\n              const pathItem = {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key,\r\n                value: value2\r\n              };\r\n              for (const issue of itemDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = itemDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!itemDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            dataset.value.push(itemDataset.value);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\r\nfunction tupleWithRestAsync(items, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple_with_rest\",\r\n    reference: tupleWithRestAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    rest,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const [normalDatasets, restDatasets] = await Promise.all([\r\n          // Parse schema of each normal item\r\n          Promise.all(\r\n            this.items.map(async (item, key) => {\r\n              const value2 = input[key];\r\n              return [\r\n                key,\r\n                value2,\r\n                await item._run({ typed: false, value: value2 }, config2)\r\n              ];\r\n            })\r\n          ),\r\n          // Parse other items with rest schema\r\n          Promise.all(\r\n            input.slice(this.items.length).map(async (value2, key) => {\r\n              return [\r\n                key + this.items.length,\r\n                value2,\r\n                await this.rest._run({ typed: false, value: value2 }, config2)\r\n              ];\r\n            })\r\n          )\r\n        ]);\r\n        for (const [key, value2, itemDataset] of normalDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const [key, value2, itemDataset] of restDatasets) {\r\n            if (itemDataset.issues) {\r\n              const pathItem = {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key,\r\n                value: value2\r\n              };\r\n              for (const issue of itemDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = itemDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!itemDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            dataset.value.push(itemDataset.value);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/undefined/undefined.ts\r\nfunction undefined_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"undefined\",\r\n    reference: undefined_,\r\n    expects: \"undefined\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/union/utils/_subIssues/_subIssues.ts\r\nfunction _subIssues(datasets) {\r\n  let issues;\r\n  if (datasets) {\r\n    for (const dataset of datasets) {\r\n      if (issues) {\r\n        issues.push(...dataset.issues);\r\n      } else {\r\n        issues = dataset.issues;\r\n      }\r\n    }\r\n  }\r\n  return issues;\r\n}\r\n\r\n// src/schemas/union/union.ts\r\nfunction union(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"union\",\r\n    reference: union,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\r\n    async: false,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      let validDataset;\r\n      let typedDatasets;\r\n      let untypedDatasets;\r\n      for (const schema of this.options) {\r\n        const optionDataset = schema._run(\r\n          { typed: false, value: dataset.value },\r\n          config2\r\n        );\r\n        if (optionDataset.typed) {\r\n          if (optionDataset.issues) {\r\n            if (typedDatasets) {\r\n              typedDatasets.push(optionDataset);\r\n            } else {\r\n              typedDatasets = [optionDataset];\r\n            }\r\n          } else {\r\n            validDataset = optionDataset;\r\n            break;\r\n          }\r\n        } else {\r\n          if (untypedDatasets) {\r\n            untypedDatasets.push(optionDataset);\r\n          } else {\r\n            untypedDatasets = [optionDataset];\r\n          }\r\n        }\r\n      }\r\n      if (validDataset) {\r\n        return validDataset;\r\n      }\r\n      if (typedDatasets) {\r\n        if (typedDatasets.length === 1) {\r\n          return typedDatasets[0];\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(typedDatasets)\r\n        });\r\n        dataset.typed = true;\r\n      } else if (untypedDatasets?.length === 1) {\r\n        return untypedDatasets[0];\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(untypedDatasets)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/union/unionAsync.ts\r\nfunction unionAsync(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"union\",\r\n    reference: unionAsync,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\r\n    async: true,\r\n    options,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      let validDataset;\r\n      let typedDatasets;\r\n      let untypedDatasets;\r\n      for (const schema of this.options) {\r\n        const optionDataset = await schema._run(\r\n          { typed: false, value: dataset.value },\r\n          config2\r\n        );\r\n        if (optionDataset.typed) {\r\n          if (optionDataset.issues) {\r\n            if (typedDatasets) {\r\n              typedDatasets.push(optionDataset);\r\n            } else {\r\n              typedDatasets = [optionDataset];\r\n            }\r\n          } else {\r\n            validDataset = optionDataset;\r\n            break;\r\n          }\r\n        } else {\r\n          if (untypedDatasets) {\r\n            untypedDatasets.push(optionDataset);\r\n          } else {\r\n            untypedDatasets = [optionDataset];\r\n          }\r\n        }\r\n      }\r\n      if (validDataset) {\r\n        return validDataset;\r\n      }\r\n      if (typedDatasets) {\r\n        if (typedDatasets.length === 1) {\r\n          return typedDatasets[0];\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(typedDatasets)\r\n        });\r\n        dataset.typed = true;\r\n      } else if (untypedDatasets?.length === 1) {\r\n        return untypedDatasets[0];\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(untypedDatasets)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/unknown/unknown.ts\r\nfunction unknown() {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"unknown\",\r\n    reference: unknown,\r\n    expects: \"unknown\",\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.typed = true;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\r\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\r\n  for (const schema of options) {\r\n    if (schema.type === \"variant\") {\r\n      _discriminators(key, schema.options, set2);\r\n    } else {\r\n      set2.add(schema.entries[key].expects);\r\n    }\r\n  }\r\n  return set2;\r\n}\r\n\r\n// src/schemas/variant/variant.ts\r\nfunction variant(key, options, message) {\r\n  let expectedDiscriminators;\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"variant\",\r\n    reference: variant,\r\n    expects: \"Object\",\r\n    async: false,\r\n    key,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        const discriminator = input[this.key];\r\n        if (this.key in input) {\r\n          let outputDataset;\r\n          for (const schema of this.options) {\r\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\r\n              { typed: false, value: discriminator },\r\n              config2\r\n            ).issues) {\r\n              const optionDataset = schema._run(\r\n                { typed: false, value: input },\r\n                config2\r\n              );\r\n              if (!optionDataset.issues) {\r\n                return optionDataset;\r\n              }\r\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\r\n                outputDataset = optionDataset;\r\n              }\r\n            }\r\n          }\r\n          if (outputDataset) {\r\n            return outputDataset;\r\n          }\r\n        }\r\n        if (!expectedDiscriminators) {\r\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          input: discriminator,\r\n          expected: expectedDiscriminators,\r\n          path: [\r\n            {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key: this.key,\r\n              value: discriminator\r\n            }\r\n          ]\r\n        });\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/variant/variantAsync.ts\r\nfunction variantAsync(key, options, message) {\r\n  let expectedDiscriminators;\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"variant\",\r\n    reference: variantAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    key,\r\n    options,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        const discriminator = input[this.key];\r\n        if (this.key in input) {\r\n          let outputDataset;\r\n          for (const schema of this.options) {\r\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\r\n              { typed: false, value: discriminator },\r\n              config2\r\n            )).issues) {\r\n              const optionDataset = await schema._run(\r\n                { typed: false, value: input },\r\n                config2\r\n              );\r\n              if (!optionDataset.issues) {\r\n                return optionDataset;\r\n              }\r\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\r\n                outputDataset = optionDataset;\r\n              }\r\n            }\r\n          }\r\n          if (outputDataset) {\r\n            return outputDataset;\r\n          }\r\n        }\r\n        if (!expectedDiscriminators) {\r\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          input: discriminator,\r\n          expected: expectedDiscriminators,\r\n          path: [\r\n            {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key: this.key,\r\n              value: discriminator\r\n            }\r\n          ]\r\n        });\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/void/void.ts\r\nfunction void_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"void\",\r\n    reference: void_,\r\n    expects: \"void\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/keyof/keyof.ts\r\nfunction keyof(schema, message) {\r\n  return picklist(Object.keys(schema.entries), message);\r\n}\r\n\r\n// src/methods/omit/omit.ts\r\nfunction omit(schema, keys) {\r\n  const entries = {\r\n    ...schema.entries\r\n  };\r\n  for (const key of keys) {\r\n    delete entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/parse/parse.ts\r\nfunction parse(schema, input, config2) {\r\n  const dataset = schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  if (dataset.issues) {\r\n    throw new ValiError(dataset.issues);\r\n  }\r\n  return dataset.value;\r\n}\r\n\r\n// src/methods/parse/parseAsync.ts\r\nasync function parseAsync(schema, input, config2) {\r\n  const dataset = await schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  if (dataset.issues) {\r\n    throw new ValiError(dataset.issues);\r\n  }\r\n  return dataset.value;\r\n}\r\n\r\n// src/methods/parser/parser.ts\r\nfunction parser(schema, config2) {\r\n  const func = (input) => parse(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/parser/parserAsync.ts\r\nfunction parserAsync(schema, config2) {\r\n  const func = (input) => parseAsync(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/partial/partial.ts\r\nfunction partial(schema, keys) {\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/partial/partialAsync.ts\r\nfunction partialAsync(schema, keys) {\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/pick/pick.ts\r\nfunction pick(schema, keys) {\r\n  const entries = {};\r\n  for (const key of keys) {\r\n    entries[key] = schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/pipe/pipe.ts\r\nfunction pipe(...pipe2) {\r\n  return {\r\n    ...pipe2[0],\r\n    pipe: pipe2,\r\n    _run(dataset, config2) {\r\n      for (let index = 0; index < pipe2.length; index++) {\r\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\r\n          dataset.typed = false;\r\n          break;\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\r\n          dataset = pipe2[index]._run(dataset, config2);\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/pipe/pipeAsync.ts\r\nfunction pipeAsync(...pipe2) {\r\n  return {\r\n    ...pipe2[0],\r\n    pipe: pipe2,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      for (let index = 0; index < pipe2.length; index++) {\r\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\r\n          dataset.typed = false;\r\n          break;\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\r\n          dataset = await pipe2[index]._run(dataset, config2);\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/required/required.ts\r\nfunction required(schema, arg2, arg3) {\r\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\r\n  const message = Array.isArray(arg2) ? arg3 : arg2;\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/required/requiredAsync.ts\r\nfunction requiredAsync(schema, arg2, arg3) {\r\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\r\n  const message = Array.isArray(arg2) ? arg3 : arg2;\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/safeParse/safeParse.ts\r\nfunction safeParse(schema, input, config2) {\r\n  const dataset = schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  return {\r\n    typed: dataset.typed,\r\n    success: !dataset.issues,\r\n    output: dataset.value,\r\n    issues: dataset.issues\r\n  };\r\n}\r\n\r\n// src/methods/safeParse/safeParseAsync.ts\r\nasync function safeParseAsync(schema, input, config2) {\r\n  const dataset = await schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  return {\r\n    typed: dataset.typed,\r\n    success: !dataset.issues,\r\n    output: dataset.value,\r\n    issues: dataset.issues\r\n  };\r\n}\r\n\r\n// src/methods/safeParser/safeParser.ts\r\nfunction safeParser(schema, config2) {\r\n  const func = (input) => safeParse(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/safeParser/safeParserAsync.ts\r\nfunction safeParserAsync(schema, config2) {\r\n  const func = (input) => safeParseAsync(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/unwrap/unwrap.ts\r\nfunction unwrap(schema) {\r\n  return schema.wrapped;\r\n}\r\nexport {\r\n  BIC_REGEX,\r\n  CUID2_REGEX,\r\n  DECIMAL_REGEX,\r\n  EMAIL_REGEX,\r\n  EMOJI_REGEX,\r\n  HEXADECIMAL_REGEX,\r\n  HEX_COLOR_REGEX,\r\n  IMEI_REGEX,\r\n  IPV4_REGEX,\r\n  IPV6_REGEX,\r\n  IP_REGEX,\r\n  ISO_DATE_REGEX,\r\n  ISO_DATE_TIME_REGEX,\r\n  ISO_TIMESTAMP_REGEX,\r\n  ISO_TIME_REGEX,\r\n  ISO_TIME_SECOND_REGEX,\r\n  ISO_WEEK_REGEX,\r\n  MAC48_REGEX,\r\n  MAC64_REGEX,\r\n  MAC_REGEX,\r\n  OCTAL_REGEX,\r\n  ULID_REGEX,\r\n  UUID_REGEX,\r\n  ValiError,\r\n  _addIssue,\r\n  _isLuhnAlgo,\r\n  _isValidObjectKey,\r\n  _stringify,\r\n  any,\r\n  array,\r\n  arrayAsync,\r\n  awaitAsync,\r\n  bic,\r\n  bigint,\r\n  blob,\r\n  boolean,\r\n  brand,\r\n  bytes,\r\n  check,\r\n  checkAsync,\r\n  checkItems,\r\n  config,\r\n  creditCard,\r\n  cuid2,\r\n  custom,\r\n  customAsync,\r\n  date,\r\n  decimal,\r\n  deleteGlobalConfig,\r\n  deleteGlobalMessage,\r\n  deleteSchemaMessage,\r\n  deleteSpecificMessage,\r\n  email,\r\n  emoji,\r\n  empty,\r\n  endsWith,\r\n  entriesFromList,\r\n  enum_ as enum,\r\n  enum_,\r\n  everyItem,\r\n  excludes,\r\n  fallback,\r\n  fallbackAsync,\r\n  file,\r\n  filterItems,\r\n  findItem,\r\n  finite,\r\n  flatten,\r\n  forward,\r\n  forwardAsync,\r\n  function_ as function,\r\n  function_,\r\n  getDefault,\r\n  getDefaults,\r\n  getDefaultsAsync,\r\n  getDotPath,\r\n  getFallback,\r\n  getFallbacks,\r\n  getFallbacksAsync,\r\n  getGlobalConfig,\r\n  getGlobalMessage,\r\n  getSchemaMessage,\r\n  getSpecificMessage,\r\n  hash,\r\n  hexColor,\r\n  hexadecimal,\r\n  imei,\r\n  includes,\r\n  instance,\r\n  integer,\r\n  intersect,\r\n  intersectAsync,\r\n  ip,\r\n  ipv4,\r\n  ipv6,\r\n  is,\r\n  isOfKind,\r\n  isOfType,\r\n  isValiError,\r\n  isoDate,\r\n  isoDateTime,\r\n  isoTime,\r\n  isoTimeSecond,\r\n  isoTimestamp,\r\n  isoWeek,\r\n  keyof,\r\n  lazy,\r\n  lazyAsync,\r\n  length,\r\n  literal,\r\n  looseObject,\r\n  looseObjectAsync,\r\n  looseTuple,\r\n  looseTupleAsync,\r\n  mac,\r\n  mac48,\r\n  mac64,\r\n  map,\r\n  mapAsync,\r\n  mapItems,\r\n  maxBytes,\r\n  maxLength,\r\n  maxSize,\r\n  maxValue,\r\n  mimeType,\r\n  minBytes,\r\n  minLength,\r\n  minSize,\r\n  minValue,\r\n  multipleOf,\r\n  nan,\r\n  never,\r\n  nonEmpty,\r\n  nonNullable,\r\n  nonNullableAsync,\r\n  nonNullish,\r\n  nonNullishAsync,\r\n  nonOptional,\r\n  nonOptionalAsync,\r\n  normalize,\r\n  notBytes,\r\n  notLength,\r\n  notSize,\r\n  notValue,\r\n  null_ as null,\r\n  null_,\r\n  nullable,\r\n  nullableAsync,\r\n  nullish,\r\n  nullishAsync,\r\n  number,\r\n  object,\r\n  objectAsync,\r\n  objectWithRest,\r\n  objectWithRestAsync,\r\n  octal,\r\n  omit,\r\n  optional,\r\n  optionalAsync,\r\n  parse,\r\n  parseAsync,\r\n  parser,\r\n  parserAsync,\r\n  partial,\r\n  partialAsync,\r\n  partialCheck,\r\n  partialCheckAsync,\r\n  pick,\r\n  picklist,\r\n  pipe,\r\n  pipeAsync,\r\n  promise,\r\n  rawCheck,\r\n  rawCheckAsync,\r\n  rawTransform,\r\n  rawTransformAsync,\r\n  readonly,\r\n  record,\r\n  recordAsync,\r\n  reduceItems,\r\n  regex,\r\n  required,\r\n  requiredAsync,\r\n  safeInteger,\r\n  safeParse,\r\n  safeParseAsync,\r\n  safeParser,\r\n  safeParserAsync,\r\n  set,\r\n  setAsync,\r\n  setGlobalConfig,\r\n  setGlobalMessage,\r\n  setSchemaMessage,\r\n  setSpecificMessage,\r\n  size,\r\n  someItem,\r\n  sortItems,\r\n  startsWith,\r\n  strictObject,\r\n  strictObjectAsync,\r\n  strictTuple,\r\n  strictTupleAsync,\r\n  string,\r\n  symbol,\r\n  toLowerCase,\r\n  toMaxValue,\r\n  toMinValue,\r\n  toUpperCase,\r\n  transform,\r\n  transformAsync,\r\n  trim,\r\n  trimEnd,\r\n  trimStart,\r\n  tuple,\r\n  tupleAsync,\r\n  tupleWithRest,\r\n  tupleWithRestAsync,\r\n  ulid,\r\n  undefined_ as undefined,\r\n  undefined_,\r\n  union,\r\n  unionAsync,\r\n  unknown,\r\n  unwrap,\r\n  url,\r\n  uuid,\r\n  value,\r\n  variant,\r\n  variantAsync,\r\n  void_ as void,\r\n  void_\r\n};\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tcheck,\n\tinteger,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttransform,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { isValidSuiAddress, normalizeSuiAddress } from '../../utils/sui-types.js';\nimport type { Simplify } from '@mysten/utils';\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n\tEnumInputShape<\n\t\tSimplify<{\n\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t}>\n\t>,\n\tEnumOutputShape<\n\t\tSimplify<{\n\t\t\t[K in keyof T]: InferOutput<T[K]>;\n\t\t}>\n\t>\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n\tconst unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n\treturn pipe(\n\t\tunion(unionOptions),\n\t\ttransform((value) => ({\n\t\t\t...value,\n\t\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t\t})),\n\t) as EnumSchema<T>;\n}\n\nexport const SuiAddress = pipe(\n\tstring(),\n\ttransform((value) => normalizeSuiAddress(value)),\n\tcheck(isValidSuiAddress),\n);\nexport const ObjectID = SuiAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n\tunion([string(), pipe(number(), integer())]),\n\n\tcheck((val) => {\n\t\ttry {\n\t\t\tBigInt(val);\n\t\t\treturn BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}, 'Invalid u64'),\n);\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRefSchema = object({\n\tobjectId: SuiAddress,\n\tversion: JsonU64,\n\tdigest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRefSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nexport const ArgumentSchema = pipe(\n\tunion([\n\t\tobject({ GasCoin: literal(true) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n\t\tobject({ Result: pipe(number(), integer()) }),\n\t\tobject({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n\t]),\n\ttransform((value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t})),\n\t// Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n\t// Input\n\t| { GasCoin: true }\n\t| { Input: number; type?: 'pure' | 'object' }\n\t| { Result: number }\n\t| { NestedResult: [number, number] },\n\t// Output\n\t| { $kind: 'GasCoin'; GasCoin: true }\n\t| { $kind: 'Input'; Input: number; type?: 'pure' }\n\t| { $kind: 'Input'; Input: number; type?: 'object' }\n\t| { $kind: 'Result'; Result: number }\n\t| { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof ArgumentSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nexport const GasDataSchema = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRefSchema)),\n});\nexport type GasData = InferOutput<typeof GasDataSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTagSchema = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\t// type_params in rust, should be updated to use camelCase\n\ttypeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTagSchema>;\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n\t| 'address'\n\t| 'bool'\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| { vector: OpenMoveTypeSignatureBody }\n\t| {\n\t\t\tdatatype: {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\ttype: string;\n\t\t\t\ttypeParameters: OpenMoveTypeSignatureBody[];\n\t\t\t};\n\t  }\n\t| { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBodySchema: GenericSchema<OpenMoveTypeSignatureBody> = union([\n\tliteral('address'),\n\tliteral('bool'),\n\tliteral('u8'),\n\tliteral('u16'),\n\tliteral('u32'),\n\tliteral('u64'),\n\tliteral('u128'),\n\tliteral('u256'),\n\tobject({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),\n\tobject({\n\t\tdatatype: object({\n\t\t\tpackage: string(),\n\t\t\tmodule: string(),\n\t\t\ttype: string(),\n\t\t\ttypeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema)),\n\t\t}),\n\t}),\n\tobject({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignatureSchema = object({\n\tref: nullable(union([literal('&'), literal('&mut')])),\n\tbody: OpenMoveTypeSignatureBodySchema,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignatureSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCallSchema = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(ArgumentSchema),\n\t_argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCallSchema>;\n\nexport const $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nexport const CommandSchema = safeEnum({\n\tMoveCall: ProgrammableMoveCallSchema,\n\tTransferObjects: object({\n\t\tobjects: array(ArgumentSchema),\n\t\taddress: ArgumentSchema,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: ArgumentSchema,\n\t\tamounts: array(ArgumentSchema),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: ArgumentSchema,\n\t\tsources: array(ArgumentSchema),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(ArgumentSchema),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: ArgumentSchema,\n\t}),\n\t$Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n\tMoveCall: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t\ttypeArguments: string[];\n\t\targuments: Arg[];\n\t\t_argumentTypes?: OpenMoveTypeSignature[] | null;\n\t};\n\tTransferObjects: {\n\t\tobjects: Arg[];\n\t\taddress: Arg;\n\t};\n\tSplitCoins: {\n\t\tcoin: Arg;\n\t\tamounts: Arg[];\n\t};\n\tMergeCoins: {\n\t\tdestination: Arg;\n\t\tsources: Arg[];\n\t};\n\tPublish: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t};\n\tMakeMoveVec: {\n\t\ttype: string | null;\n\t\telements: Arg[];\n\t};\n\tUpgrade: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: Arg;\n\t};\n\t$Intent: {\n\t\tname: string;\n\t\tinputs: Record<string, Argument | Argument[]>;\n\t\tdata: Record<string, unknown>;\n\t};\n}>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nexport const ObjectArgSchema = safeEnum({\n\tImmOrOwnedObject: ObjectRefSchema,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRefSchema,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArgSchema = safeEnum({\n\tObject: ObjectArgSchema,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t\tmutable: optional(nullable(boolean())),\n\t}),\n});\nexport type CallArg = InferOutput<typeof CallArgSchema>;\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArgSchema,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n});\n\nexport const TransactionExpiration = safeEnum({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionDataSchema = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasDataSchema,\n\tinputs: array(CallArgSchema),\n\tcommands: array(CommandSchema),\n});\n\nexport type TransactionData = InferOutput<typeof TransactionDataSchema>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport type { Argument, CallArg, Command } from './data/internal.js';\nimport { ArgumentSchema } from './data/internal.js';\nimport type { AsyncTransactionThunk, Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n\t| InferInput<typeof ArgumentSchema>\n\t| ((tx: Transaction) => InferInput<typeof ArgumentSchema>)\n\t| AsyncTransactionThunk;\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n\t[K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n\tMoveCall(\n\t\tinput:\n\t\t\t| {\n\t\t\t\t\tpackage: string;\n\t\t\t\t\tmodule: string;\n\t\t\t\t\tfunction: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\ttarget: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  },\n\t): TransactionShape<'MoveCall'> {\n\t\tconst [pkg, mod = '', fn = ''] =\n\t\t\t'target' in input ? input.target.split('::') : [input.package, input.module, input.function];\n\n\t\treturn {\n\t\t\t$kind: 'MoveCall',\n\t\t\tMoveCall: {\n\t\t\t\tpackage: pkg,\n\t\t\t\tmodule: mod,\n\t\t\t\tfunction: fn,\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t},\n\t\t};\n\t},\n\n\tTransferObjects(\n\t\tobjects: InferInput<typeof ArgumentSchema>[],\n\t\taddress: InferInput<typeof ArgumentSchema>,\n\t): TransactionShape<'TransferObjects'> {\n\t\treturn {\n\t\t\t$kind: 'TransferObjects',\n\t\t\tTransferObjects: {\n\t\t\t\tobjects: objects.map((o) => parse(ArgumentSchema, o)),\n\t\t\t\taddress: parse(ArgumentSchema, address),\n\t\t\t},\n\t\t};\n\t},\n\tSplitCoins(\n\t\tcoin: InferInput<typeof ArgumentSchema>,\n\t\tamounts: InferInput<typeof ArgumentSchema>[],\n\t): TransactionShape<'SplitCoins'> {\n\t\treturn {\n\t\t\t$kind: 'SplitCoins',\n\t\t\tSplitCoins: {\n\t\t\t\tcoin: parse(ArgumentSchema, coin),\n\t\t\t\tamounts: amounts.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tMergeCoins(\n\t\tdestination: InferInput<typeof ArgumentSchema>,\n\t\tsources: InferInput<typeof ArgumentSchema>[],\n\t): TransactionShape<'MergeCoins'> {\n\t\treturn {\n\t\t\t$kind: 'MergeCoins',\n\t\t\tMergeCoins: {\n\t\t\t\tdestination: parse(ArgumentSchema, destination),\n\t\t\t\tsources: sources.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): TransactionShape<'Publish'> {\n\t\treturn {\n\t\t\t$kind: 'Publish',\n\t\t\tPublish: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t};\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: InferInput<typeof ArgumentSchema>;\n\t}): TransactionShape<'Upgrade'> {\n\t\treturn {\n\t\t\t$kind: 'Upgrade',\n\t\t\tUpgrade: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: parse(ArgumentSchema, ticket),\n\t\t\t},\n\t\t};\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\ttype?: string;\n\t\telements: InferInput<typeof ArgumentSchema>[];\n\t}): TransactionShape<'MakeMoveVec'> {\n\t\treturn {\n\t\t\t$kind: 'MakeMoveVec',\n\t\t\tMakeMoveVec: {\n\t\t\t\ttype: type ?? null,\n\t\t\t\telements: elements.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tIntent({\n\t\tname,\n\t\tinputs = {},\n\t\tdata = {},\n\t}: {\n\t\tname: string;\n\t\tinputs?: Record<\n\t\t\tstring,\n\t\t\tInferInput<typeof ArgumentSchema> | InferInput<typeof ArgumentSchema>[]\n\t\t>;\n\t\tdata?: Record<string, unknown>;\n\t}): TransactionShape<'$Intent'> {\n\t\treturn {\n\t\t\t$kind: '$Intent',\n\t\t\t$Intent: {\n\t\t\t\tname,\n\t\t\t\tinputs: Object.fromEntries(\n\t\t\t\t\tObject.entries(inputs).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tArray.isArray(value)\n\t\t\t\t\t\t\t? value.map((o) => parse(ArgumentSchema, o))\n\t\t\t\t\t\t\t: parse(ArgumentSchema, value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\tdata,\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { is } from 'valibot';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { ArgumentSchema } from './data/internal.js';\nimport type { Argument, CallArg, Command } from './data/internal.js';\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\n\tif (arg.Object) {\n\t\tif (arg.Object.ImmOrOwnedObject) {\n\t\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\n\t\tif (arg.Object.Receiving) {\n\t\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t\t}\n\n\t\treturn normalizeSuiAddress(arg.Object.SharedObject.objectId);\n\t}\n\n\tif (arg.UnresolvedObject) {\n\t\treturn normalizeSuiAddress(arg.UnresolvedObject.objectId);\n\t}\n\n\treturn undefined;\n}\n\nexport function isArgument(value: unknown): value is Argument {\n\treturn is(ArgumentSchema, value);\n}\n\nexport function remapCommandArguments(\n\tcommand: Command,\n\tinputMapping: Map<number, number>,\n\tcommandMapping: Map<number, number>,\n) {\n\tconst remapArg = (arg: Argument): Argument => {\n\t\tswitch (arg.$kind) {\n\t\t\tcase 'Input': {\n\t\t\t\tconst newInputIndex = inputMapping.get(arg.Input);\n\t\t\t\tif (newInputIndex === undefined) {\n\t\t\t\t\tthrow new Error(`Input ${arg.Input} not found in input mapping`);\n\t\t\t\t}\n\t\t\t\treturn { ...arg, Input: newInputIndex };\n\t\t\t}\n\t\t\tcase 'Result': {\n\t\t\t\tconst newCommandIndex = commandMapping.get(arg.Result);\n\t\t\t\tif (newCommandIndex !== undefined) {\n\t\t\t\t\treturn { ...arg, Result: newCommandIndex };\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t}\n\t\t\tcase 'NestedResult': {\n\t\t\t\tconst newCommandIndex = commandMapping.get(arg.NestedResult[0]);\n\t\t\t\tif (newCommandIndex !== undefined) {\n\t\t\t\t\treturn { ...arg, NestedResult: [newCommandIndex, arg.NestedResult[1]] };\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn arg;\n\t\t}\n\t};\n\n\tswitch (command.$kind) {\n\t\tcase 'MoveCall':\n\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'TransferObjects':\n\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map(remapArg);\n\t\t\tcommand.TransferObjects.address = remapArg(command.TransferObjects.address);\n\t\t\tbreak;\n\t\tcase 'SplitCoins':\n\t\t\tcommand.SplitCoins.coin = remapArg(command.SplitCoins.coin);\n\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'MergeCoins':\n\t\t\tcommand.MergeCoins.destination = remapArg(command.MergeCoins.destination);\n\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'MakeMoveVec':\n\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'Upgrade':\n\t\t\tcommand.Upgrade.ticket = remapArg(command.Upgrade.ticket);\n\t\t\tbreak;\n\t\tcase '$Intent': {\n\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value) ? value.map(remapArg) : remapArg(value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'Publish':\n\t\t\tbreak;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tbigint,\n\tboolean,\n\tcheck,\n\tinteger,\n\tis,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tparse,\n\tpipe,\n\tstring,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionDataSchema } from './internal.js';\nimport type { Argument, ArgumentSchema, TransactionData } from './internal.js';\n\nexport const ObjectRef = object({\n\tdigest: string(),\n\tobjectId: string(),\n\tversion: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n\tImmOrOwned: ObjectRef,\n\tShared: object({\n\t\tobjectId: ObjectID,\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: literal('pure'),\n\t}),\n]);\n\nconst TransactionExpiration = union([\n\tobject({ Epoch: pipe(number(), integer()) }),\n\tobject({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n\tunion([number(), string(), bigint()]),\n\tcheck((val) => {\n\t\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\t\ttry {\n\t\t\tBigInt(val as string);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n\tobject({ bool: nullable(literal(true)) }),\n\tobject({ u8: nullable(literal(true)) }),\n\tobject({ u64: nullable(literal(true)) }),\n\tobject({ u128: nullable(literal(true)) }),\n\tobject({ address: nullable(literal(true)) }),\n\tobject({ signer: nullable(literal(true)) }),\n\tobject({ vector: lazy(() => TypeTag) }),\n\tobject({ struct: lazy(() => StructTag) }),\n\tobject({ u16: nullable(literal(true)) }),\n\tobject({ u32: nullable(literal(true)) }),\n\tobject({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\ttypeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(ObjectRef)),\n\towner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n\tTransactionInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: pipe(number(), integer()) }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: pipe(number(), integer()),\n\t\tresultIndex: pipe(number(), integer()),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: pipe(\n\t\tstring(),\n\t\tcheck((target) => target.split('::').length === 3),\n\t) as GenericSchema<`${string}::${string}::${string}`>,\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\ttype: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n\tobjects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: nullish(TransactionExpiration),\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionInput),\n\ttransactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n\ttransactionData: TransactionData,\n): SerializedTransactionDataV1 {\n\tconst inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n\t\t(input, index) => {\n\t\t\tif (input.Object) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tObject: input.Object.ImmOrOwnedObject\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tImmOrOwned: input.Object.ImmOrOwnedObject,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: input.Object.Receiving\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\t\tdigest: input.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\t\tversion: input.Object.Receiving.version,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tShared: {\n\t\t\t\t\t\t\t\t\t\t\tmutable: input.Object.SharedObject.mutable,\n\t\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.SharedObject.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'object',\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (input.Pure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tPure: Array.from(fromBase64(input.Pure.bytes)),\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedPure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedPure.value,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedObject) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedObject.objectId,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t},\n\t);\n\n\treturn {\n\t\tversion: 1,\n\t\tsender: transactionData.sender ?? undefined,\n\t\texpiration:\n\t\t\ttransactionData.expiration?.$kind === 'Epoch'\n\t\t\t\t? { Epoch: Number(transactionData.expiration.Epoch) }\n\t\t\t\t: transactionData.expiration\n\t\t\t\t\t? { None: true }\n\t\t\t\t\t: null,\n\t\tgasConfig: {\n\t\t\towner: transactionData.gasData.owner ?? undefined,\n\t\t\tbudget: transactionData.gasData.budget ?? undefined,\n\t\t\tprice: transactionData.gasData.price ?? undefined,\n\t\t\tpayment: transactionData.gasData.payment ?? undefined,\n\t\t},\n\t\tinputs,\n\t\ttransactions: transactionData.commands.map((command): InferOutput<typeof TransactionType> => {\n\t\t\tif (command.MakeMoveVec) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\t\ttype:\n\t\t\t\t\t\tcommand.MakeMoveVec.type === null\n\t\t\t\t\t\t\t? { None: true }\n\t\t\t\t\t\t\t: { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n\t\t\t\t\tobjects: command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MergeCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MergeCoins',\n\t\t\t\t\tdestination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n\t\t\t\t\tsources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MoveCall) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MoveCall',\n\t\t\t\t\ttarget: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n\t\t\t\t\ttypeArguments: command.MoveCall.typeArguments,\n\t\t\t\t\targuments: command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.Publish) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Publish',\n\t\t\t\t\tmodules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Publish.dependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.SplitCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'SplitCoins',\n\t\t\t\t\tcoin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n\t\t\t\t\tamounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.TransferObjects) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'TransferObjects',\n\t\t\t\t\tobjects: command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t\taddress: convertTransactionArgument(command.TransferObjects.address, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.Upgrade) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Upgrade',\n\t\t\t\t\tmodules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Upgrade.dependencies,\n\t\t\t\t\tpackageId: command.Upgrade.package,\n\t\t\t\t\tticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(command)}`);\n\t\t}),\n\t};\n}\n\nfunction convertTransactionArgument(\n\targ: Argument,\n\tinputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n\tif (arg.$kind === 'GasCoin') {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\tif (arg.$kind === 'Result') {\n\t\treturn { kind: 'Result', index: arg.Result };\n\t}\n\tif (arg.$kind === 'NestedResult') {\n\t\treturn { kind: 'NestedResult', index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n\t}\n\tif (arg.$kind === 'Input') {\n\t\treturn inputs[arg.Input];\n\t}\n\n\tthrow new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n\treturn parse(TransactionDataSchema, {\n\t\tversion: 2,\n\t\tsender: data.sender ?? null,\n\t\texpiration: data.expiration\n\t\t\t? 'Epoch' in data.expiration\n\t\t\t\t? { Epoch: data.expiration.Epoch }\n\t\t\t\t: { None: true }\n\t\t\t: null,\n\t\tgasData: {\n\t\t\towner: data.gasConfig.owner ?? null,\n\t\t\tbudget: data.gasConfig.budget?.toString() ?? null,\n\t\t\tprice: data.gasConfig.price?.toString() ?? null,\n\t\t\tpayment:\n\t\t\t\tdata.gasConfig.payment?.map((ref) => ({\n\t\t\t\t\tdigest: ref.digest,\n\t\t\t\t\tobjectId: ref.objectId,\n\t\t\t\t\tversion: ref.version.toString(),\n\t\t\t\t})) ?? null,\n\t\t},\n\t\tinputs: data.inputs.map((input) => {\n\t\t\tif (input.kind === 'Input') {\n\t\t\t\tif (is(NormalizedCallArg, input.value)) {\n\t\t\t\t\tconst value = parse(NormalizedCallArg, input.value);\n\n\t\t\t\t\tif (value.Object) {\n\t\t\t\t\t\tif (value.Object.ImmOrOwned) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.ImmOrOwned.objectId,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.ImmOrOwned.version),\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.ImmOrOwned.digest,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Shared) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tSharedObject: {\n\t\t\t\t\t\t\t\t\t\tmutable: value.Object.Shared.mutable ?? null,\n\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: value.Object.Shared.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Shared.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Receiving) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.Receiving.version),\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error('Invalid object input');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: toBase64(new Uint8Array(value.Pure)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'object') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: input.value as string,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tUnresolvedPure: {\n\t\t\t\t\t\tvalue: input.value,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t}),\n\t\tcommands: data.transactions.map((transaction) => {\n\t\t\tswitch (transaction.kind) {\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMakeMoveVec: {\n\t\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t\t'Some' in transaction.type\n\t\t\t\t\t\t\t\t\t? TypeTagSerializer.tagToString(transaction.type.Some)\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\telements: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\tcase 'MergeCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMergeCoins: {\n\t\t\t\t\t\t\tdestination: parseV1TransactionArgument(transaction.destination),\n\t\t\t\t\t\t\tsources: transaction.sources.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'MoveCall': {\n\t\t\t\t\tconst [pkg, mod, fn] = transaction.target.split('::');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMoveCall: {\n\t\t\t\t\t\t\tpackage: pkg,\n\t\t\t\t\t\t\tmodule: mod,\n\t\t\t\t\t\t\tfunction: fn,\n\t\t\t\t\t\t\ttypeArguments: transaction.typeArguments,\n\t\t\t\t\t\t\targuments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Publish': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPublish: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'SplitCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tSplitCoins: {\n\t\t\t\t\t\t\tcoin: parseV1TransactionArgument(transaction.coin),\n\t\t\t\t\t\t\tamounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'TransferObjects': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tTransferObjects: {\n\t\t\t\t\t\t\tobjects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t\taddress: parseV1TransactionArgument(transaction.address),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Upgrade': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUpgrade: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t\tpackage: transaction.packageId,\n\t\t\t\t\t\t\tticket: parseV1TransactionArgument(transaction.ticket),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(transaction)}`);\n\t\t}),\n\t} satisfies InferInput<typeof TransactionDataSchema>);\n}\n\nfunction parseV1TransactionArgument(\n\targ: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof ArgumentSchema> {\n\tswitch (arg.kind) {\n\t\tcase 'GasCoin': {\n\t\t\treturn { GasCoin: true };\n\t\t}\n\t\tcase 'Result':\n\t\t\treturn { Result: arg.index };\n\t\tcase 'NestedResult': {\n\t\t\treturn { NestedResult: [arg.index, arg.resultIndex] };\n\t\t}\n\t\tcase 'Input': {\n\t\t\treturn { Input: arg.index };\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n\tTransactionData,\n} from './data/internal.js';\nimport { ArgumentSchema, TransactionDataSchema } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\nimport { getIdFromCallArg, remapCommandArguments } from './utils.js';\nimport type { TransactionResult } from './Transaction.js';\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2Schema>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapCommandArguments(\n\t\tindex: number,\n\t\tfn: (arg: Argument, command: Command, commandIndex: number) => Argument,\n\t) {\n\t\tconst command = this.commands[index];\n\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MoveCall':\n\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n\t\t\t\tbreak;\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MergeCoins':\n\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'Upgrade':\n\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n\t\t\t\tbreak;\n\t\t\tcase '$Intent':\n\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t? value.map((arg) => fn(arg, command, index))\n\t\t\t\t\t\t: fn(value, command, index);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'Publish':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t}\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command, commandIndex: number) => Argument) {\n\t\tfor (const commandIndex of this.commands.keys()) {\n\t\t\tthis.mapCommandArguments(commandIndex, fn);\n\t\t}\n\t}\n\n\treplaceCommand(\n\t\tindex: number,\n\t\treplacement: Command | Command[],\n\t\tresultIndex: number | { Result: number } | { NestedResult: [number, number] } = index,\n\t) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\n\t\tthis.commands.splice(index, 1, ...structuredClone(replacement));\n\n\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\tif (commandIndex < index + replacement.length) {\n\t\t\t\treturn arg;\n\t\t\t}\n\n\t\t\tif (typeof resultIndex !== 'number') {\n\t\t\t\tif (\n\t\t\t\t\t(arg.$kind === 'Result' && arg.Result === index) ||\n\t\t\t\t\t(arg.$kind === 'NestedResult' && arg.NestedResult[0] === index)\n\t\t\t\t) {\n\t\t\t\t\tif (!('NestedResult' in arg) || arg.NestedResult[1] === 0) {\n\t\t\t\t\t\treturn parse(ArgumentSchema, structuredClone(resultIndex));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot replace command ${index} with a specific result type: NestedResult[${index}, ${arg.NestedResult[1]}] references a nested element that cannot be mapped to the replacement result`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle adjustment of other references\n\t\t\tswitch (arg.$kind) {\n\t\t\t\tcase 'Result':\n\t\t\t\t\tif (arg.Result === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\targ.Result = resultIndex;\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NestedResult':\n\t\t\t\t\tif (arg.NestedResult[0] === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\t\t\tNestedResult: [resultIndex, arg.NestedResult[1]],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treplaceCommandWithTransaction(\n\t\tindex: number,\n\t\totherTransaction: TransactionData,\n\t\tresult: TransactionResult,\n\t) {\n\t\tif (result.$kind !== 'Result' && result.$kind !== 'NestedResult') {\n\t\t\tthrow new Error('Result must be of kind Result or NestedResult');\n\t\t}\n\n\t\tthis.insertTransaction(index, otherTransaction);\n\n\t\tthis.replaceCommand(\n\t\t\tindex + otherTransaction.commands.length,\n\t\t\t[],\n\t\t\t'Result' in result\n\t\t\t\t? { NestedResult: [result.Result + index, 0] }\n\t\t\t\t: {\n\t\t\t\t\t\tNestedResult: [\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[0] + index,\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[1],\n\t\t\t\t\t\t] as [number, number],\n\t\t\t\t\t},\n\t\t);\n\t}\n\n\tinsertTransaction(atCommandIndex: number, otherTransaction: TransactionData) {\n\t\tconst inputMapping = new Map<number, number>();\n\t\tconst commandMapping = new Map<number, number>();\n\n\t\tfor (let i = 0; i < otherTransaction.inputs.length; i++) {\n\t\t\tconst otherInput = otherTransaction.inputs[i];\n\t\t\tconst id = getIdFromCallArg(otherInput);\n\n\t\t\tlet existingIndex = -1;\n\t\t\tif (id !== undefined) {\n\t\t\t\texistingIndex = this.inputs.findIndex((input) => getIdFromCallArg(input) === id);\n\n\t\t\t\tif (\n\t\t\t\t\texistingIndex !== -1 &&\n\t\t\t\t\tthis.inputs[existingIndex].Object?.SharedObject &&\n\t\t\t\t\totherInput.Object?.SharedObject\n\t\t\t\t) {\n\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable =\n\t\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable ||\n\t\t\t\t\t\totherInput.Object.SharedObject.mutable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingIndex !== -1) {\n\t\t\t\tinputMapping.set(i, existingIndex);\n\t\t\t} else {\n\t\t\t\tconst newIndex = this.inputs.length;\n\t\t\t\tthis.inputs.push(otherInput);\n\t\t\t\tinputMapping.set(i, newIndex);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tcommandMapping.set(i, atCommandIndex + i);\n\t\t}\n\n\t\tconst remappedCommands: Command[] = [];\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tconst command = structuredClone(otherTransaction.commands[i]);\n\n\t\t\tremapCommandArguments(command, inputMapping, commandMapping);\n\n\t\t\tremappedCommands.push(command);\n\t\t}\n\n\t\tthis.commands.splice(atCommandIndex, 0, ...remappedCommands);\n\n\t\tconst sizeDiff = remappedCommands.length;\n\t\tif (sizeDiff > 0) {\n\t\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\t\tif (\n\t\t\t\t\tcommandIndex >= atCommandIndex &&\n\t\t\t\t\tcommandIndex < atCommandIndex + remappedCommands.length\n\t\t\t\t) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result >= atCommandIndex) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] >= atCommandIndex) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionDataSchema, this);\n\t}\n\n\tshallowClone() {\n\t\treturn new TransactionDataBuilder({\n\t\t\tversion: this.version,\n\t\t\tsender: this.sender,\n\t\t\texpiration: this.expiration,\n\t\t\tgasData: {\n\t\t\t\t...this.gasData,\n\t\t\t},\n\t\t\tinputs: [...this.inputs],\n\t\t\tcommands: [...this.commands],\n\t\t});\n\t}\n\n\tapplyResolvedData(resolved: TransactionData) {\n\t\tif (!this.sender) {\n\t\t\tthis.sender = resolved.sender ?? null;\n\t\t}\n\n\t\tif (!this.expiration) {\n\t\t\tthis.expiration = resolved.expiration ?? null;\n\t\t}\n\n\t\tif (!this.gasData.budget) {\n\t\t\tthis.gasData.budget = resolved.gasData.budget;\n\t\t}\n\n\t\tif (!this.gasData.owner) {\n\t\t\tthis.gasData.owner = resolved.gasData.owner ?? null;\n\t\t}\n\n\t\tif (!this.gasData.payment) {\n\t\t\tthis.gasData.payment = resolved.gasData.payment;\n\t\t}\n\n\t\tif (!this.gasData.price) {\n\t\t\tthis.gasData.price = resolved.gasData.price;\n\t\t}\n\n\t\tfor (let i = 0; i < this.inputs.length; i++) {\n\t\t\tconst input = this.inputs[i];\n\t\t\tconst resolvedInput = resolved.inputs[i];\n\n\t\t\tswitch (input.$kind) {\n\t\t\t\tcase 'UnresolvedPure':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Pure') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UnresolvedObject':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Object') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'ImmOrOwnedObject' ||\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'Receiving'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved =\n\t\t\t\t\t\t\tresolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving!;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.version != null && original.version !== resolved.version) ||\n\t\t\t\t\t\t\t(original.digest != null && original.digest !== resolved.digest) ||\n\t\t\t\t\t\t\t// Objects with shared object properties should not resolve to owned objects\n\t\t\t\t\t\t\toriginal.mutable != null ||\n\t\t\t\t\t\t\toriginal.initialSharedVersion != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (resolvedInput.Object.$kind === 'SharedObject') {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved = resolvedInput.Object.SharedObject;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.initialSharedVersion != null &&\n\t\t\t\t\t\t\t\toriginal.initialSharedVersion !== resolved.initialSharedVersion) ||\n\t\t\t\t\t\t\t(original.mutable != null && original.mutable !== resolved.mutable) ||\n\t\t\t\t\t\t\t// Objects with owned object properties should not resolve to shared objects\n\t\t\t\t\t\t\toriginal.version != null ||\n\t\t\t\t\t\t\toriginal.digest != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput.Object,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface ClientCacheOptions {\n\tprefix?: string[];\n\tcache?: Map<string, unknown>;\n}\n\nexport class ClientCache {\n\t#prefix: string[];\n\t#cache: Map<string, unknown>;\n\n\tconstructor({ prefix, cache }: ClientCacheOptions = {}) {\n\t\tthis.#prefix = prefix ?? [];\n\t\tthis.#cache = cache ?? new Map();\n\t}\n\n\tread<T>(key: [string, ...string[]], load: () => T | Promise<T>): T | Promise<T> {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\tif (typeof result === 'object' && result !== null && 'then' in result) {\n\t\t\treturn Promise.resolve(result)\n\t\t\t\t.then((v) => {\n\t\t\t\t\tthis.#cache.set(cacheKey, v);\n\t\t\t\t\treturn v as T;\n\t\t\t\t})\n\t\t\t\t.catch((err) => {\n\t\t\t\t\tthis.#cache.delete(cacheKey);\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t}\n\n\t\treturn result as T;\n\t}\n\n\treadSync<T>(key: [string, ...string[]], load: () => T): T {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\treturn result as T;\n\t}\n\n\tclear(prefix?: string[]) {\n\t\tconst prefixKey = [...this.#prefix, ...(prefix ?? [])].join(':');\n\t\tif (!prefixKey) {\n\t\t\tthis.#cache.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const key of this.#cache.keys()) {\n\t\t\tif (key.startsWith(prefixKey)) {\n\t\t\t\tthis.#cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tscope(prefix: string | string[]) {\n\t\treturn new ClientCache({\n\t\t\tprefix: [...this.#prefix, ...(Array.isArray(prefix) ? prefix : [prefix])],\n\t\t\tcache: this.#cache,\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '1.45.0';\nexport const TARGETED_RPC_VERSION = '1.61.0';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { chunk, DataLoader } from '@mysten/utils';\nimport { isValidNamedPackage, isValidNamedType } from '../utils/move-registry.js';\nimport type { StructTag } from '../utils/sui-types.js';\nimport {\n\tisValidSuiAddress,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '../utils/sui-types.js';\nimport type { ClientCache } from './cache.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { PACKAGE_VERSION } from '../version.js';\nimport type { Experimental_SuiClientTypes } from './types.js';\n\nconst NAME_SEPARATOR = '/';\nconst MVR_API_HEADER = {\n\t'Mvr-Source': `@mysten/sui@${PACKAGE_VERSION}`,\n};\n\nexport interface MvrClientOptions {\n\tcache: ClientCache;\n\turl?: string;\n\tpageSize?: number;\n\toverrides?: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n}\n\nexport class MvrClient implements Experimental_SuiClientTypes.MvrMethods {\n\t#cache: ClientCache;\n\t#url?: string;\n\t#pageSize: number;\n\t#overrides: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n\n\tconstructor({ cache, url, pageSize = 50, overrides }: MvrClientOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#url = url;\n\t\tthis.#pageSize = pageSize;\n\t\tthis.#overrides = {\n\t\t\tpackages: overrides?.packages,\n\t\t\ttypes: overrides?.types,\n\t\t};\n\n\t\tvalidateOverrides(this.#overrides);\n\t}\n\n\tget #mvrPackageDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrPackageDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (packages) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${packages.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolvePackages(packages);\n\n\t\t\t\treturn packages.map(\n\t\t\t\t\t(pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`),\n\t\t\t\t);\n\t\t\t});\n\t\t\tconst overrides = this.#overrides?.packages;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [pkg, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(pkg, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tget #mvrTypeDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrTypeDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (types) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${types.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolveTypes(types);\n\n\t\t\t\treturn types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n\t\t\t});\n\n\t\t\tconst overrides = this.#overrides?.types;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [type, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(type, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tasync #resolvePackages(packages: readonly string[]) {\n\t\tif (packages.length === 0) return {};\n\n\t\tconst batches = chunk(packages, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { package_id: string }> }>(\n\t\t\t\t\t'/v1/resolution/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\tnames: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const pkg of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst pkgData = data.resolution[pkg]?.package_id;\n\n\t\t\t\t\tif (!pkgData) continue;\n\n\t\t\t\t\tresults[pkg] = pkgData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #resolveTypes(types: readonly string[]) {\n\t\tif (types.length === 0) return {};\n\n\t\tconst batches = chunk(types, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { type_tag: string }> }>(\n\t\t\t\t\t'/v1/struct-definition/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\ttypes: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const type of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst typeData = data.resolution[type]?.type_tag;\n\t\t\t\t\tif (!typeData) continue;\n\n\t\t\t\t\tresults[type] = typeData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #fetch<T>(url: string, body: Record<string, unknown>): Promise<T> {\n\t\tif (!this.#url) {\n\t\t\tthrow new Error('MVR Api URL is not set for the current client');\n\t\t}\n\n\t\tconst response = await fetch(`${this.#url}${url}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...MVR_API_HEADER,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorBody = await response.json().catch(() => ({}));\n\t\t\tthrow new Error(`Failed to resolve types: ${errorBody?.message}`);\n\t\t}\n\n\t\treturn response.json();\n\t}\n\n\tasync resolvePackage({\n\t\tpackage: name,\n\t}: Experimental_SuiClientTypes.MvrResolvePackageOptions): Promise<Experimental_SuiClientTypes.MvrResolvePackageResponse> {\n\t\tif (!hasMvrName(name)) {\n\t\t\treturn {\n\t\t\t\tpackage: name,\n\t\t\t};\n\t\t}\n\t\tconst resolved = await this.#mvrPackageDataLoader.load(name);\n\t\treturn {\n\t\t\tpackage: resolved,\n\t\t};\n\t}\n\n\tasync resolveType({\n\t\ttype,\n\t}: Experimental_SuiClientTypes.MvrResolveTypeOptions): Promise<Experimental_SuiClientTypes.MvrResolveTypeResponse> {\n\t\tif (!hasMvrName(type)) {\n\t\t\treturn {\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\n\t\tconst mvrTypes = [...extractMvrTypes(type)];\n\t\tconst resolvedTypes = await this.#mvrTypeDataLoader.loadMany(mvrTypes);\n\n\t\tconst typeMap: Record<string, string> = {};\n\n\t\tfor (let i = 0; i < mvrTypes.length; i++) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[mvrTypes[i]] = resolvedType;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: replaceMvrNames(type, typeMap),\n\t\t};\n\t}\n\n\tasync resolve({\n\t\ttypes = [],\n\t\tpackages = [],\n\t}: Experimental_SuiClientTypes.MvrResolveOptions): Promise<Experimental_SuiClientTypes.MvrResolveResponse> {\n\t\tconst mvrTypes = new Set<string>();\n\n\t\tfor (const type of types ?? []) {\n\t\t\textractMvrTypes(type, mvrTypes);\n\t\t}\n\n\t\tconst typesArray = [...mvrTypes];\n\t\tconst [resolvedTypes, resolvedPackages] = await Promise.all([\n\t\t\ttypesArray.length > 0 ? this.#mvrTypeDataLoader.loadMany(typesArray) : [],\n\t\t\tpackages.length > 0 ? this.#mvrPackageDataLoader.loadMany(packages) : [],\n\t\t]);\n\n\t\tconst typeMap: Record<string, string> = {\n\t\t\t...this.#overrides?.types,\n\t\t};\n\n\t\tfor (const [i, type] of typesArray.entries()) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[type] = resolvedType;\n\t\t}\n\n\t\tconst replacedTypes: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const type of types ?? []) {\n\t\t\tconst resolvedType = replaceMvrNames(type, typeMap);\n\n\t\t\treplacedTypes[type] = {\n\t\t\t\ttype: resolvedType,\n\t\t\t};\n\t\t}\n\n\t\tconst replacedPackages: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpackage: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const [i, pkg] of (packages ?? []).entries()) {\n\t\t\tconst resolvedPkg = this.#overrides?.packages?.[pkg] ?? resolvedPackages[i];\n\n\t\t\tif (resolvedPkg instanceof Error) {\n\t\t\t\tthrow resolvedPkg;\n\t\t\t}\n\n\t\t\treplacedPackages[pkg] = {\n\t\t\t\tpackage: resolvedPkg,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttypes: replacedTypes,\n\t\t\tpackages: replacedPackages,\n\t\t};\n\t}\n}\n\nfunction validateOverrides(overrides?: {\n\tpackages?: Record<string, string>;\n\ttypes?: Record<string, string>;\n}) {\n\tif (overrides?.packages) {\n\t\tfor (const [pkg, id] of Object.entries(overrides.packages)) {\n\t\t\tif (!isValidNamedPackage(pkg)) {\n\t\t\t\tthrow new Error(`Invalid package name: ${pkg}`);\n\t\t\t}\n\t\t\tif (!isValidSuiAddress(normalizeSuiAddress(id))) {\n\t\t\t\tthrow new Error(`Invalid package ID: ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (overrides?.types) {\n\t\tfor (const [type, val] of Object.entries(overrides.types)) {\n\t\t\t// validate that types are first-level only.\n\t\t\tif (parseStructTag(type).typeParams.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst parsedValue = parseStructTag(val);\n\n\t\t\tif (!isValidSuiAddress(parsedValue.address)) {\n\t\t\t\tthrow new Error(`Invalid type: ${val}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts all named types from a given type.\n */\nexport function extractMvrTypes(type: string | StructTag, types = new Set<string>()) {\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tconst tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\textractMvrTypes(param, types);\n\t}\n\n\treturn types;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction replaceMvrNames(tag: string | StructTag, typeCache: Record<string, string>): string {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tconst typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn normalizeStructTag({\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache)),\n\t});\n}\n\nexport function hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n\nexport type NamedPackagesOverrides = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tif (command.MakeMoveVec.type) {\n\t\t\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\t\t\ttypes.add(type);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'MoveCall':\n\t\t\t\tconst moveCall = command.MoveCall;\n\n\t\t\t\tconst pkg = moveCall.package.split('::')[0];\n\t\t\t\tif (hasMvrName(pkg)) {\n\t\t\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\t\t\tpackages.add(pkg);\n\t\t\t\t}\n\n\t\t\t\tgetNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n\t\t\t\t\ttypes.add(type);\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(\n\tbuilder: TransactionDataBuilder,\n\tresolved: Experimental_SuiClientTypes.MvrResolveResponse,\n) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!resolved.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !resolved.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = resolved.packages[name].package;\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = resolved.types[types[i]].type;\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '../../experimental/cache.js';\nimport { MvrClient } from '../../experimental/mvr.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\nimport { findNamesInTransaction, replaceNames } from '../../experimental/mvr.js';\nimport type { NamedPackagesOverrides } from '../../experimental/mvr.js';\n\nexport type NamedPackagesPluginOptions = {\n\t/**\n\t * The URL of the MVR API to use for resolving names.\n\t */\n\turl: string;\n\t/**\n\t * The number of names to resolve in each batch request.\n\t * Needs to be calculated based on the GraphQL query limits.\n\t */\n\tpageSize?: number;\n\t/**\n\t * Local overrides for the resolution plugin. Pass this to pre-populate\n\t * the cache with known packages / types (especially useful for local or CI testing).\n\t *\n\t * The type cache expects ONLY first-level types to ensure the cache is more composable.\n\t *\n\t * \tExpected format example:\n\t *  {\n\t * \t\tpackages: {\n\t * \t\t\t'@framework/std': '0x1234',\n\t * \t\t},\n\t * \t\ttypes: {\n\t * \t\t\t'@framework/std::string::String': '0x1234::string::String',\n\t * \t\t},\n\t * \t}\n\t *\n\t */\n\toverrides?: NamedPackagesOverrides;\n};\n\n// The original versions of the mvr plugin cached lookups by mutating overrides.\n// We don't want to mutate the options, but we can link our cache to the provided overrides object\n// This preserves the caching across transactions while removing the mutation side effects\nconst cacheMap = new WeakMap<object, ClientCache>();\n\n/**\n * @experimental This plugin is in experimental phase and there might be breaking changes in the future\n *\n * Adds named resolution so that you can use .move names in your transactions.\n * e.g. `@org/app::type::Type` will be resolved to `0x1234::type::Type`.\n * This plugin will resolve all names & types in the transaction block.\n *\n * To install this plugin globally in your app, use:\n * ```\n * Transaction.registerGlobalSerializationPlugin(\"namedPackagesPlugin\", namedPackagesPlugin({ suiGraphQLClient }));\n * ```\n *\n * You can also define `overrides` to pre-populate name resolutions locally (removes the GraphQL request).\n */\nexport const namedPackagesPlugin = (options?: NamedPackagesPluginOptions) => {\n\tlet mvrClient: MvrClient | undefined;\n\n\tif (options) {\n\t\tconst overrides = options.overrides ?? {\n\t\t\tpackages: {},\n\t\t\ttypes: {},\n\t\t};\n\n\t\tif (!cacheMap.has(overrides)) {\n\t\t\tcacheMap.set(overrides, new ClientCache());\n\t\t}\n\n\t\tmvrClient = new MvrClient({\n\t\t\tcache: cacheMap.get(overrides)!,\n\t\t\turl: options.url,\n\t\t\tpageSize: options.pageSize,\n\t\t\toverrides: overrides,\n\t\t});\n\t}\n\n\treturn async (\n\t\ttransactionData: TransactionDataBuilder,\n\t\tbuildOptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) => {\n\t\tconst names = findNamesInTransaction(transactionData);\n\n\t\tif (names.types.length === 0 && names.packages.length === 0) {\n\t\t\treturn next();\n\t\t}\n\n\t\tconst resolved = await (mvrClient || getClient(buildOptions).core.mvr).resolve({\n\t\t\ttypes: names.types,\n\t\t\tpackages: names.packages,\n\t\t});\n\n\t\treplaceNames(transactionData, resolved);\n\n\t\tawait next();\n\t};\n};\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tinteger,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRefSchema, SuiAddress } from './internal.js';\nimport type { Simplify } from '@mysten/utils';\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n\treturn union(\n\t\tObject.entries(options).map(([key, value]) => object({ [key]: value })),\n\t) as GenericSchema<\n\t\tEnumInputShape<\n\t\t\tSimplify<{\n\t\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t\t}>\n\t\t>\n\t>;\n}\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n\tGasCoin: literal(true),\n\tInput: pipe(number(), integer()),\n\tResult: pipe(number(), integer()),\n\tNestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRefSchema)),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n});\n\nconst $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n\tImmOrOwnedObject: ObjectRefSchema,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRefSchema,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t\tmutable: optional(nullable(boolean())),\n\t}),\n});\n\nconst TransactionExpiration = enumUnion({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2Schema = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n\tdigest: optional(nullable(string())),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2Schema>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRefSchema } from '../transactions/data/internal.js';\nimport type { CallArg, Command, OpenMoveTypeSignature } from '../transactions/data/internal.js';\nimport { Inputs } from '../transactions/Inputs.js';\nimport {\n\tgetPureBcsSchema,\n\tisTxContext,\n\tnormalizedTypeToMoveTypeSignature,\n} from '../transactions/serializer.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\nimport type { BuildTransactionOptions } from '../transactions/index.js';\nimport type { SuiJsonRpcClient } from './client.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport function jsonRpcClientResolveTransactionPlugin(client: SuiJsonRpcClient) {\n\treturn async function resolveTransactionData(\n\t\ttransactionData: TransactionDataBuilder,\n\t\toptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) {\n\t\tawait normalizeInputs(transactionData, client);\n\t\tawait resolveObjectReferences(transactionData, client);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait setGasPrice(transactionData, client);\n\t\t\tawait setGasBudget(transactionData, client);\n\t\t\tawait setGasPayment(transactionData, client);\n\t\t}\n\n\t\treturn await next();\n\t};\n}\n\nasync function setGasPrice(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await client.dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await client.getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) =>\n\t\t\tparse(ObjectRefSchema, payment),\n\t\t);\n\t}\n}\n\nasync function resolveObjectReferences(\n\ttransactionData: TransactionDataBuilder,\n\tclient: SuiJsonRpcClient,\n) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tclient.multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object'\n\t\t\t\t? 'Shared' in owner\n\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t: 'ConsensusAddressOwner' in owner\n\t\t\t\t\t\t? owner.ConsensusAddressOwner.start_version\n\t\t\t\t\t\t: null\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) =>\n\t\t\t\t\tinput?.UnresolvedPure ||\n\t\t\t\t\t(input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== 'boolean'),\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (\n\t\t\ttx.$kind === 'MakeMoveVec' ||\n\t\t\ttx.$kind === 'MergeCoins' ||\n\t\t\ttx.$kind === 'SplitCoins' ||\n\t\t\ttx.$kind === 'TransferObjects'\n\t\t) {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\n\nimport type { ClientWithCoreApi } from '../experimental/index.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\nimport type { BcsType } from '@mysten/bcs';\nimport { Inputs } from './Inputs.js';\nimport { bcs } from '../bcs/index.js';\nimport { jsonRpcClientResolveTransactionPlugin } from '../jsonRpc/json-rpc-resolver.js';\nimport type { SuiJsonRpcClient } from '../jsonRpc/client.js';\n\nexport interface BuildTransactionOptions {\n\tclient?: ClientWithCoreApi;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport function needsTransactionResolution(\n\tdata: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n): boolean {\n\tif (\n\t\tdata.inputs.some((input) => {\n\t\t\treturn input.UnresolvedObject || input.UnresolvedPure;\n\t\t})\n\t) {\n\t\treturn true;\n\t}\n\n\tif (!options.onlyTransactionKind) {\n\t\tif (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport async function resolveTransactionPlugin(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tnormalizeRawArguments(transactionData);\n\tif (!needsTransactionResolution(transactionData, options)) {\n\t\tawait validate(transactionData);\n\t\treturn next();\n\t}\n\n\tconst client = getClient(options);\n\tconst plugin =\n\t\tclient.core?.resolveTransactionPlugin() ??\n\t\tjsonRpcClientResolveTransactionPlugin(client as SuiJsonRpcClient);\n\n\treturn plugin(transactionData, options, async () => {\n\t\tawait validate(transactionData);\n\t\tawait next();\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction normalizeRawArguments(transactionData: TransactionDataBuilder) {\n\tfor (const command of transactionData.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\nimport { Inputs } from './Inputs.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n\tfunction object(value: TransactionObjectInput) {\n\t\treturn makeObject(value);\n\t}\n\n\tobject.system = (options?: { mutable?: boolean }) => {\n\t\tconst mutable = options?.mutable;\n\n\t\tif (mutable !== undefined) {\n\t\t\treturn object(\n\t\t\t\tInputs.SharedObjectRef({\n\t\t\t\t\tobjectId: '0x5',\n\t\t\t\t\tinitialSharedVersion: 1,\n\t\t\t\t\tmutable,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn object({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x5',\n\t\t\t\tinitialSharedVersion: 1,\n\t\t\t},\n\t\t});\n\t};\n\tobject.clock = () =>\n\t\tobject(\n\t\t\tInputs.SharedObjectRef({\n\t\t\t\tobjectId: '0x6',\n\t\t\t\tinitialSharedVersion: 1,\n\t\t\t\tmutable: false,\n\t\t\t}),\n\t\t);\n\tobject.random = () =>\n\t\tobject({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x8',\n\t\t\t\tmutable: false,\n\t\t\t},\n\t\t});\n\tobject.denyList = (options?: { mutable?: boolean }) => {\n\t\treturn object({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x403',\n\t\t\t\tmutable: options?.mutable,\n\t\t\t},\n\t\t});\n\t};\n\tobject.option =\n\t\t({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.moveCall({\n\t\t\t\ttypeArguments: [type],\n\t\t\t\ttarget: `0x1::option::${value === null ? 'none' : 'some'}`,\n\t\t\t\targuments: value === null ? [] : [tx.object(value)],\n\t\t\t});\n\n\treturn object;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { pureBcsSchemaFromTypeName } from '../bcs/pure.js';\nimport type { PureTypeName, ShapeFromPureTypeName, ValidPureTypeName } from '../bcs/pure.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(\n\t\t\tbcs.vector(pureBcsSchemaFromTypeName(type as PureTypeName)).serialize(value as never),\n\t\t);\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command, Argument, ObjectRef } from './data/internal.js';\nimport {\n\tArgumentSchema,\n\tNormalizedCallArg,\n\tObjectRefSchema,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport { needsTransactionResolution, resolveTransactionPlugin } from './resolve.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './resolve.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\nimport { namedPackagesPlugin } from './plugins/NamedPackagesPlugin.js';\nimport type { ClientWithCoreApi } from '../experimental/core.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>\n\t| ((\n\t\t\ttx: Transaction,\n\t  ) => Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>)\n\t| AsyncTransactionThunk<TransactionResultArgument>;\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nexport type TransactionResultArgument =\n\t| Extract<Argument, { Result: unknown }>\n\t| readonly Extract<Argument, { NestedResult: unknown }>[];\n\nexport type AsyncTransactionThunk<\n\tT extends TransactionResultArgument | void = TransactionResultArgument | void,\n> = (tx: Transaction) => Promise<T | void>;\n\nfunction createTransactionResult(\n\tindex: number | (() => number),\n\tlength = Infinity,\n): TransactionResult {\n\tconst baseResult = {\n\t\t$kind: 'Result' as const,\n\t\tget Result() {\n\t\t\treturn typeof index === 'function' ? index() : index;\n\t\t},\n\t};\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tget NestedResult() {\n\t\t\t\treturn [typeof index === 'function' ? index() : index, resultIndex] as [number, number];\n\t\t\t},\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is TransactionLike {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\ntype InputSection = (CallArg | InputSection)[];\ntype CommandSection = (Command | CommandSection)[];\n\ntype TransactionLike = {\n\tgetData(): unknown;\n};\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\t#inputSection: InputSection = [];\n\t#commandSection: CommandSection = [];\n\t#availableResults: Set<number> = new Set();\n\t#pendingPromises = new Set<Promise<unknown>>();\n\t#added = new Map<(...args: any[]) => unknown, unknown>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\ttx.#inputSection = tx.#data.inputs.slice();\n\t\ttx.#commandSection = tx.#data.commands.slice();\n\t\ttx.#availableResults = new Set(tx.#commandSection.map((_, i) => i));\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | TransactionLike) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(\n\t\t\t\ttransaction.getData() as InferInput<typeof SerializedTransactionDataV2Schema>,\n\t\t\t);\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\tnewTransaction.#inputSection = newTransaction.#data.inputs.slice();\n\t\tnewTransaction.#commandSection = newTransaction.#data.commands.slice();\n\t\tnewTransaction.#availableResults = new Set(newTransaction.#commandSection.map((_, i) => i));\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(this.add(value as (tx: Transaction) => TransactionObjectArgument));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(ArgumentSchema, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t#fork() {\n\t\tconst fork = new Transaction();\n\n\t\tfork.#data = this.#data;\n\t\tfork.#serializationPlugins = this.#serializationPlugins;\n\t\tfork.#buildPlugins = this.#buildPlugins;\n\t\tfork.#intentResolvers = this.#intentResolvers;\n\t\tfork.#pendingPromises = this.#pendingPromises;\n\t\tfork.#availableResults = new Set(this.#availableResults);\n\t\tfork.#added = this.#added;\n\t\tthis.#inputSection.push(fork.#inputSection);\n\t\tthis.#commandSection.push(fork.#commandSection);\n\n\t\treturn fork;\n\t}\n\n\t/** Add a transaction to the transaction */\n\n\tadd<T extends Command>(command: T): TransactionResult;\n\tadd<T extends void | TransactionResultArgument | TransactionArgument | Command>(\n\t\tthunk: (tx: Transaction) => T,\n\t): T;\n\tadd<T extends TransactionResultArgument | void>(\n\t\tasyncTransactionThunk: AsyncTransactionThunk<T>,\n\t): T;\n\tadd(command: Command | AsyncTransactionThunk | ((tx: Transaction) => unknown)): unknown {\n\t\tif (typeof command === 'function') {\n\t\t\tif (this.#added.has(command)) {\n\t\t\t\treturn this.#added.get(command);\n\t\t\t}\n\n\t\t\tconst fork = this.#fork();\n\t\t\tconst result = command(fork);\n\n\t\t\tif (!(result && typeof result === 'object' && 'then' in result)) {\n\t\t\t\tthis.#availableResults = fork.#availableResults;\n\t\t\t\tthis.#added.set(command, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tconst placeholder = this.#addCommand({\n\t\t\t\t$kind: '$Intent',\n\t\t\t\t$Intent: {\n\t\t\t\t\tname: 'AsyncTransactionThunk',\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tresultIndex: this.#data.commands.length,\n\t\t\t\t\t\tresult: null as TransactionResult | null,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.#pendingPromises.add(\n\t\t\t\tPromise.resolve(result as Promise<TransactionResult>).then((result) => {\n\t\t\t\t\tplaceholder.$Intent.data.result = result;\n\t\t\t\t}),\n\t\t\t);\n\t\t\tconst txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n\t\t\tthis.#added.set(command, txResult);\n\t\t\treturn txResult;\n\t\t} else {\n\t\t\tthis.#addCommand(command);\n\t\t}\n\n\t\treturn createTransactionResult(this.#data.commands.length - 1);\n\t}\n\n\t#addCommand<T extends Command>(command: T) {\n\t\tconst resultIndex = this.#data.commands.length;\n\t\tthis.#commandSection.push(command);\n\t\tthis.#availableResults.add(resultIndex);\n\t\tthis.#data.commands.push(command);\n\n\t\tthis.#data.mapCommandArguments(resultIndex, (arg) => {\n\t\t\tif (arg.$kind === 'Result' && !this.#availableResults.has(arg.Result)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { Result: ${arg.Result} } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'NestedResult' && !this.#availableResults.has(arg.NestedResult[0])) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'Input' && arg.Input >= this.#data.inputs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\treturn command;\n\t}\n\n\t#addInput<T extends 'pure' | 'object'>(type: T, input: CallArg) {\n\t\tthis.#inputSection.push(input);\n\t\treturn this.#data.addInput(type, input);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\tconst resolved = this.add(arg as never);\n\n\t\t\tif (typeof resolved === 'function') {\n\t\t\t\treturn this.#resolveArgument(resolved);\n\t\t\t}\n\n\t\t\treturn parse(ArgumentSchema, resolved);\n\t\t}\n\n\t\treturn parse(ArgumentSchema, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tthis.#addCommand(command);\n\t\treturn createTransactionResult(this.#data.commands.length - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tconst fullyResolved = this.isFullyResolved();\n\t\treturn JSON.stringify(\n\t\t\tparse(\n\t\t\t\tSerializedTransactionDataV2Schema,\n\t\t\t\tfullyResolved\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...this.#data.snapshot(),\n\t\t\t\t\t\t\tdigest: this.#data.getDigest(),\n\t\t\t\t\t\t}\n\t\t\t\t\t: this.#data.snapshot(),\n\t\t\t),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/**\n\t *  Ensures that:\n\t *  - All objects have been fully resolved to a specific version\n\t *  - All pure inputs have been serialized to bytes\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved\n\t * \t- The gas payment, budget, and price have been set\n\t *  - The transaction sender has been set\n\t *\n\t *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n\t */\n\tisFullyResolved() {\n\t\tif (!this.#data.sender) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#pendingPromises.size > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#data.commands.some((cmd) => cmd.$Intent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (needsTransactionResolution(this.#data, {})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array<ArrayBuffer>> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: ClientWithCoreApi;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionPlugin], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\ttry {\n\t\t\tconst createNext = (i: number) => {\n\t\t\t\tif (i >= plugins.length) {\n\t\t\t\t\treturn () => {};\n\t\t\t\t}\n\t\t\t\tconst plugin = plugins[i];\n\n\t\t\t\treturn async () => {\n\t\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\t\tlet calledNext = false;\n\t\t\t\t\tlet nextResolved = false;\n\n\t\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\t\tawait next();\n\n\t\t\t\t\t\tnextResolved = true;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextResolved) {\n\t\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tawait createNext(0)();\n\t\t} finally {\n\t\t\tthis.#inputSection = this.#data.inputs.slice();\n\t\t\tthis.#commandSection = this.#data.commands.slice();\n\t\t}\n\t}\n\n\tasync #waitForPendingTasks() {\n\t\twhile (this.#pendingPromises.size > 0) {\n\t\t\tconst newPromise = Promise.all(this.#pendingPromises);\n\t\t\tthis.#pendingPromises.clear();\n\t\t\tthis.#pendingPromises.add(newPromise);\n\t\t\tawait newPromise;\n\t\t\tthis.#pendingPromises.delete(newPromise);\n\t\t}\n\t}\n\n\t#sortCommandsAndInputs() {\n\t\tconst unorderedCommands = this.#data.commands;\n\t\tconst unorderedInputs = this.#data.inputs;\n\n\t\tconst orderedCommands = (this.#commandSection as Command[]).flat(Infinity);\n\t\tconst orderedInputs = (this.#inputSection as CallArg[]).flat(Infinity);\n\n\t\tif (orderedCommands.length !== unorderedCommands.length) {\n\t\t\tthrow new Error('Unexpected number of commands found in transaction data');\n\t\t}\n\n\t\tif (orderedInputs.length !== unorderedInputs.length) {\n\t\t\tthrow new Error('Unexpected number of inputs found in transaction data');\n\t\t}\n\n\t\tconst filteredCommands = orderedCommands.filter(\n\t\t\t(cmd) => cmd.$Intent?.name !== 'AsyncTransactionThunk',\n\t\t);\n\n\t\tthis.#data.commands = filteredCommands;\n\t\tthis.#data.inputs = orderedInputs;\n\t\tthis.#commandSection = filteredCommands;\n\t\tthis.#inputSection = orderedInputs;\n\t\tthis.#availableResults = new Set(filteredCommands.map((_, i) => i));\n\n\t\tfunction getOriginalIndex(index: number): number {\n\t\t\tconst command = unorderedCommands[index];\n\t\t\tif (command.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\tconst result = command.$Intent.data.result as TransactionResult | null;\n\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new Error('AsyncTransactionThunk has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn getOriginalIndex(result.Result);\n\t\t\t}\n\n\t\t\tconst updated = filteredCommands.indexOf(command);\n\n\t\t\tif (updated === -1) {\n\t\t\t\tthrow new Error('Unable to find original index for command');\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t}\n\n\t\tthis.#data.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\tconst updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n\n\t\t\t\tif (updated === -1) {\n\t\t\t\t\tthrow new Error('Input has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn { ...arg, Input: updated };\n\t\t\t} else if (arg.$kind === 'Result') {\n\t\t\t\tconst updated = getOriginalIndex(arg.Result);\n\n\t\t\t\treturn { ...arg, Result: updated };\n\t\t\t} else if (arg.$kind === 'NestedResult') {\n\t\t\t\tconst updated = getOriginalIndex(arg.NestedResult[0]);\n\n\t\t\t\treturn { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tfor (const [i, cmd] of unorderedCommands.entries()) {\n\t\t\tif (cmd.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\ttry {\n\t\t\t\t\tcmd.$Intent.data.resultIndex = getOriginalIndex(i);\n\t\t\t\t} catch {\n\t\t\t\t\t// If async thunk did not return a result, this will error, but is safe to ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tawait this.#waitForPendingTasks();\n\t\tthis.#sortCommandsAndInputs();\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tsteps.push(namedPackagesPlugin());\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n"],
  "mappings": ";AAGO,SAAS,WAAWA,eAA+C;AACzE,SAAO,WAAW,KAAK,KAAKA,aAAY,GAAG,CAAC,SAAS,KAAK,WAAW,CAAC,CAAC;AACxE;AAEA,IAAM,aAAa;AACZ,SAAS,SAAS,OAA2B;AAEnD,MAAI,MAAM,SAAS,YAAY;AAC9B,WAAO,KAAK,OAAO,aAAa,GAAG,KAAK,CAAC;EAC1C;AAEA,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,YAAY;AAClD,UAAMC,SAAQ,MAAM,MAAM,GAAG,IAAI,UAAU;AAC3C,cAAU,OAAO,aAAa,GAAGA,MAAK;EACvC;AAEA,SAAO,KAAK,MAAM;AACnB;;;ACTA,SAAS,QAAQ,GAAU;AACzB,SAAO,aAAa,cAAe,YAAY,OAAO,CAAC,KAAK,EAAE,YAAY,SAAS;AACrF;AAEA,SAAS,OAAO,MAA8B,SAAiB;AAC7D,MAAI,CAAC,QAAQ,CAAC;AAAG,UAAM,IAAI,MAAM,qBAAqB;AACtD,MAAI,QAAQ,SAAS,KAAK,CAAC,QAAQ,SAAS,EAAE,MAAM;AAClD,UAAM,IAAI,MAAM,mCAAmC,UAAU,kBAAkB,EAAE,MAAM;AAC3F;AAEA,SAAS,UAAU,UAAmB,KAAU;AAC9C,MAAI,CAAC,MAAM,QAAQ,GAAG;AAAG,WAAO;AAChC,MAAI,IAAI,WAAW;AAAG,WAAO;AAC7B,MAAI,UAAU;AACZ,WAAO,IAAI,MAAM,CAAC,SAAS,OAAO,SAAS,QAAQ;EACrD,OAAO;AACL,WAAO,IAAI,MAAM,CAAC,SAAS,OAAO,cAAc,IAAI,CAAC;EACvD;AACF;AAIA,SAAS,IAAI,OAAe;AAC1B,MAAI,OAAO,UAAU;AAAY,UAAM,IAAI,MAAM,mBAAmB;AACpE,SAAO;AACT;AAEA,SAAS,KAAK,OAAe,OAAc;AACzC,MAAI,OAAO,UAAU;AAAU,UAAM,IAAI,MAAM,GAAG,KAAK,mBAAmB;AAC1E,SAAO;AACT;AAEA,SAAS,QAAQ,GAAS;AACxB,MAAI,CAAC,OAAO,cAAc,CAAC;AAAG,UAAM,IAAI,MAAM,oBAAoB,CAAC,EAAE;AACvE;AAEA,SAAS,KAAK,OAAY;AACxB,MAAI,CAAC,MAAM,QAAQ,KAAK;AAAG,UAAM,IAAI,MAAM,gBAAgB;AAC7D;AACA,SAAS,QAAQ,OAAe,OAAe;AAC7C,MAAI,CAAC,UAAU,MAAM,KAAK;AAAG,UAAM,IAAI,MAAM,GAAG,KAAK,6BAA6B;AACpF;AACA,SAAS,QAAQ,OAAe,OAAe;AAC7C,MAAI,CAAC,UAAU,OAAO,KAAK;AAAG,UAAM,IAAI,MAAM,GAAG,KAAK,6BAA6B;AACrF;AAqBA,SAAS,SAAuC,MAAO;AACrD,QAAM,KAAK,CAAC,MAAW;AAEvB,QAAM,OAAO,CAAC,GAAQ,MAAW,CAAC,MAAW,EAAE,EAAE,CAAC,CAAC;AAEnD,QAAM,SAAS,KAAK,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,YAAY,MAAM,EAAE;AAE7D,QAAM,SAAS,KAAK,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,MAAM,EAAE;AACxD,SAAO,EAAE,QAAQ,OAAM;AACzB;AAOA,SAAS,SAAS,SAA0B;AAE1C,QAAM,WAAW,OAAO,YAAY,WAAW,QAAQ,MAAM,EAAE,IAAI;AACnE,QAAM,MAAM,SAAS;AACrB,UAAQ,YAAY,QAAQ;AAG5B,QAAM,UAAU,IAAI,IAAI,SAAS,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;AACtD,SAAO;IACL,QAAQ,CAAC,WAAoB;AAC3B,WAAK,MAAM;AACX,aAAO,OAAO,IAAI,CAAC,MAAK;AACtB,YAAI,CAAC,OAAO,cAAc,CAAC,KAAK,IAAI,KAAK,KAAK;AAC5C,gBAAM,IAAI,MACR,kDAAkD,CAAC,eAAe,OAAO,EAAE;AAE/E,eAAO,SAAS,CAAC;MACnB,CAAC;IACH;IACA,QAAQ,CAAC,UAA6B;AACpC,WAAK,KAAK;AACV,aAAO,MAAM,IAAI,CAAC,WAAU;AAC1B,aAAK,mBAAmB,MAAM;AAC9B,cAAM,IAAI,QAAQ,IAAI,MAAM;AAC5B,YAAI,MAAM;AAAW,gBAAM,IAAI,MAAM,oBAAoB,MAAM,eAAe,OAAO,EAAE;AACvF,eAAO;MACT,CAAC;IACH;;AAEJ;AAKA,SAAS,KAAK,YAAY,IAAE;AAC1B,OAAK,QAAQ,SAAS;AACtB,SAAO;IACL,QAAQ,CAAC,SAAQ;AACf,cAAQ,eAAe,IAAI;AAC3B,aAAO,KAAK,KAAK,SAAS;IAC5B;IACA,QAAQ,CAAC,OAAM;AACb,WAAK,eAAe,EAAE;AACtB,aAAO,GAAG,MAAM,SAAS;IAC3B;;AAEJ;AAMA,SAAS,QAAQ,MAAc,MAAM,KAAG;AACtC,UAAQ,IAAI;AACZ,OAAK,WAAW,GAAG;AACnB,SAAO;IACL,OAAO,MAAc;AACnB,cAAQ,kBAAkB,IAAI;AAC9B,aAAQ,KAAK,SAAS,OAAQ;AAAG,aAAK,KAAK,GAAG;AAC9C,aAAO;IACT;IACA,OAAO,OAAe;AACpB,cAAQ,kBAAkB,KAAK;AAC/B,UAAI,MAAM,MAAM;AAChB,UAAK,MAAM,OAAQ;AACjB,cAAM,IAAI,MAAM,4DAA4D;AAC9E,aAAO,MAAM,KAAK,MAAM,MAAM,CAAC,MAAM,KAAK,OAAO;AAC/C,cAAM,OAAO,MAAM;AACnB,cAAM,OAAO,OAAO;AACpB,YAAI,OAAO,MAAM;AAAG,gBAAM,IAAI,MAAM,+CAA+C;MACrF;AACA,aAAO,MAAM,MAAM,GAAG,GAAG;IAC3B;;AAEJ;AAKA,SAAS,UAAa,IAAiB;AACrC,MAAI,EAAE;AACN,SAAO,EAAE,QAAQ,CAAC,SAAY,MAAM,QAAQ,CAAC,OAAU,GAAG,EAAE,EAAC;AAC/D;AAKA,SAAS,aAAa,MAAgB,MAAc,IAAU;AAE5D,MAAI,OAAO;AAAG,UAAM,IAAI,MAAM,8BAA8B,IAAI,8BAA8B;AAC9F,MAAI,KAAK;AAAG,UAAM,IAAI,MAAM,4BAA4B,EAAE,8BAA8B;AACxF,OAAK,IAAI;AACT,MAAI,CAAC,KAAK;AAAQ,WAAO,CAAA;AACzB,MAAI,MAAM;AACV,QAAM,MAAM,CAAA;AACZ,QAAM,SAAS,MAAM,KAAK,MAAM,CAAC,MAAK;AACpC,YAAQ,CAAC;AACT,QAAI,IAAI,KAAK,KAAK;AAAM,YAAM,IAAI,MAAM,oBAAoB,CAAC,EAAE;AAC/D,WAAO;EACT,CAAC;AACD,QAAM,OAAO,OAAO;AACpB,SAAO,MAAM;AACX,QAAI,QAAQ;AACZ,QAAI,OAAO;AACX,aAAS,IAAI,KAAK,IAAI,MAAM,KAAK;AAC/B,YAAM,QAAQ,OAAO,CAAC;AACtB,YAAM,YAAY,OAAO;AACzB,YAAM,YAAY,YAAY;AAC9B,UACE,CAAC,OAAO,cAAc,SAAS,KAC/B,YAAY,SAAS,SACrB,YAAY,UAAU,WACtB;AACA,cAAM,IAAI,MAAM,8BAA8B;MAChD;AACA,YAAM,MAAM,YAAY;AACxB,cAAQ,YAAY;AACpB,YAAM,UAAU,KAAK,MAAM,GAAG;AAC9B,aAAO,CAAC,IAAI;AACZ,UAAI,CAAC,OAAO,cAAc,OAAO,KAAK,UAAU,KAAK,UAAU;AAC7D,cAAM,IAAI,MAAM,8BAA8B;AAChD,UAAI,CAAC;AAAM;eACF,CAAC;AAAS,cAAM;;AACpB,eAAO;IACd;AACA,QAAI,KAAK,KAAK;AACd,QAAI;AAAM;EACZ;AACA,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,KAAK,KAAK,CAAC,MAAM,GAAG;AAAK,QAAI,KAAK,CAAC;AACrE,SAAO,IAAI,QAAO;AACpB;AAEA,IAAM,MAAM,CAAC,GAAW,MAAuB,MAAM,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC;AACzE,IAAM,cAAyC,CAAC,MAAc,OAC5D,QAAQ,KAAK,IAAI,MAAM,EAAE;AAC3B,IAAM,UAAoC,MAAK;AAC7C,MAAI,MAAM,CAAA;AACV,WAAS,IAAI,GAAG,IAAI,IAAI;AAAK,QAAI,KAAK,KAAK,CAAC;AAC5C,SAAO;AACT,GAAE;AAIF,SAAS,cAAc,MAAgB,MAAc,IAAYC,UAAgB;AAC/E,OAAK,IAAI;AACT,MAAI,QAAQ,KAAK,OAAO;AAAI,UAAM,IAAI,MAAM,6BAA6B,IAAI,EAAE;AAC/E,MAAI,MAAM,KAAK,KAAK;AAAI,UAAM,IAAI,MAAM,2BAA2B,EAAE,EAAE;AACvE,MAAI,YAAY,MAAM,EAAE,IAAI,IAAI;AAC9B,UAAM,IAAI,MACR,sCAAsC,IAAI,OAAO,EAAE,cAAc,YAAY,MAAM,EAAE,CAAC,EAAE;EAE5F;AACA,MAAI,QAAQ;AACZ,MAAI,MAAM;AACV,QAAM,MAAM,OAAO,IAAI;AACvB,QAAM,OAAO,OAAO,EAAE,IAAK;AAC3B,QAAM,MAAgB,CAAA;AACtB,aAAW,KAAK,MAAM;AACpB,YAAQ,CAAC;AACT,QAAI,KAAK;AAAK,YAAM,IAAI,MAAM,oCAAoC,CAAC,SAAS,IAAI,EAAE;AAClF,YAAS,SAAS,OAAQ;AAC1B,QAAI,MAAM,OAAO;AAAI,YAAM,IAAI,MAAM,qCAAqC,GAAG,SAAS,IAAI,EAAE;AAC5F,WAAO;AACP,WAAO,OAAO,IAAI,OAAO;AAAI,UAAI,MAAO,SAAU,MAAM,KAAO,UAAU,CAAC;AAC1E,UAAM,MAAM,OAAO,GAAG;AACtB,QAAI,QAAQ;AAAW,YAAM,IAAI,MAAM,eAAe;AACtD,aAAS,MAAM;EACjB;AACA,UAAS,SAAU,KAAK,MAAQ;AAChC,MAAI,CAACA,YAAW,OAAO;AAAM,UAAM,IAAI,MAAM,gBAAgB;AAC7D,MAAI,CAACA,YAAW,QAAQ;AAAG,UAAM,IAAI,MAAM,qBAAqB,KAAK,EAAE;AACvE,MAAIA,YAAW,MAAM;AAAG,QAAI,KAAK,UAAU,CAAC;AAC5C,SAAO;AACT;AAKA,SAAS,MAAM,KAAW;AACxB,UAAQ,GAAG;AACX,QAAM,OAAO,KAAK;AAClB,SAAO;IACL,QAAQ,CAAC,UAAqB;AAC5B,UAAI,CAAC,QAAQ,KAAK;AAAG,cAAM,IAAI,MAAM,yCAAyC;AAC9E,aAAO,aAAa,MAAM,KAAK,KAAK,GAAG,MAAM,GAAG;IAClD;IACA,QAAQ,CAAC,WAAoB;AAC3B,cAAQ,gBAAgB,MAAM;AAC9B,aAAO,WAAW,KAAK,aAAa,QAAQ,KAAK,IAAI,CAAC;IACxD;;AAEJ;AAOA,SAAS,OAAO,MAAc,aAAa,OAAK;AAC9C,UAAQ,IAAI;AACZ,MAAI,QAAQ,KAAK,OAAO;AAAI,UAAM,IAAI,MAAM,mCAAmC;AAC/E,MAAI,YAAY,GAAG,IAAI,IAAI,MAAM,YAAY,MAAM,CAAC,IAAI;AACtD,UAAM,IAAI,MAAM,wBAAwB;AAC1C,SAAO;IACL,QAAQ,CAAC,UAAqB;AAC5B,UAAI,CAAC,QAAQ,KAAK;AAAG,cAAM,IAAI,MAAM,0CAA0C;AAC/E,aAAO,cAAc,MAAM,KAAK,KAAK,GAAG,GAAG,MAAM,CAAC,UAAU;IAC9D;IACA,QAAQ,CAAC,WAAoB;AAC3B,cAAQ,iBAAiB,MAAM;AAC/B,aAAO,WAAW,KAAK,cAAc,QAAQ,MAAM,GAAG,UAAU,CAAC;IACnE;;AAEJ;AAGA,SAAS,cAA+C,IAAK;AAC3D,MAAI,EAAE;AACN,SAAO,YAAa,MAAsB;AACxC,QAAI;AACF,aAAO,GAAG,MAAM,MAAM,IAAI;IAC5B,SAAS,GAAG;IAAC;EACf;AACF;AA6CO,IAAM,SAAqB,MAAM,OAAO,CAAC,GAAG,SAAS,kBAAkB,GAAG,KAAK,EAAE,CAAC;AAclF,IAAM,SAAqB,MAChC,OAAO,CAAC,GACR,SAAS,kCAAkC,GAC3C,QAAQ,CAAC,GACT,KAAK,EAAE,CAAC;AAeH,IAAM,cAA0B,MACrC,OAAO,CAAC,GACR,SAAS,kCAAkC,GAC3C,KAAK,EAAE,CAAC;AAaH,IAAM,YAAwB,MACnC,OAAO,CAAC,GACR,SAAS,kCAAkC,GAC3C,QAAQ,CAAC,GACT,KAAK,EAAE,CAAC;AAcH,IAAM,iBAA6B,MACxC,OAAO,CAAC,GACR,SAAS,kCAAkC,GAC3C,KAAK,EAAE,CAAC;AAaH,IAAM,kBAA8B,MACzC,OAAO,CAAC,GACR,SAAS,kCAAkC,GAC3C,KAAK,EAAE,GACP,UAAU,CAAC,MAAc,EAAE,YAAW,EAAG,QAAQ,MAAM,GAAG,EAAE,QAAQ,SAAS,GAAG,CAAC,CAAC;AAKpF,IAAM,oBAA6C,MACjD,OAAQ,WAAmB,KAAK,CAAA,CAAE,EAAE,aAAa,cACjD,OAAQ,WAAmB,eAAe,YAAW;AAEvD,IAAM,sBAAsB,CAAC,GAAW,UAAkB;AACxD,OAAK,UAAU,CAAC;AAChB,QAAM,KAAK,QAAQ,sBAAsB;AACzC,QAAMC,YAAW,QAAQ,cAAc;AACvC,MAAI,EAAE,SAAS,KAAK,CAAC,GAAG,KAAK,CAAC;AAAG,UAAM,IAAI,MAAM,gBAAgB;AACjE,SAAQ,WAAmB,WAAW,GAAG,EAAE,UAAAA,WAAU,mBAAmB,SAAQ,CAAE;AACpF;AAgBO,IAAM,SAAqB,mBAAmB;EACnD,OAAO,GAAC;AAAI,WAAO,CAAC;AAAG,WAAQ,EAAU,SAAQ;EAAI;EACrD,OAAO,GAAC;AAAI,WAAO,oBAAoB,GAAG,KAAK;EAAG;IAChD,MACF,OAAO,CAAC,GACR,SAAS,kEAAkE,GAC3E,QAAQ,CAAC,GACT,KAAK,EAAE,CAAC;AAaH,IAAM,cAA0B,MACrC,OAAO,CAAC,GACR,SAAS,kEAAkE,GAC3E,KAAK,EAAE,CAAC;AAgBH,IAAM,YAAwB,mBAAmB;EACtD,OAAO,GAAC;AAAI,WAAO,CAAC;AAAG,WAAQ,EAAU,SAAS,EAAE,UAAU,YAAW,CAAE;EAAG;EAC9E,OAAO,GAAC;AAAI,WAAO,oBAAoB,GAAG,IAAI;EAAG;IAC/C,MACF,OAAO,CAAC,GACR,SAAS,kEAAkE,GAC3E,QAAQ,CAAC,GACT,KAAK,EAAE,CAAC;AAcH,IAAM,iBAA6B,MACxC,OAAO,CAAC,GACR,SAAS,kEAAkE,GAC3E,KAAK,EAAE,CAAC;AAKV,IAAM,YAAuC,CAAC,QAC5C,MAAM,MAAM,EAAE,GAAG,SAAS,GAAG,GAAG,KAAK,EAAE,CAAC;AAWnC,IAAM,SAAqB,UAChC,4DAA4D;AAKvD,IAAM,eAA2B,UACtC,4DAA4D;AAKvD,IAAM,YAAwB,UACnC,4DAA4D;AAgE9D,IAAM,gBAAyC,MAC7C,SAAS,kCAAkC,GAC3C,KAAK,EAAE,CAAC;AAGV,IAAM,qBAAqB,CAAC,WAAY,WAAY,WAAY,YAAY,SAAU;AACtF,SAAS,cAAc,KAAW;AAChC,QAAM,IAAI,OAAO;AACjB,MAAI,OAAO,MAAM,aAAc;AAC/B,WAAS,IAAI,GAAG,IAAI,mBAAmB,QAAQ,KAAK;AAClD,SAAM,KAAK,IAAK,OAAO;AAAG,aAAO,mBAAmB,CAAC;EACvD;AACA,SAAO;AACT;AAEA,SAAS,aAAa,QAAgB,OAAiB,gBAAgB,GAAC;AACtE,QAAM,MAAM,OAAO;AACnB,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,UAAM,IAAI,OAAO,WAAW,CAAC;AAC7B,QAAI,IAAI,MAAM,IAAI;AAAK,YAAM,IAAI,MAAM,mBAAmB,MAAM,GAAG;AACnE,UAAM,cAAc,GAAG,IAAK,KAAK;EACnC;AACA,QAAM,cAAc,GAAG;AACvB,WAAS,IAAI,GAAG,IAAI,KAAK;AAAK,UAAM,cAAc,GAAG,IAAK,OAAO,WAAW,CAAC,IAAI;AACjF,WAAS,KAAK;AAAO,UAAM,cAAc,GAAG,IAAI;AAChD,WAAS,IAAI,GAAG,IAAI,GAAG;AAAK,UAAM,cAAc,GAAG;AACnD,SAAO;AACP,SAAO,cAAc,OAAO,cAAc,CAAC,MAAM,OAAO,EAAE,CAAE,GAAG,IAAI,GAAG,KAAK,CAAC;AAC9E;AAsBA,SAAS,UAAU,UAA8B;AAC/C,QAAM,iBAAiB,aAAa,WAAW,IAAI;AACnD,QAAM,SAAS,OAAO,CAAC;AACvB,QAAM,YAAY,OAAO;AACzB,QAAM,UAAU,OAAO;AACvB,QAAM,kBAAkB,cAAc,SAAS;AAE/C,WAAS,OACP,QACA,OACA,QAAwB,IAAE;AAE1B,SAAK,wBAAwB,MAAM;AACnC,QAAI,QAAQ,KAAK;AAAG,cAAQ,MAAM,KAAK,KAAK;AAC5C,YAAQ,iBAAiB,KAAK;AAC9B,UAAM,OAAO,OAAO;AACpB,QAAI,SAAS;AAAG,YAAM,IAAI,UAAU,yBAAyB,IAAI,EAAE;AACnE,UAAM,eAAe,OAAO,IAAI,MAAM;AACtC,QAAI,UAAU,SAAS,eAAe;AACpC,YAAM,IAAI,UAAU,UAAU,YAAY,kBAAkB,KAAK,EAAE;AACrE,UAAM,UAAU,OAAO,YAAW;AAClC,UAAM,MAAM,aAAa,SAAS,OAAO,cAAc;AACvD,WAAO,GAAG,OAAO,IAAI,cAAc,OAAO,KAAK,CAAC,GAAG,GAAG;EACxD;AAOA,WAAS,OAAO,KAAa,QAAwB,IAAE;AACrD,SAAK,uBAAuB,GAAG;AAC/B,UAAM,OAAO,IAAI;AACjB,QAAI,OAAO,KAAM,UAAU,SAAS,OAAO;AACzC,YAAM,IAAI,UAAU,0BAA0B,IAAI,KAAK,GAAG,mBAAmB,KAAK,GAAG;AAEvF,UAAM,UAAU,IAAI,YAAW;AAC/B,QAAI,QAAQ,WAAW,QAAQ,IAAI,YAAW;AAC5C,YAAM,IAAI,MAAM,uCAAuC;AACzD,UAAM,WAAW,QAAQ,YAAY,GAAG;AACxC,QAAI,aAAa,KAAK,aAAa;AACjC,YAAM,IAAI,MAAM,yDAAyD;AAC3E,UAAM,SAAS,QAAQ,MAAM,GAAG,QAAQ;AACxC,UAAM,OAAO,QAAQ,MAAM,WAAW,CAAC;AACvC,QAAI,KAAK,SAAS;AAAG,YAAM,IAAI,MAAM,yCAAyC;AAC9E,UAAM,QAAQ,cAAc,OAAO,IAAI,EAAE,MAAM,GAAG,EAAE;AACpD,UAAM,MAAM,aAAa,QAAQ,OAAO,cAAc;AACtD,QAAI,CAAC,KAAK,SAAS,GAAG;AAAG,YAAM,IAAI,MAAM,uBAAuB,GAAG,eAAe,GAAG,GAAG;AACxF,WAAO,EAAE,QAAQ,MAAK;EACxB;AAEA,QAAM,eAAe,cAAc,MAAM;AAEzC,WAAS,cAAc,KAAW;AAChC,UAAM,EAAE,QAAQ,MAAK,IAAK,OAAO,KAAK,KAAK;AAC3C,WAAO,EAAE,QAAQ,OAAO,OAAO,UAAU,KAAK,EAAC;EACjD;AAEA,WAAS,gBAAgB,QAAgB,OAAiB;AACxD,WAAO,OAAO,QAAQ,QAAQ,KAAK,CAAC;EACtC;AAEA,SAAO;IACL;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;AAEJ;AAOO,IAAM,SAAiB,UAAU,QAAQ;AAQzC,IAAM,UAAkB,UAAU,SAAS;AAoBlD,IAAM,iBAA0C,MAC9C,OAAQ,WAAmB,KAAK,CAAA,CAAE,EAAE,UAAU,cAC9C,OAAQ,WAAmB,YAAY,YAAW;AAEpD,IAAM,aAAyB;EAC7B,OAAO,MAAI;AAAI,WAAO,IAAI;AAAG,WAAQ,KAAa,MAAK;EAAI;EAC3D,OAAO,GAAC;AAAI,SAAK,OAAO,CAAC;AAAG,WAAQ,WAAmB,QAAQ,CAAC;EAAG;;AAU9D,IAAM,MAAkB,gBAC3B,aACA,MACE,OAAO,CAAC,GACR,SAAS,kBAAkB,GAC3B,KAAK,EAAE,GACP,UAAU,CAAC,MAAa;AACtB,MAAI,OAAO,MAAM,YAAY,EAAE,SAAS,MAAM;AAC5C,UAAM,IAAI,UACR,oCAAoC,OAAO,CAAC,gBAAgB,EAAE,MAAM,EAAE;AAE1E,SAAO,EAAE,YAAW;AACtB,CAAC,CAAC;;;ACjzBD,IAAM,WAAW,CAAC,WAAuB,OAAO,OAAO,MAAM;AAC7D,IAAM,aAAa,CAAC,QAAgB,OAAO,OAAO,GAAG;;;ACHrD,SAAS,QAAQ,QAAyC;AAChE,QAAM,aAAa,OAAO,WAAW,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI;AAC/D,QAAM,SAAS,WAAW,SAAS,MAAM,IAAI,aAAa,IAAI,UAAU;AACxE,QAAM,SAAS,OAAO,MAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,SAAS,MAAM,EAAE,CAAC,KAAK,CAAC;AAEtF,MAAI,OAAO,WAAW,OAAO,SAAS,GAAG;AACxC,UAAM,IAAI,MAAM,sBAAsB,MAAM,EAAE;EAC/C;AAEA,SAAO,WAAW,KAAK,MAAM;AAC9B;AAEO,SAAS,MAAM,OAA2B;AAChD,SAAO,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE;AAChF;;;ACdO,SAAS,MAASC,QAAqB,MAAqB;AAClE,SAAO,MAAM,KAAK,EAAE,QAAQ,KAAK,KAAKA,OAAM,SAAS,IAAI,EAAE,GAAG,CAAC,GAAG,MAAM;AACvE,WAAOA,OAAM,MAAM,IAAI,OAAO,IAAI,KAAK,IAAI;EAC5C,CAAC;AACF;;;ACEO,SAAS,uBAAmD;AAClE,MAAI;AACJ,MAAI;AAEJ,QAAM,UAAU,IAAI,QAAW,CAAC,SAAS,WAAW;AACnD,eAAW;AACX,eAAW;EACZ,CAAC;AAED,SAAO;IACN;IACA,SAAS;IACT,QAAQ;EACT;AACD;;;ACRO,IAAM,aAAN,MAA8B;EACpC,YAAY,aAA2C,SAAuC;AAC7F,QAAI,OAAO,gBAAgB,YAAY;AACtC,YAAM,IAAI;QACT,uHAC2D,WAAW;MACvE;IACD;AACA,SAAK,eAAe;AACpB,SAAK,gBAAgB,qBAAqB,OAAO;AACjD,SAAK,mBAAmB,wBAAwB,OAAO;AACvD,SAAK,cAAc,mBAAmB,OAAO;AAC7C,SAAK,YAAY,iBAAiB,OAAO;AACzC,SAAK,SAAS;AACd,SAAK,OAAO,aAAa,OAAO;EACjC;;;;EAaA,KAAK,KAAoB;AACxB,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACtC,YAAM,IAAI;QACT,oEAAoE,OAAO,GAAG,CAAC;MAChF;IACD;AAEA,UAAM,QAAQ,gBAAgB,IAAI;AAClC,UAAMC,YAAW,KAAK;AACtB,QAAI;AAGJ,QAAIA,WAAU;AACb,iBAAW,KAAK,YAAY,GAAG;AAC/B,YAAM,gBAAgBA,UAAS,IAAI,QAAQ;AAC3C,UAAI,eAAe;AAClB,cAAM,YAAY,MAAM,cAAc,MAAM,YAAY,CAAC;AACzD,eAAO,IAAI,QAAQ,CAAC,YAAY;AAC/B,oBAAU,KAAK,MAAM;AACpB,oBAAQ,aAAa;UACtB,CAAC;QACF,CAAC;MACF;IACD;AAIA,UAAM,KAAK,KAAK,GAAG;AACnB,UAAM,UAAU,IAAI,QAAW,CAAC,SAAS,WAAW;AACnD,YAAM,UAAU,KAAK,EAAE,SAAS,OAAO,CAAC;IACzC,CAAC;AAGD,QAAIA,WAAU;AACb,MAAAA,UAAS,IAAI,UAAW,OAAO;IAChC;AAEA,WAAO;EACR;;;;;;;;;;;;;;;;;;;;;EAsBA,SAAS,MAAmD;AAC3D,QAAI,CAAC,YAAY,IAAI,GAAG;AACvB,YAAM,IAAI;QACT,2EAA2E,IAAI;MAChF;IACD;AAEA,UAAM,eAAe,CAAC;AACtB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,mBAAa,KAAK,KAAK,KAAK,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,UAAU,KAAK,CAAC;IAC7D;AACA,WAAO,QAAQ,IAAI,YAAY;EAChC;;;;;EAMA,MAAM,KAAc;AACnB,UAAMA,YAAW,KAAK;AACtB,QAAIA,WAAU;AACb,YAAM,WAAW,KAAK,YAAY,GAAG;AACrC,MAAAA,UAAS,OAAO,QAAQ;IACzB;AACA,WAAO;EACR;;;;;;EAOA,WAAiB;AAChB,UAAMA,YAAW,KAAK;AACtB,QAAIA,WAAU;AACb,MAAAA,UAAS,MAAM;IAChB;AACA,WAAO;EACR;;;;;;;EAQA,MAAM,KAAQ,OAAqC;AAClD,UAAMA,YAAW,KAAK;AACtB,QAAIA,WAAU;AACb,YAAM,WAAW,KAAK,YAAY,GAAG;AAGrC,UAAIA,UAAS,IAAI,QAAQ,MAAM,QAAW;AAGzC,YAAI;AACJ,YAAI,iBAAiB,OAAO;AAC3B,oBAAU,QAAQ,OAAO,KAAK;AAG9B,kBAAQ,MAAM,MAAM;UAAC,CAAC;QACvB,OAAO;AACN,oBAAU,QAAQ,QAAQ,KAAK;QAChC;AACA,QAAAA,UAAS,IAAI,UAAU,OAAO;MAC/B;IACD;AACA,WAAO;EACR;AAQD;AA4BA,IAAM;;EAEL,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,aACxD,SAAU,IAAI;AACd,QAAI,CAAC,iBAAiB;AACrB,wBAAkB,QAAQ,QAAQ;IACnC;AACA,oBAAgB,KAAK,MAAM;AAE1B,cAAQ,SAAS,EAAE;IACpB,CAAC;EACF;;IAEA,OAAO,iBAAiB,aACtB,SAAU,IAAI;AAEd,mBAAa,EAAE;IAChB,IACC,SAAU,IAAI;AACd,iBAAW,EAAE;IACd;;;AAGJ,IAAI;AAeJ,SAAS,gBAAsB,QAA4C;AAG1E,QAAM,gBAAgB,OAAO;AAC7B,MACC,kBAAkB,QAClB,CAAC,cAAc,iBACf,cAAc,KAAK,SAAS,OAAO,eAClC;AACD,WAAO;EACR;AAGA,QAAM,WAAW,EAAE,eAAe,OAAO,MAAM,CAAC,GAAG,WAAW,CAAC,EAAE;AAGjE,SAAO,SAAS;AAGhB,SAAO,iBAAiB,MAAM;AAC7B,kBAAc,QAAQ,QAAQ;EAC/B,CAAC;AAED,SAAO;AACR;AAEA,SAAS,cAAoB,QAA+B,OAAoB;AAE/E,QAAM,gBAAgB;AAGtB,MAAI,MAAM,KAAK,WAAW,GAAG;AAC5B,qBAAiB,KAAK;AACtB;EACD;AAIA,MAAI;AACJ,MAAI;AACH,mBAAe,OAAO,aAAa,MAAM,IAAI;EAC9C,SAAS,GAAG;AACX,WAAO;MACN;MACA;MACA,IAAI;QACH,sJAE2B,OAAO,CAAC,CAAC;MACrC;IACD;EACD;AAGA,MAAI,CAAC,gBAAgB,OAAO,aAAa,SAAS,YAAY;AAC7D,WAAO;MACN;MACA;MACA,IAAI;QACH,yJAE0B,OAAO,YAAY,CAAC;MAC/C;IACD;EACD;AAGA,UAAQ,QAAQ,YAAY,EAC1B,KAAK,CAAC,WAAW;AAEjB,QAAI,CAAC,YAAY,MAAM,GAAG;AACzB,YAAM,IAAI;QACT,qKAEsC,OAAO,MAAM,CAAC;MACrD;IACD;AACA,QAAI,OAAO,WAAW,MAAM,KAAK,QAAQ;AACxC,YAAM,IAAI;QACT;;;EAIe,OAAO,MAAM,IAAI,CAAC;;;EAChB,OAAO,MAAM,CAAC;MAChC;IACD;AAGA,qBAAiB,KAAK;AAGtB,aAAS,IAAI,GAAG,IAAI,MAAM,UAAU,QAAQ,KAAK;AAChD,YAAM,QAAQ,OAAO,CAAC;AACtB,UAAI,iBAAiB,OAAO;AAC3B,cAAM,UAAU,CAAC,EAAE,OAAO,KAAK;MAChC,OAAO;AACN,cAAM,UAAU,CAAC,EAAE,QAAQ,KAAK;MACjC;IACD;EACD,CAAC,EACA,MAAM,CAAC,UAAmB;AAC1B,mBAAe,QAAQ,OAAO,KAAc;EAC7C,CAAC;AACH;AAIA,SAAS,eAAqB,QAA+B,OAAoB,OAAc;AAE9F,mBAAiB,KAAK;AACtB,WAAS,IAAI,GAAG,IAAI,MAAM,KAAK,QAAQ,KAAK;AAC3C,WAAO,MAAM,MAAM,KAAK,CAAC,CAAC;AAC1B,UAAM,UAAU,CAAC,EAAE,OAAO,KAAK;EAChC;AACD;AAGA,SAAS,iBAAiB,OAAwB;AACjD,MAAI,MAAM,WAAW;AACpB,aAAS,IAAI,GAAG,IAAI,MAAM,UAAU,QAAQ,KAAK;AAChD,YAAM,UAAU,CAAC,EAAE;IACpB;EACD;AACD;AAGA,SAAS,qBAA8B,SAA+C;AACrF,QAAM,cAAc,CAAC,WAAW,QAAQ,UAAU;AAClD,MAAI,CAAC,aAAa;AACjB,WAAO;EACR;AACA,QAAM,eAAe,WAAW,QAAQ;AACxC,MAAI,iBAAiB,QAAW;AAC/B,WAAO;EACR;AACA,MAAI,OAAO,iBAAiB,YAAY,eAAe,GAAG;AACzD,UAAM,IAAI,UAAU,2CAA2C,YAAY,EAAE;EAC9E;AACA,SAAO;AACR;AAGA,SAAS,wBACR,SAC2B;AAC3B,QAAM,kBAAkB,WAAW,QAAQ;AAC3C,MAAI,oBAAoB,QAAW;AAClC,WAAO;EACR;AACA,MAAI,OAAO,oBAAoB,YAAY;AAC1C,UAAM,IAAI,UAAU,uCAAuC,eAAe,EAAE;EAC7E;AACA,SAAO;AACR;AAGA,SAAS,mBAA4B,SAAsD;AAC1F,QAAM,aAAa,WAAW,QAAQ;AACtC,MAAI,eAAe,QAAW;AAC7B,WAAO,CAAC,QAAW;EACpB;AACA,MAAI,OAAO,eAAe,YAAY;AACrC,UAAM,IAAI,UAAU,kCAAkC,UAAU,EAAE;EACnE;AACA,SAAO;AACR;AAGA,SAAS,iBACR,SAC4C;AAC5C,QAAM,cAAc,CAAC,WAAW,QAAQ,UAAU;AAClD,MAAI,CAAC,aAAa;AACjB,WAAO;EACR;AACA,QAAMA,YAAW,WAAW,QAAQ;AACpC,MAAIA,cAAa,QAAW;AAC3B,WAAO,oBAAI,IAAI;EAChB;AACA,MAAIA,cAAa,MAAM;AACtB,UAAM,iBAAiB,CAAC,OAAO,OAAO,UAAU,OAAO;AACvD,UAAM,mBAAmB,eAAe;MACvC,CAAC,WAAWA,aAAY,OAAOA,UAAS,MAAM,MAAM;IACrD;AACA,QAAI,iBAAiB,WAAW,GAAG;AAClC,YAAM,IAAI,UAAU,sCAAsC,iBAAiB,KAAK,IAAI,CAAC;IACtF;EACD;AACA,SAAOA;AACR;AAEA,SAAS,aAAsB,SAAsD;AACpF,MAAI,WAAW,QAAQ,MAAM;AAC5B,WAAO,QAAQ;EAChB;AAEA,SAAO;AACR;AAEA,SAAS,YAAY,GAAqC;AACzD,SACC,OAAO,MAAM,YACb,MAAM,QACN,YAAY,KACZ,OAAO,EAAE,WAAW,aACnB,EAAE,WAAW,KAAM,EAAE,SAAS,KAAK,OAAO,UAAU,eAAe,KAAK,GAAG,EAAE,SAAS,CAAC;AAE1F;;;AChcO,SAAS,WAAW,KAAgC;AAC1D,MAAI,SAAS,OAAO,GAAG;AACvB,QAAM,MAAgB,CAAC;AACvB,MAAI,MAAM;AAEV,MAAI,WAAW,IAAI;AAClB,WAAO,CAAC,CAAC;EACV;AAEA,SAAO,SAAS,GAAG;AAClB,QAAI,GAAG,IAAI,OAAO,SAAS,KAAK;AAChC,eAAW;AACX,QAAI,SAAS,IAAI;AAChB,UAAI,GAAG,KAAK;IACb;AACA,WAAO;EACR;AAEA,SAAO;AACR;AAIO,SAAS,WAAW,KAGzB;AACD,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,MAAI,MAAM;AAGV,SAAO,MAAM;AACZ,QAAI,OAAO,IAAI,QAAQ;AACtB,YAAM,IAAI,MAAM,oCAAoC;IACrD;AAEA,UAAM,OAAO,IAAI,GAAG;AACpB,WAAO;AACP,aAAS,OAAO,OAAO,GAAI,KAAK;AAChC,SAAK,OAAO,SAAU,GAAG;AACxB;IACD;AACA,aAAS;EACV;AAGA,MAAI,QAAQ,OAAO,OAAO,gBAAgB,GAAG;AAC5C,UAAM,IAAI,MAAM,mDAAmD;EACpE;AAEA,SAAO;IACN,OAAO,OAAO,KAAK;IACnB,QAAQ;EACT;AACD;;;ACzBO,IAAM,YAAN,MAAgB;;;;EAOtB,YAAY,MAAkB;AAL9B,SAAQ,eAAuB;AAM9B,SAAK,WAAW,IAAI,SAAS,KAAK,QAAQ,KAAK,YAAY,KAAK,UAAU;EAC3E;;;;;;;EAOA,MAAM,OAAe;AACpB,SAAK,gBAAgB;AACrB,WAAO;EACR;;;;;EAKA,QAAgB;AACf,UAAM,QAAQ,KAAK,SAAS,SAAS,KAAK,YAAY;AACtD,SAAK,MAAM,CAAC;AACZ,WAAO;EACR;;;;;EAKA,SAAiB;AAChB,UAAM,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,IAAI;AAC7D,SAAK,MAAM,CAAC;AACZ,WAAO;EACR;;;;;EAKA,SAAiB;AAChB,UAAM,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,IAAI;AAC7D,SAAK,MAAM,CAAC;AACZ,WAAO;EACR;;;;;EAKA,SAAiB;AAChB,UAAM,SAAS,KAAK,OAAO;AAC3B,UAAM,SAAS,KAAK,OAAO;AAE3B,UAAM,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG;AAExE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;EACzC;;;;EAIA,UAAkB;AACjB,UAAM,SAAS,OAAO,KAAK,OAAO,CAAC;AACnC,UAAM,SAAS,OAAO,KAAK,OAAO,CAAC;AACnC,UAAM,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAEzE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;EACzC;;;;;EAKA,UAAkB;AACjB,UAAM,SAAS,OAAO,KAAK,QAAQ,CAAC;AACpC,UAAM,SAAS,OAAO,KAAK,QAAQ,CAAC;AACpC,UAAM,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAEzE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;EACzC;;;;;EAKA,UAAU,KAAyB;AAClC,UAAM,QAAQ,KAAK,eAAe,KAAK,SAAS;AAChD,UAAM,QAAQ,IAAI,WAAW,KAAK,SAAS,QAAQ,OAAO,GAAG;AAE7D,SAAK,MAAM,GAAG;AAEd,WAAO;EACR;;;;;;EAMA,WAAmB;AAClB,UAAM,QAAQ,KAAK,eAAe,KAAK,SAAS;AAChD,UAAM,SAAS,IAAI,WAAW,KAAK,SAAS,QAAQ,KAAK;AACzD,UAAM,EAAE,OAAO,OAAO,IAAI,WAAW,MAAM;AAE3C,SAAK,MAAM,MAAM;AAEjB,WAAO;EACR;;;;;;;EAOA,QAAQ,IAAkE;AACzE,UAAM,SAAS,KAAK,SAAS;AAC7B,UAAM,SAAS,CAAC;AAChB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,aAAO,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;IAChC;AACA,WAAO;EACR;AACD;;;AC9IO,SAAS,UAAU,MAAkB,UAA4B;AACvE,UAAQ,UAAU;IACjB,KAAK;AACJ,aAAO,SAAS,IAAI;IACrB,KAAK;AACJ,aAAO,SAAS,IAAI;IACrB,KAAK;AACJ,aAAO,MAAM,IAAI;IAClB;AACC,YAAM,IAAI,MAAM,yDAAyD;EAC3E;AACD;AAsBO,SAAS,uBACf,KACA,oBAAsC,CAAC,KAAK,GAAG,GAC9C;AACD,QAAM,CAAC,MAAM,KAAK,IAAI;AACtB,QAAM,MAAM,CAAC;AACb,MAAI,OAAO;AACX,MAAI,sBAAsB;AAE1B,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,UAAM,OAAO,IAAI,CAAC;AAClB,QAAI,SAAS,MAAM;AAClB;IACD;AACA,QAAI,SAAS,OAAO;AACnB;IACD;AACA,QAAI,wBAAwB,KAAK,SAAS,KAAK;AAC9C,UAAI,KAAK,KAAK,KAAK,CAAC;AACpB,aAAO;AACP;IACD;AACA,YAAQ;EACT;AAEA,MAAI,KAAK,KAAK,KAAK,CAAC;AAEpB,SAAO;AACR;;;ACxCO,IAAM,YAAN,MAAgB;EAOtB,YAAY;IACX,cAAc;IACd,UAAU;IACV,eAAe;EAChB,IAAsB,CAAC,GAAG;AAT1B,SAAQ,eAAuB;AAU9B,SAAK,OAAO;AACZ,SAAK,UAAU;AACf,SAAK,eAAe;AACpB,SAAK,WAAW,IAAI,SAAS,IAAI,YAAY,WAAW,CAAC;EAC1D;EAEQ,iBAAiB,OAAe;AACvC,UAAM,eAAe,KAAK,eAAe;AACzC,QAAI,eAAe,KAAK,MAAM;AAC7B,YAAM,WAAW,KAAK;QACrB,KAAK;QACL,KAAK,IAAI,KAAK,OAAO,cAAc,KAAK,OAAO,KAAK,YAAY;MACjE;AACA,UAAI,eAAe,UAAU;AAC5B,cAAM,IAAI;UACT,yFAAyF,KAAK,IAAI,eAAe,KAAK,OAAO,oBAAoB,YAAY;QAC9J;MACD;AAEA,WAAK,OAAO;AACZ,YAAM,aAAa,IAAI,YAAY,KAAK,IAAI;AAC5C,UAAI,WAAW,UAAU,EAAE,IAAI,IAAI,WAAW,KAAK,SAAS,MAAM,CAAC;AACnE,WAAK,WAAW,IAAI,SAAS,UAAU;IACxC;EACD;;;;;;;EAQA,MAAM,OAAqB;AAC1B,SAAK,gBAAgB;AACrB,WAAO;EACR;;;;;;EAMA,OAAO,OAA8B;AACpC,SAAK,iBAAiB,CAAC;AACvB,SAAK,SAAS,SAAS,KAAK,cAAc,OAAO,KAAK,CAAC;AACvD,WAAO,KAAK,MAAM,CAAC;EACpB;;;;;;EAOA,WAAW,OAAyB;AACnC,SAAK,iBAAiB,MAAM,MAAM;AAElC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,WAAK,SAAS,SAAS,KAAK,eAAe,GAAG,MAAM,CAAC,CAAC;IACvD;AAEA,WAAO,KAAK,MAAM,MAAM,MAAM;EAC/B;;;;;;EAMA,QAAQ,OAA8B;AACrC,SAAK,iBAAiB,CAAC;AACvB,SAAK,SAAS,UAAU,KAAK,cAAc,OAAO,KAAK,GAAG,IAAI;AAC9D,WAAO,KAAK,MAAM,CAAC;EACpB;;;;;;EAMA,QAAQ,OAA8B;AACrC,SAAK,iBAAiB,CAAC;AACvB,SAAK,SAAS,UAAU,KAAK,cAAc,OAAO,KAAK,GAAG,IAAI;AAC9D,WAAO,KAAK,MAAM,CAAC;EACpB;;;;;;EAMA,QAAQ,OAA8B;AACrC,mBAAe,OAAO,KAAK,GAAG,CAAC,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AAEhE,WAAO;EACR;;;;;;;EAOA,SAAS,OAA8B;AACtC,mBAAe,OAAO,KAAK,GAAG,EAAE,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AAEjE,WAAO;EACR;;;;;;;EAOA,SAAS,OAA8B;AACtC,mBAAe,OAAO,KAAK,GAAG,EAAE,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AAEjE,WAAO;EACR;;;;;;;EAOA,UAAU,OAAqB;AAC9B,eAAW,KAAK,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AACjD,WAAO;EACR;;;;;;;;;EASA,SAASC,SAAe,IAAwE;AAC/F,SAAK,UAAUA,QAAO,MAAM;AAC5B,UAAM,KAAKA,OAAM,EAAE,QAAQ,CAAC,IAAI,MAAM,GAAG,MAAM,IAAI,GAAGA,QAAO,MAAM,CAAC;AACpE,WAAO;EACR;;;;;;EAOA,EAAE,OAAO,QAAQ,IAAwC;AACxD,aAAS,IAAI,GAAG,IAAI,KAAK,cAAc,KAAK;AAC3C,YAAM,KAAK,SAAS,SAAS,CAAC;IAC/B;AACA,WAAO,KAAK,QAAQ;EACrB;;;;;EAMA,UAAmC;AAClC,WAAO,IAAI,WAAW,KAAK,SAAS,OAAO,MAAM,GAAG,KAAK,YAAY,CAAC;EACvE;;;;;EAMA,SAAS,UAA4B;AACpC,WAAO,UAAU,KAAK,QAAQ,GAAG,QAAQ;EAC1C;AACD;AAEA,SAAS,eAAeC,SAAgB,MAAc;AACrD,QAAM,SAAS,IAAI,WAAW,IAAI;AAClC,MAAI,IAAI;AACR,SAAOA,UAAS,GAAG;AAClB,WAAO,CAAC,IAAI,OAAOA,UAAS,OAAO,GAAG,CAAC;AACvC,IAAAA,UAASA,UAAS,OAAO,GAAG;AAC5B,SAAK;EACN;AACA,SAAO;AACR;;;;;;;;;;AC7NA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAeO,IAAM,WAAN,MAAMC,UAA0D;EAUtE,YACC,SAQC;AAZF,iBAAA,MAAA,MAAA;AACA,iBAAA,MAAA,UAAA;AAYC,SAAK,OAAO,QAAQ;AACpB,SAAK,OAAO,QAAQ;AACpB,SAAK,iBAAiB,QAAQ,mBAAmB,MAAM;AACvD,iBAAA,MAAK,QAAS,QAAQ,KAAA;AACtB,iBAAA,MAAK,YACJ,QAAQ,cACP,CAAC,OAAOC,aAAY;AACpB,YAAM,SAAS,IAAI,UAAU;QAC5B,aAAa,KAAK,eAAe,KAAK,KAAK;QAC3C,GAAGA;MACJ,CAAC;AACD,mBAAA,MAAK,MAAA,EAAL,KAAA,MAAY,OAAO,MAAA;AACnB,aAAO,OAAO,QAAQ;IACvB,EAAA;AAED,SAAK,WAAW,QAAQ,aAAa,MAAM;IAAC;EAC7C;EAEA,MAAM,OAAc,QAAmB;AACtC,SAAK,SAAS,KAAK;AACnB,iBAAA,MAAK,MAAA,EAAL,KAAA,MAAY,OAAO,MAAA;EACpB;EAEA,UAAU,OAAc,SAA4B;AACnD,SAAK,SAAS,KAAK;AACnB,WAAO,IAAI,cAAc,MAAM,aAAA,MAAK,UAAA,EAAL,KAAA,MAAgB,OAAO,OAAA,CAAQ;EAC/D;EAEA,MAAM,OAAsB;AAC3B,UAAM,SAAS,IAAI,UAAU,KAAK;AAClC,WAAO,KAAK,KAAK,MAAM;EACxB;EAEA,QAAQC,MAAa;AACpB,WAAO,KAAK,MAAM,QAAQA,IAAG,CAAC;EAC/B;EAEA,WAAW,KAAa;AACvB,WAAO,KAAK,MAAM,WAAW,GAAG,CAAC;EAClC;EAEA,WAAW,KAAa;AACvB,WAAO,KAAK,MAAM,WAAW,GAAG,CAAC;EAClC;EAEA,UAAiE;IAChE;IACA;IACA;IACA,UAAAC;EACD,GAGyC;AACxC,WAAO,IAAIH,UAA6B;MACvC,MAAO,QAAQ,KAAK;MACpB,MAAM,CAAC,WAAY,SAAS,OAAO,KAAK,KAAK,MAAM,CAAC,IAAK,KAAK,KAAK,MAAM;MACzE,OAAO,CAAC,OAAO,WAAW,aAAA,MAAK,MAAA,EAAL,KAAA,MAAY,QAAQ,MAAM,KAAK,IAAK,OAAiB,MAAA;MAC/E,gBAAgB,CAAC,UAAU,KAAK,eAAe,QAAQ,MAAM,KAAK,IAAK,KAAe;MACtF,WAAW,CAAC,OAAO,YAClB,aAAA,MAAK,UAAA,EAAL,KAAA,MAAgB,QAAQ,MAAM,KAAK,IAAK,OAAiB,OAAA;MAC1D,UAAU,CAAC,UAAU;AACpB,QAAAG,YAAW,KAAK;AAChB,aAAK,SAAS,QAAQ,MAAM,KAAK,IAAK,KAAe;MACtD;IACD,CAAC;EACF;AACD;AAhFC,SAAA,oBAAA,QAAA;AACA,aAAA,oBAAA,QAAA;AARM,IAAM,UAAN;AAyFP,IAAM,uBAAuB,OAAO,IAAI,wBAAwB;AACzD,SAAS,gBAAgB,KAA6C;AAC5E,SAAO,CAAC,CAAC,OAAO,OAAO,QAAQ,YAAa,IAAY,oBAAoB,MAAM;AACnF;AAEO,IAAM,gBAAN,MAAkC;EAUxC,YAAY,QAA2B,OAAgC;AATvE,iBAAA,MAAA,OAAA;AACA,iBAAA,MAAA,MAAA;AASC,iBAAA,MAAK,SAAU,MAAA;AACf,iBAAA,MAAK,QAAS,KAAA;EACf;;;EAPA,KAAK,oBAAoB,IAAI;AAC5B,WAAO;EACR;EAOA,UAAU;AACT,WAAO,aAAA,MAAK,MAAA;EACb;EAEA,QAAQ;AACP,WAAO,MAAM,aAAA,MAAK,MAAA,CAAM;EACzB;EAEA,WAAW;AACV,WAAO,SAAS,aAAA,MAAK,MAAA,CAAM;EAC5B;EAEA,WAAW;AACV,WAAO,SAAS,aAAA,MAAK,MAAA,CAAM;EAC5B;EAEA,QAAQ;AACP,WAAO,aAAA,MAAK,OAAA,EAAQ,MAAM,aAAA,MAAK,MAAA,CAAM;EACtC;AACD;AAjCC,UAAA,oBAAA,QAAA;AACA,SAAA,oBAAA,QAAA;AAkCM,SAAS,iBAAmE;EAClF;EACA,GAAG;AACJ,GAKoC;AACnC,SAAO,IAAI,QAAwB;IAClC,GAAG;IACH,gBAAgB,MAAM;EACvB,CAAC;AACF;AAEO,SAAS,YAAgD;EAC/D;EACA;EACA,GAAG;AACJ,GAM0C;AACzC,SAAO,iBAAuC;IAC7C,GAAG;IACH,MAAM,CAAC,WAAW,OAAO,UAAU,EAAE;IACrC,OAAO,CAAC,OAAO,WAAW,OAAO,WAAW,EAAE,KAAK;IACnD,UAAU,CAAC,UAAU;AACpB,UAAI,QAAQ,KAAK,QAAQ,QAAQ,UAAU;AAC1C,cAAM,IAAI;UACT,WAAW,QAAQ,IAAI,WAAW,KAAK,+BAA+B,QAAQ,QAAQ;QACvF;MACD;AACA,cAAQ,WAAW,KAAK;IACzB;EACD,CAAC;AACF;AAEO,SAAS,eAAmD;EAClE;EACA;EACA,GAAG;AACJ,GAMsD;AACrD,SAAO,iBAAyD;IAC/D,GAAG;IACH,MAAM,CAAC,WAAW,OAAO,UAAU,EAAE;IACrC,OAAO,CAAC,OAAO,WAAW,OAAO,WAAW,EAAE,OAAO,KAAK,CAAC;IAC3D,UAAU,CAAC,QAAQ;AAClB,YAAM,QAAQ,OAAO,GAAG;AACxB,UAAI,QAAQ,KAAK,QAAQ,QAAQ,UAAU;AAC1C,cAAM,IAAI;UACT,WAAW,QAAQ,IAAI,WAAW,KAAK,+BAA+B,QAAQ,QAAQ;QACvF;MACD;AACA,cAAQ,WAAW,KAAK;IACzB;EACD,CAAC;AACF;AAEO,SAAS,mBAAqE;EACpF;EACA,GAAG;AACJ,GAI8B;AAC7B,QAAM,OAAO,IAAI,QAAkB;IAClC,GAAG;IACH;IACA,OAAO,CAAC,OAAO,WAAW;AACzB,iBAAW,QAAQ,KAAK,UAAU,KAAK,EAAE,QAAQ,GAAG;AACnD,eAAO,OAAO,IAAI;MACnB;IACD;EACD,CAAC;AAED,SAAO;AACR;AAEO,SAAS,kBAAsD;EACrE,SAAAC;EACA;EACA,GAAG;AACJ,GAK0C;AACzC,SAAO,IAAI,QAA8B;IACxC,GAAG;IACH,MAAM,CAAC,WAAW;AACjB,YAAM,SAAS,OAAO,SAAS;AAC/B,YAAM,QAAQ,OAAO,UAAU,MAAM;AAErC,aAAO,UAAU,KAAK;IACvB;IACA,OAAO,CAACF,MAAK,WAAW;AACvB,YAAM,QAAQE,SAAQF,IAAG;AACzB,aAAO,UAAU,MAAM,MAAM;AAC7B,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,eAAO,OAAO,MAAM,CAAC,CAAC;MACvB;IACD;IACA,WAAW,CAAC,UAAU;AACrB,YAAM,QAAQE,SAAQ,KAAK;AAC3B,YAAM,OAAO,WAAW,MAAM,MAAM;AACpC,YAAM,SAAS,IAAI,WAAW,KAAK,SAAS,MAAM,MAAM;AACxD,aAAO,IAAI,MAAM,CAAC;AAClB,aAAO,IAAI,OAAO,KAAK,MAAM;AAE7B,aAAO;IACR;IACA,UAAU,CAAC,UAAU;AACpB,UAAI,OAAO,UAAU,UAAU;AAC9B,cAAM,IAAI,UAAU,WAAW,QAAQ,IAAI,WAAW,KAAK,mBAAmB;MAC/E;AACA,cAAQ,WAAW,KAAK;IACzB;EACD,CAAC;AACF;AAEO,SAAS,YAAsB,IAA6B;AAClE,MAAI,WAAqC;AACzC,WAAS,UAAU;AAClB,QAAI,CAAC,UAAU;AACd,iBAAW,GAAG;IACf;AACA,WAAO;EACR;AAEA,SAAO,IAAI,QAAkB;IAC5B,MAAM;IACN,MAAM,CAAC,SAAS,QAAQ,EAAE,KAAK,IAAI;IACnC,gBAAgB,CAAC,UAAU,QAAQ,EAAE,eAAe,KAAK;IACzD,OAAO,CAAC,OAAO,WAAW,QAAQ,EAAE,MAAM,OAAO,MAAM;IACvD,WAAW,CAAC,OAAO,YAAY,QAAQ,EAAE,UAAU,OAAO,OAAO,EAAE,QAAQ;EAC5E,CAAC;AACF;AAqBO,IAAM,YAAN,cAGG,QAQR;EACD,YAAY,EAAE,MAAM,QAAQ,GAAG,QAAQ,GAA8B;AACpE,UAAM,iBAAiB,OAAO,QAAQ,MAAM;AAE5C,UAAM;MACL;MACA,gBAAgB,CAAC,WAAW;AAC3B,YAAI,QAAQ;AACZ,mBAAW,CAAC,OAAO,IAAI,KAAK,gBAAgB;AAC3C,gBAAM,OAAO,KAAK,eAAe,OAAO,KAAK,CAAC;AAC9C,cAAI,QAAQ,MAAM;AACjB,mBAAO;UACR;AAEA,mBAAS;QACV;AAEA,eAAO;MACR;MACA,MAAM,CAAC,WAAW;AACjB,cAAM,SAAkC,CAAC;AACzC,mBAAW,CAAC,OAAO,IAAI,KAAK,gBAAgB;AAC3C,iBAAO,KAAK,IAAI,KAAK,KAAK,MAAM;QACjC;AAEA,eAAO;MACR;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,mBAAW,CAAC,OAAO,IAAI,KAAK,gBAAgB;AAC3C,eAAK,MAAM,MAAM,KAAK,GAAG,MAAM;QAChC;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AACpB,iBAAS,WAAW,KAAK;AACzB,YAAI,OAAO,UAAU,YAAY,SAAS,MAAM;AAC/C,gBAAM,IAAI,UAAU,0BAA0B,OAAO,KAAK,EAAE;QAC7D;MACD;IACD,CAAC;EACF;AACD;AAqBO,IAAM,UAAN,cAGG,QAQR;EACD,YAAY,EAAE,QAAQ,GAAG,QAAQ,GAA4B;AAC5D,UAAM,iBAAiB,OAAO,QAAQ,MAAgB;AACtD,UAAM;MACL,MAAM,CAAC,WAAW;AACjB,cAAM,QAAQ,OAAO,SAAS;AAE9B,cAAM,YAAY,eAAe,KAAK;AACtC,YAAI,CAAC,WAAW;AACf,gBAAM,IAAI,UAAU,iBAAiB,KAAK,aAAa,QAAQ,IAAI,EAAE;QACtE;AAEA,cAAM,CAAC,MAAM,IAAI,IAAI;AAErB,eAAO;UACN,CAAC,IAAI,GAAG,MAAM,KAAK,MAAM,KAAK;UAC9B,OAAO;QACR;MACD;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,cAAM,CAAC,MAAM,GAAG,IAAI,OAAO,QAAQ,KAAK,EAAE;UAAO,CAAC,CAACC,KAAI,MACtD,OAAO,OAAO,QAAQA,KAAI;QAC3B,EAAE,CAAC;AAEH,iBAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC/C,gBAAM,CAAC,YAAY,UAAU,IAAI,eAAe,CAAC;AACjD,cAAI,eAAe,MAAM;AACxB,mBAAO,UAAU,CAAC;AAClB,wBAAY,MAAM,KAAK,MAAM;AAC7B;UACD;QACD;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AACpB,iBAAS,WAAW,KAAK;AACzB,YAAI,OAAO,UAAU,YAAY,SAAS,MAAM;AAC/C,gBAAM,IAAI,UAAU,0BAA0B,OAAO,KAAK,EAAE;QAC7D;AAEA,cAAM,OAAO,OAAO,KAAK,KAAK,EAAE;UAC/B,CAAC,MAAM,MAAM,CAAC,MAAM,UAAa,OAAO,OAAO,QAAQ,CAAC;QACzD;AAEA,YAAI,KAAK,WAAW,GAAG;AACtB,gBAAM,IAAI;YACT,2CAA2C,KAAK,MAAM,aAAa,QAAQ,IAAI;UAChF;QACD;AAEA,cAAM,CAACC,QAAO,IAAI;AAElB,YAAI,CAAC,OAAO,OAAO,QAAQA,QAAO,GAAG;AACpC,gBAAM,IAAI,UAAU,wBAAwBA,QAAO,EAAE;QACtD;MACD;IACD,CAAC;EACF;AACD;AAmBO,IAAM,WAAN,cAIG,QAQR;EACD,YAAY,EAAE,QAAQ,MAAM,GAAG,QAAQ,GAA6B;AACnE,UAAM;MACL,MAAM,QAAS,IAAI,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,IAAI,CAAC;MACvD,gBAAgB,CAAC,WAAW;AAC3B,YAAI,QAAQ;AACZ,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,gBAAM,OAAO,OAAO,CAAC,EAAE,eAAe,OAAO,CAAC,CAAC;AAC/C,cAAI,QAAQ,MAAM;AACjB,mBAAO;UACR;AAEA,mBAAS;QACV;AAEA,eAAO;MACR;MACA,MAAM,CAAC,WAAW;AACjB,cAAM,SAAoB,CAAC;AAC3B,mBAAW,SAAS,QAAQ;AAC3B,iBAAO,KAAK,MAAM,KAAK,MAAM,CAAC;QAC/B;AACA,eAAO;MACR;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,iBAAO,CAAC,EAAE,MAAM,MAAM,CAAC,GAAG,MAAM;QACjC;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AACpB,iBAAS,WAAW,KAAK;AACzB,YAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC1B,gBAAM,IAAI,UAAU,yBAAyB,OAAO,KAAK,EAAE;QAC5D;AACA,YAAI,MAAM,WAAW,OAAO,QAAQ;AACnC,gBAAM,IAAI,UAAU,4BAA4B,OAAO,MAAM,WAAW,MAAM,MAAM,EAAE;QACvF;MACD;IACD,CAAC;EACF;AACD;;;ACzeA,SAAS,WACR,MACA,MACA,SAKoF;AACpF,SAAO,IAAI,QAAkF;IAC5F,MAAM,CAAC,WAAW;AACjB,YAAM,SAA4B,IAAI,MAAM,IAAI;AAChD,eAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC9B,eAAO,CAAC,IAAI,KAAK,KAAK,MAAM;MAC7B;AACA,aAAO;IACR;IACA,OAAO,CAAC,OAAO,WAAW;AACzB,iBAAW,QAAQ,OAAO;AACzB,aAAK,MAAM,MAAM,MAAM;MACxB;IACD;IACA,GAAG;IACH,MAAO,SAAS,QAAQ,GAAG,KAAK,IAAI,IAAI,IAAI;IAC5C,UAAU,CAAC,UAAU;AACpB,eAAS,WAAW,KAAK;AACzB,UAAI,CAAC,SAAS,OAAO,UAAU,YAAY,EAAE,YAAY,QAAQ;AAChE,cAAM,IAAI,UAAU,yBAAyB,OAAO,KAAK,EAAE;MAC5D;AACA,UAAI,MAAM,WAAW,MAAM;AAC1B,cAAM,IAAI,UAAU,4BAA4B,IAAI,WAAW,MAAM,MAAM,EAAE;MAC9E;IACD;EACD,CAAC;AACF;AAQA,SAAS,OACR,MAC+F;AAC/F,SAAO,IACL,KAAK,UAAU,KAAK,IAAI,KAAK;IAC7B,MAAM;IACN,MAAM;EACP,CAAC,EACA,UAAU;IACV,OAAO,CAAC,UAA+C;AACtD,UAAI,SAAS,MAAM;AAClB,eAAO,EAAE,MAAM,KAAK;MACrB;AAEA,aAAO,EAAE,MAAM,MAAM;IACtB;IACA,QAAQ,CAAC,UAAU;AAClB,UAAI,MAAM,UAAU,QAAQ;AAC3B,eAAO,MAAM;MACd;AAEA,aAAO;IACR;EACD,CAAC;AACH;AAcA,SAAS,OACR,MACA,SAKoF;AACpF,SAAO,IAAI,QAAkF;IAC5F,MAAM,CAAC,WAAW;AACjB,YAAM,SAAS,OAAO,SAAS;AAC/B,YAAM,SAA4B,IAAI,MAAM,MAAM;AAClD,eAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,eAAO,CAAC,IAAI,KAAK,KAAK,MAAM;MAC7B;AACA,aAAO;IACR;IACA,OAAO,CAAC,OAAO,WAAW;AACzB,aAAO,UAAU,MAAM,MAAM;AAC7B,iBAAW,QAAQ,OAAO;AACzB,aAAK,MAAM,MAAM,MAAM;MACxB;IACD;IACA,GAAG;IACH,MAAO,SAAS,QAAQ,UAAU,KAAK,IAAI;IAC3C,UAAU,CAAC,UAAU;AACpB,eAAS,WAAW,KAAK;AACzB,UAAI,CAAC,SAAS,OAAO,UAAU,YAAY,EAAE,YAAY,QAAQ;AAChE,cAAM,IAAI,UAAU,yBAAyB,OAAO,KAAK,EAAE;MAC5D;IACD;EACD,CAAC;AACF;AAcA,SAAS,IACR,SACA,WAKC;AACD,SAAO,IAAI,OAAO,IAAI,MAAM,CAAC,SAAS,SAAS,CAAC,CAAC,EAAE,UAAU;IAC5D,MAAM,OAAO,QAAQ,IAAI,KAAK,UAAU,IAAI;IAC5C,OAAO,CAAC,UAAmD;AAC1D,aAAO,CAAC,GAAG,MAAM,QAAQ,CAAC;IAC3B;IACA,QAAQ,CAAC,UAAU;AAClB,YAAM,SAAS,oBAAI,IAAsC;AACzD,iBAAW,CAAC,KAAK,GAAG,KAAK,OAAO;AAC/B,eAAO,IAAI,KAAK,GAAG;MACpB;AACA,aAAO;IACR;EACD,CAAC;AACF;AAEO,IAAM,MAAM;;;;;;EAMlB,GAAG,SAAkC;AACpC,WAAO,YAAY;MAClB,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,KAAK,IAAI;MACnB,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;EAOA,IAAI,SAAkC;AACrC,WAAO,YAAY;MAClB,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,KAAK,KAAK;MACpB,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;EAOA,IAAI,SAAkC;AACrC,WAAO,YAAY;MAClB,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,KAAK,KAAK;MACpB,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;EAOA,IAAI,SAA4D;AAC/D,WAAO,eAAe;MACrB,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,MAAM,MAAM;MACtB,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;EAOA,KAAK,SAA4D;AAChE,WAAO,eAAe;MACrB,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,MAAM,OAAO;MACvB,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;EAOA,KAAK,SAA4D;AAChE,WAAO,eAAe;MACrB,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,MAAM,OAAO;MACvB,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;EAOA,KAAK,SAAmC;AACvC,WAAO,iBAAiB;MACvB,MAAM;MACN,MAAM,CAAC,WAAW,OAAO,MAAM,MAAM;MACrC,OAAO,CAAC,OAAO,WAAW,OAAO,OAAO,QAAQ,IAAI,CAAC;MACrD,GAAG;MACH,MAAO,SAAS,QAAQ;MACxB,UAAU,CAAC,UAAU;AACpB,iBAAS,WAAW,KAAK;AACzB,YAAI,OAAO,UAAU,WAAW;AAC/B,gBAAM,IAAI,UAAU,2BAA2B,OAAO,KAAK,EAAE;QAC9D;MACD;IACD,CAAC;EACF;;;;;;EAOA,QAAQ,SAAkC;AACzC,WAAO,mBAAmB;MACzB,MAAM,CAAC,WAAW,OAAO,SAAS;MAClC,WAAW,CAAC,UAAU;AACrB,eAAO,WAAW,KAAK,WAAW,KAAK,CAAC;MACzC;MACA,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;;EAQA,MAAwB,MAAS,SAAwD;AACxF,WAAO,iBAA8D;MACpE;MACA,MAAM,CAAC,WAAW,OAAO,UAAU,IAAI;MACvC,OAAO,CAAC,OAAO,WAAW;AACzB,eAAO,WAAW,IAAI,WAAW,KAAK,CAAC;MACxC;MACA,GAAG;MACH,MAAO,SAAS,QAAQ,SAAS,IAAI;MACrC,UAAU,CAAC,UAAU;AACpB,iBAAS,WAAW,KAAK;AACzB,YAAI,CAAC,SAAS,OAAO,UAAU,YAAY,EAAE,YAAY,QAAQ;AAChE,gBAAM,IAAI,UAAU,yBAAyB,OAAO,KAAK,EAAE;QAC5D;AACA,YAAI,MAAM,WAAW,MAAM;AAC1B,gBAAM,IAAI,UAAU,4BAA4B,IAAI,WAAW,MAAM,MAAM,EAAE;QAC9E;MACD;IACD,CAAC;EACF;;;;;;;EAQA,WAAW,SAAwD;AAClE,WAAO,IAAI,QAAoD;MAC9D,MAAM,CAAC,WAAW;AACjB,cAAM,SAAS,OAAO,SAAS;AAE/B,eAAO,OAAO,UAAU,MAAM;MAC/B;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,cAAMC,SAAQ,IAAI,WAAW,KAAK;AAClC,eAAO,UAAUA,OAAM,MAAM;AAC7B,eAAO,WAAWA,MAAK;MACxB;MACA,GAAG;MACH,MAAO,SAAS,QAAQ;MACxB,gBAAgB,CAAC,UAAU;AAC1B,cAAM,SAAS,YAAY,QAAS,MAAM,SAAoB;AAC9D,eAAO,UAAU,OAAO,OAAO,WAAW,MAAM,EAAE,SAAS;MAC5D;MACA,UAAU,CAAC,UAAU;AACpB,iBAAS,WAAW,KAAK;AACzB,YAAI,CAAC,SAAS,OAAO,UAAU,YAAY,EAAE,YAAY,QAAQ;AAChE,gBAAM,IAAI,UAAU,yBAAyB,OAAO,KAAK,EAAE;QAC5D;MACD;IACD,CAAC;EACF;;;;;;EAOA,OAAO,SAAkC;AACxC,WAAO,kBAAkB;MACxB,SAAS,CAAC,UAAU,IAAI,YAAY,EAAE,OAAO,KAAK;MAClD,WAAW,CAAC,UAAU,IAAI,YAAY,EAAE,OAAO,KAAK;MACpD,GAAG;MACH,MAAO,SAAS,QAAQ;IACzB,CAAC;EACF;;;;;;;;EAQA;;;;;;;;EASA;;;;;;;;EASA;;;;;;;;;EAUA,MAKC,QACA,SASC;AACD,WAAO,IAAI,SAAkB;MAC5B;MACA,GAAG;IACJ,CAAC;EACF;;;;;;;;;;;;;EAcA,OACC,MACA,QACA,SAWC;AACD,WAAO,IAAI,UAAa;MACvB;MACA;MACA,GAAG;IACJ,CAAC;EACF;;;;;;;;;;;;;;;;;EAkBA,KACC,MACA,QACA,SAYC;AACD,WAAO,IAAI,QAAiB;MAC3B;MACA;MACA,GAAG;IACJ,CAAC;EACF;;;;;;;;;EAUA;;;;;EAMA,KAA6B,IAAgB;AAC5C,WAAO,YAAY,EAAE;EACtB;AACD;;;AC3hBA,IAAM,WAAW;AAEV,SAAS,cAAc,SAAiB;AAC9C,MAAI,QAAQ,UAAU,GAAG;AACxB,WAAO;EACR;AAEA,QAAM,SAAS,QAAQ,WAAW,IAAI,IAAI,IAAI;AAE9C,SAAO,KAAK,QAAQ,MAAM,QAAQ,SAAS,CAAC,CAAC,GAAG,QAAQ,GAAG,QAAQ,MAAM,EAAE,CAAC;AAC7E;;;ACVA,IAAM,oBACL;AACD,IAAM,sBAAsB;AAC5B,IAAM,yBAAyB;AAExB,SAAS,iBAAiB,MAAuB;AACvD,MAAI,KAAK,SAAS,wBAAwB;AACzC,WAAO;EACR;AAEA,MAAI,KAAK,SAAS,GAAG,GAAG;AACvB,WAAO,kBAAkB,KAAK,IAAI;EACnC;AAEA,SAAO,oBAAoB,KAAK,IAAI;AACrC;AAEO,SAAS,mBAAmB,MAAc,SAAuB,MAAc;AACrF,QAAM,YAAY,KAAK,YAAY;AACnC,MAAI;AAEJ,MAAI,UAAU,SAAS,GAAG,GAAG;AAC5B,QAAI,CAAC,kBAAkB,KAAK,SAAS,GAAG;AACvC,YAAM,IAAI,MAAM,sBAAsB,IAAI,EAAE;IAC7C;AACA,UAAM,CAAC,QAAQ,MAAM,IAAI,UAAU,MAAM,GAAG;AAC5C,YAAQ,CAAC,GAAI,SAAS,OAAO,MAAM,GAAG,IAAI,CAAC,GAAI,MAAM;EACtD,OAAO;AACN,QAAI,CAAC,oBAAoB,KAAK,SAAS,GAAG;AACzC,YAAM,IAAI,MAAM,sBAAsB,IAAI,EAAE;IAC7C;AACA,YAAQ,UAAU,MAAM,GAAG,EAAE,MAAM,GAAG,EAAE;EACzC;AAEA,MAAI,WAAW,OAAO;AACrB,WAAO,GAAG,MAAM,KAAK,GAAG,CAAC;EAC1B;AAEA,SAAO,GAAG,MAAM,MAAM,GAAG,EAAE,EAAE,KAAK,GAAG,CAAC,IAAI,MAAM,MAAM,SAAS,CAAC,CAAC;AAClE;;;ACpCA,IAAM,eAAe;AAErB,IAAM,gBAAgB;AAEtB,IAAM,eAAe;AAErB,IAAM,iBAAiB;AAEhB,IAAM,sBAAsB,CAAC,SAA0B;AAC7D,QAAM,QAAQ,KAAK,MAAM,cAAc;AAEvC,MAAI,MAAM,SAAS,KAAK,MAAM,SAAS,EAAG,QAAO;AAEjD,QAAM,CAAC,KAAK,KAAK,OAAO,IAAI;AAG5B,MAAI,YAAY,UAAa,CAAC,cAAc,KAAK,OAAO,EAAG,QAAO;AAElE,MAAI,CAAC,iBAAiB,GAAG,EAAG,QAAO;AAGnC,SAAO,aAAa,KAAK,GAAG,KAAK,IAAI,SAAS;AAC/C;AAMO,IAAM,mBAAmB,CAAC,SAA0B;AAE1D,QAAM,YAAY,KAAK,MAAM,UAAU;AACvC,aAAW,KAAK,WAAW;AAC1B,QAAI,EAAE,SAAS,cAAc,KAAK,CAAC,oBAAoB,CAAC,EAAG,QAAO;EACnE;AAEA,SAAO;AACR;;;ACnCA,IAAM,mBAAmB;AAGlB,SAAS,yBAAyB,OAAgC;AACxE,MAAI;AACH,UAAM,SAAS,WAAW,KAAK;AAC/B,WAAO,OAAO,WAAW;EAC1B,QAAQ;AACP,WAAO;EACR;AACD;AAQO,IAAM,qBAAqB;AAC3B,SAAS,kBAAkB,OAAgC;AACjE,SAAO,MAAM,KAAK,KAAK,iBAAiB,KAAK,MAAM;AACpD;AAEO,SAAS,mBAAmB,OAAwB;AAC1D,SAAO,kBAAkB,KAAK;AAC/B;AASA,SAAS,aAAa,MAAkC;AACvD,MAAI,CAAC,KAAK,SAAS,IAAI,EAAG,QAAO;AAEjC,SAAO,eAAe,IAAI;AAC3B;AAEO,SAAS,eAAe,MAAyB;AACvD,QAAM,CAAC,SAAS,MAAM,IAAI,KAAK,MAAM,IAAI;AAEzC,QAAM,eAAe,oBAAoB,OAAO;AAEhD,QAAM,OAAO,KAAK,MAAM,QAAQ,SAAS,OAAO,SAAS,CAAC;AAC1D,QAAM,OAAO,KAAK,SAAS,GAAG,IAAI,KAAK,MAAM,GAAG,KAAK,QAAQ,GAAG,CAAC,IAAI;AACrE,QAAM,aAAa,KAAK,SAAS,GAAG,IACjC,uBAAuB,KAAK,MAAM,KAAK,QAAQ,GAAG,IAAI,GAAG,KAAK,YAAY,GAAG,CAAC,CAAC,EAAE;IACjF,CAAC,cAAc,aAAa,UAAU,KAAK,CAAC;EAC7C,IACC,CAAC;AAEJ,SAAO;IACN,SAAS,eAAe,UAAU,oBAAoB,OAAO;IAC7D;IACA;IACA;EACD;AACD;AAEO,SAAS,mBAAmB,MAAkC;AACpE,QAAM,EAAE,SAAS,QAAQ,MAAM,WAAW,IACzC,OAAO,SAAS,WAAW,eAAe,IAAI,IAAI;AAEnD,QAAM,sBACL,YAAY,SAAS,IAClB,IAAI,WACH;IAAI,CAAC,cACL,OAAO,cAAc,WAAW,YAAY,mBAAmB,SAAS;EACzE,EACC,KAAK,GAAG,CAAC,MACV;AAEJ,SAAO,GAAG,OAAO,KAAK,MAAM,KAAK,IAAI,GAAG,mBAAmB;AAC5D;AAaO,SAAS,oBAAoB,OAAe,aAAsB,OAAe;AACvF,MAAI,UAAU,MAAM,YAAY;AAChC,MAAI,CAAC,cAAc,QAAQ,WAAW,IAAI,GAAG;AAC5C,cAAU,QAAQ,MAAM,CAAC;EAC1B;AACA,SAAO,KAAK,QAAQ,SAAS,qBAAqB,GAAG,GAAG,CAAC;AAC1D;AAEO,SAAS,qBAAqB,OAAe,aAAsB,OAAe;AACxF,SAAO,oBAAoB,OAAO,UAAU;AAC7C;AAEA,SAAS,MAAM,OAAwB;AACtC,SAAO,yBAAyB,KAAK,KAAK,KAAK,MAAM,SAAS,MAAM;AACrE;AAEA,SAAS,iBAAiB,OAAuB;AAChD,SAAO,WAAW,KAAK,KAAK,KAAK,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS;AACzE;;;AC3GO,IAAM,eAAe,OAAO,GAAU;AAEtC,IAAM,sBAAsB;AAC5B,IAAM,wBAAwB;AAE9B,IAAM,sBAAsB,qBAAqB,KAAK;AAEtD,IAAM,eAAe,GAAG,qBAAqB;AAC7C,IAAM,6BAAqC,qBAAqB,KAAK;AACrE,IAAM,uBAAuB,qBAAqB,KAAK;;;ACRvD,IAAM,SACX,OAAO,eAAe,YAAY,YAAY,aAAa,WAAW,SAAS;;;ACO3E,SAAUC,SAAQ,GAAU;AAChC,SAAO,aAAa,cAAe,YAAY,OAAO,CAAC,KAAK,EAAE,YAAY,SAAS;AACrF;AAGM,SAAUC,SAAQ,GAAS;AAC/B,MAAI,CAAC,OAAO,cAAc,CAAC,KAAK,IAAI;AAAG,UAAM,IAAI,MAAM,oCAAoC,CAAC;AAC9F;AAGM,SAAUC,QAAO,MAA8B,SAAiB;AACpE,MAAI,CAACF,SAAQ,CAAC;AAAG,UAAM,IAAI,MAAM,qBAAqB;AACtD,MAAI,QAAQ,SAAS,KAAK,CAAC,QAAQ,SAAS,EAAE,MAAM;AAClD,UAAM,IAAI,MAAM,mCAAmC,UAAU,kBAAkB,EAAE,MAAM;AAC3F;AAGM,SAAU,MAAM,GAAQ;AAC5B,MAAI,OAAO,MAAM,cAAc,OAAO,EAAE,WAAW;AACjD,UAAM,IAAI,MAAM,8CAA8C;AAChE,EAAAC,SAAQ,EAAE,SAAS;AACnB,EAAAA,SAAQ,EAAE,QAAQ;AACpB;AAGM,SAAU,QAAQ,UAAe,gBAAgB,MAAI;AACzD,MAAI,SAAS;AAAW,UAAM,IAAI,MAAM,kCAAkC;AAC1E,MAAI,iBAAiB,SAAS;AAAU,UAAM,IAAI,MAAM,uCAAuC;AACjG;AAGM,SAAU,QAAQ,KAAU,UAAa;AAC7C,EAAAC,QAAO,GAAG;AACV,QAAM,MAAM,SAAS;AACrB,MAAI,IAAI,SAAS,KAAK;AACpB,UAAM,IAAI,MAAM,2DAA2D,GAAG;EAChF;AACF;AAaM,SAAU,IAAI,KAAe;AACjC,SAAO,IAAI,YAAY,IAAI,QAAQ,IAAI,YAAY,KAAK,MAAM,IAAI,aAAa,CAAC,CAAC;AACnF;AAGM,SAAU,SAAS,QAAoB;AAC3C,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,WAAO,CAAC,EAAE,KAAK,CAAC;EAClB;AACF;AAGM,SAAU,WAAW,KAAe;AACxC,SAAO,IAAI,SAAS,IAAI,QAAQ,IAAI,YAAY,IAAI,UAAU;AAChE;AAGM,SAAU,KAAK,MAAc,OAAa;AAC9C,SAAQ,QAAS,KAAK,QAAW,SAAS;AAC5C;AAQO,IAAM,QAAiC,MAC5C,IAAI,WAAW,IAAI,YAAY,CAAC,SAAU,CAAC,EAAE,MAAM,EAAE,CAAC,MAAM,IAAK;AAG7D,SAAU,SAAS,MAAY;AACnC,SACI,QAAQ,KAAM,aACd,QAAQ,IAAK,WACb,SAAS,IAAK,QACd,SAAS,KAAM;AAErB;AAEO,IAAM,YAAmC,OAC5C,CAAC,MAAc,IACf,CAAC,MAAc,SAAS,CAAC;AAKvB,SAAU,WAAW,KAAgB;AACzC,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI,CAAC,IAAI,SAAS,IAAI,CAAC,CAAC;EAC1B;AACA,SAAO;AACT;AAEO,IAAM,aAA8C,OACvD,CAAC,MAAmB,IACpB;AAGJ,IAAMC,kBAA0C;;EAE9C,OAAO,WAAW,KAAK,CAAA,CAAE,EAAE,UAAU,cAAc,OAAO,WAAW,YAAY;GAAW;AAG9F,IAAM,QAAwB,MAAM,KAAK,EAAE,QAAQ,IAAG,GAAI,CAAC,GAAG,MAC5D,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC;AAO3B,SAAU,WAAW,OAAiB;AAC1C,EAAAC,QAAO,KAAK;AAEZ,MAAID;AAAe,WAAO,MAAM,MAAK;AAErC,MAAIE,OAAM;AACV,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,IAAAA,QAAO,MAAM,MAAM,CAAC,CAAC;EACvB;AACA,SAAOA;AACT;AAGA,IAAM,SAAS,EAAE,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG;AAC5D,SAAS,cAAc,IAAU;AAC/B,MAAI,MAAM,OAAO,MAAM,MAAM,OAAO;AAAI,WAAO,KAAK,OAAO;AAC3D,MAAI,MAAM,OAAO,KAAK,MAAM,OAAO;AAAG,WAAO,MAAM,OAAO,IAAI;AAC9D,MAAI,MAAM,OAAO,KAAK,MAAM,OAAO;AAAG,WAAO,MAAM,OAAO,IAAI;AAC9D;AACF;AAMM,SAAU,WAAWA,MAAW;AACpC,MAAI,OAAOA,SAAQ;AAAU,UAAM,IAAI,MAAM,8BAA8B,OAAOA,IAAG;AAErF,MAAIF;AAAe,WAAO,WAAW,QAAQE,IAAG;AAChD,QAAM,KAAKA,KAAI;AACf,QAAM,KAAK,KAAK;AAChB,MAAI,KAAK;AAAG,UAAM,IAAI,MAAM,qDAAqD,EAAE;AACnF,QAAMC,SAAQ,IAAI,WAAW,EAAE;AAC/B,WAAS,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,MAAM,MAAM,GAAG;AAC/C,UAAM,KAAK,cAAcD,KAAI,WAAW,EAAE,CAAC;AAC3C,UAAM,KAAK,cAAcA,KAAI,WAAW,KAAK,CAAC,CAAC;AAC/C,QAAI,OAAO,UAAa,OAAO,QAAW;AACxC,YAAM,OAAOA,KAAI,EAAE,IAAIA,KAAI,KAAK,CAAC;AACjC,YAAM,IAAI,MAAM,iDAAiD,OAAO,gBAAgB,EAAE;IAC5F;AACA,IAAAC,OAAM,EAAE,IAAI,KAAK,KAAK;EACxB;AACA,SAAOA;AACT;AAkCM,SAAU,YAAY,KAAW;AACrC,MAAI,OAAO,QAAQ;AAAU,UAAM,IAAI,MAAM,iBAAiB;AAC9D,SAAO,IAAI,WAAW,IAAI,YAAW,EAAG,OAAO,GAAG,CAAC;AACrD;AAiBM,SAAU,QAAQ,MAAW;AACjC,MAAI,OAAO,SAAS;AAAU,WAAO,YAAY,IAAI;AACrD,EAAAC,QAAO,IAAI;AACX,SAAO;AACT;AAQM,SAAU,gBAAgB,MAAc;AAC5C,MAAI,OAAO,SAAS;AAAU,WAAO,YAAY,IAAI;AACrD,EAAAA,QAAO,IAAI;AACX,SAAO;AACT;AAGM,SAAU,eAAe,QAAoB;AACjD,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,IAAI,OAAO,CAAC;AAClB,IAAAA,QAAO,CAAC;AACR,WAAO,EAAE;EACX;AACA,QAAM,MAAM,IAAI,WAAW,GAAG;AAC9B,WAAS,IAAI,GAAG,MAAM,GAAG,IAAI,OAAO,QAAQ,KAAK;AAC/C,UAAM,IAAI,OAAO,CAAC;AAClB,QAAI,IAAI,GAAG,GAAG;AACd,WAAO,EAAE;EACX;AACA,SAAO;AACT;AAGM,SAAU,UACd,UACA,MAAS;AAET,MAAI,SAAS,UAAa,CAAA,EAAG,SAAS,KAAK,IAAI,MAAM;AACnD,UAAM,IAAI,MAAM,uCAAuC;AACzD,QAAM,SAAS,OAAO,OAAO,UAAU,IAAI;AAC3C,SAAO;AACT;AAWM,IAAgB,OAAhB,MAAoB;;AA4CpB,SAAU,aACd,UAAuB;AAOvB,QAAM,QAAQ,CAAC,QAA2B,SAAQ,EAAG,OAAO,QAAQ,GAAG,CAAC,EAAE,OAAM;AAChF,QAAM,MAAM,SAAQ;AACpB,QAAM,YAAY,IAAI;AACtB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,MAAM,SAAQ;AAC7B,SAAO;AACT;AAEM,SAAU,gBACd,UAA+B;AAO/B,QAAM,QAAQ,CAAC,KAAY,SAAyB,SAAS,IAAI,EAAE,OAAO,QAAQ,GAAG,CAAC,EAAE,OAAM;AAC9F,QAAM,MAAM,SAAS,CAAA,CAAO;AAC5B,QAAM,YAAY,IAAI;AACtB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,CAAC,SAAa,SAAS,IAAI;AAC1C,SAAO;AACT;AAsBM,SAAU,YAAY,cAAc,IAAE;AAC1C,MAAI,UAAU,OAAO,OAAO,oBAAoB,YAAY;AAC1D,WAAO,OAAO,gBAAgB,IAAI,WAAW,WAAW,CAAC;EAC3D;AAEA,MAAI,UAAU,OAAO,OAAO,gBAAgB,YAAY;AACtD,WAAO,WAAW,KAAK,OAAO,YAAY,WAAW,CAAC;EACxD;AACA,QAAM,IAAI,MAAM,wCAAwC;AAC1D;;;AC/XO,IAAM,SAAqC,WAAW,KAAK;EAChE;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAI;EAClD;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;EACnD;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EACnD;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EACnD;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAG;EAAI;EAAI;EAAG;EAAG;EAAG;EAClD;EAAG;EAAI;EAAG;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EAAI;EAAG;EACnD;EAAI;EAAG;EAAG;EAAI;EAAI;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAClD;EAAI;EAAI;EAAG;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAG;EAAG;EAClD;EAAG;EAAI;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EACnD;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAG;EAAI;EAAG;EAAI;EAAI;EACnD;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAI;EAClD;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;;EAEnD;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EACnD;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EACnD;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAG;EAAI;EAAI;EAAG;EAAG;EAAG;EAClD;EAAG;EAAI;EAAG;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EAAI;EAAG;CACpD;AAMK,SAAU,IAAI,GAAW,GAAW,GAAW,GAAW,GAAS;AACvE,MAAK,IAAI,IAAI,IAAK;AAClB,MAAI,KAAK,IAAI,GAAG,EAAE;AAClB,MAAK,IAAI,IAAK;AACd,MAAI,KAAK,IAAI,GAAG,EAAE;AAClB,SAAO,EAAE,GAAG,GAAG,GAAG,EAAC;AACrB;AAEM,SAAU,IAAI,GAAW,GAAW,GAAW,GAAW,GAAS;AACvE,MAAK,IAAI,IAAI,IAAK;AAClB,MAAI,KAAK,IAAI,GAAG,CAAC;AACjB,MAAK,IAAI,IAAK;AACd,MAAI,KAAK,IAAI,GAAG,CAAC;AACjB,SAAO,EAAE,GAAG,GAAG,GAAG,EAAC;AACrB;;;AC1CM,SAAU,aACd,MACA,YACA,OACAC,OAAa;AAEb,MAAI,OAAO,KAAK,iBAAiB;AAAY,WAAO,KAAK,aAAa,YAAY,OAAOA,KAAI;AAC7F,QAAMC,QAAO,OAAO,EAAE;AACtB,QAAM,WAAW,OAAO,UAAU;AAClC,QAAM,KAAK,OAAQ,SAASA,QAAQ,QAAQ;AAC5C,QAAM,KAAK,OAAO,QAAQ,QAAQ;AAClC,QAAM,IAAID,QAAO,IAAI;AACrB,QAAM,IAAIA,QAAO,IAAI;AACrB,OAAK,UAAU,aAAa,GAAG,IAAIA,KAAI;AACvC,OAAK,UAAU,aAAa,GAAG,IAAIA,KAAI;AACzC;AAGM,SAAU,IAAI,GAAW,GAAW,GAAS;AACjD,SAAQ,IAAI,IAAM,CAAC,IAAI;AACzB;AAGM,SAAU,IAAI,GAAW,GAAW,GAAS;AACjD,SAAQ,IAAI,IAAM,IAAI,IAAM,IAAI;AAClC;AAMM,IAAgB,SAAhB,cAAoD,KAAO;EAoB/D,YAAY,UAAkB,WAAmB,WAAmBA,OAAa;AAC/E,UAAK;AANG,SAAA,WAAW;AACX,SAAA,SAAS;AACT,SAAA,MAAM;AACN,SAAA,YAAY;AAIpB,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,OAAOA;AACZ,SAAK,SAAS,IAAI,WAAW,QAAQ;AACrC,SAAK,OAAO,WAAW,KAAK,MAAM;EACpC;EACA,OAAO,MAAW;AAChB,YAAQ,IAAI;AACZ,WAAO,QAAQ,IAAI;AACnB,IAAAE,QAAO,IAAI;AACX,UAAM,EAAE,MAAM,QAAQ,SAAQ,IAAK;AACnC,UAAM,MAAM,KAAK;AACjB,aAAS,MAAM,GAAG,MAAM,OAAO;AAC7B,YAAM,OAAO,KAAK,IAAI,WAAW,KAAK,KAAK,MAAM,GAAG;AAEpD,UAAI,SAAS,UAAU;AACrB,cAAM,WAAW,WAAW,IAAI;AAChC,eAAO,YAAY,MAAM,KAAK,OAAO;AAAU,eAAK,QAAQ,UAAU,GAAG;AACzE;MACF;AACA,aAAO,IAAI,KAAK,SAAS,KAAK,MAAM,IAAI,GAAG,KAAK,GAAG;AACnD,WAAK,OAAO;AACZ,aAAO;AACP,UAAI,KAAK,QAAQ,UAAU;AACzB,aAAK,QAAQ,MAAM,CAAC;AACpB,aAAK,MAAM;MACb;IACF;AACA,SAAK,UAAU,KAAK;AACpB,SAAK,WAAU;AACf,WAAO;EACT;EACA,WAAW,KAAe;AACxB,YAAQ,IAAI;AACZ,YAAQ,KAAK,IAAI;AACjB,SAAK,WAAW;AAIhB,UAAM,EAAE,QAAQ,MAAM,UAAU,MAAAF,MAAI,IAAK;AACzC,QAAI,EAAE,IAAG,IAAK;AAEd,WAAO,KAAK,IAAI;AAChB,UAAM,KAAK,OAAO,SAAS,GAAG,CAAC;AAG/B,QAAI,KAAK,YAAY,WAAW,KAAK;AACnC,WAAK,QAAQ,MAAM,CAAC;AACpB,YAAM;IACR;AAEA,aAAS,IAAI,KAAK,IAAI,UAAU;AAAK,aAAO,CAAC,IAAI;AAIjD,iBAAa,MAAM,WAAW,GAAG,OAAO,KAAK,SAAS,CAAC,GAAGA,KAAI;AAC9D,SAAK,QAAQ,MAAM,CAAC;AACpB,UAAM,QAAQ,WAAW,GAAG;AAC5B,UAAM,MAAM,KAAK;AAEjB,QAAI,MAAM;AAAG,YAAM,IAAI,MAAM,6CAA6C;AAC1E,UAAM,SAAS,MAAM;AACrB,UAAM,QAAQ,KAAK,IAAG;AACtB,QAAI,SAAS,MAAM;AAAQ,YAAM,IAAI,MAAM,oCAAoC;AAC/E,aAAS,IAAI,GAAG,IAAI,QAAQ;AAAK,YAAM,UAAU,IAAI,GAAG,MAAM,CAAC,GAAGA,KAAI;EACxE;EACA,SAAM;AACJ,UAAM,EAAE,QAAQ,UAAS,IAAK;AAC9B,SAAK,WAAW,MAAM;AACtB,UAAM,MAAM,OAAO,MAAM,GAAG,SAAS;AACrC,SAAK,QAAO;AACZ,WAAO;EACT;EACA,WAAW,IAAM;AACf,WAAA,KAAO,IAAK,KAAK,YAAmB;AACpC,OAAG,IAAI,GAAG,KAAK,IAAG,CAAE;AACpB,UAAM,EAAE,UAAU,QAAQ,QAAQ,UAAU,WAAW,IAAG,IAAK;AAC/D,OAAG,YAAY;AACf,OAAG,WAAW;AACd,OAAG,SAAS;AACZ,OAAG,MAAM;AACT,QAAI,SAAS;AAAU,SAAG,OAAO,IAAI,MAAM;AAC3C,WAAO;EACT;EACA,QAAK;AACH,WAAO,KAAK,WAAU;EACxB;;AASK,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGM,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGM,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGM,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;;;AC1KD,IAAM,aAA6B,OAAO,KAAK,KAAK,CAAC;AACrD,IAAM,OAAuB,OAAO,EAAE;AAEtC,SAAS,QACP,GACA,KAAK,OAAK;AAKV,MAAI;AAAI,WAAO,EAAE,GAAG,OAAO,IAAI,UAAU,GAAG,GAAG,OAAQ,KAAK,OAAQ,UAAU,EAAC;AAC/E,SAAO,EAAE,GAAG,OAAQ,KAAK,OAAQ,UAAU,IAAI,GAAG,GAAG,OAAO,IAAI,UAAU,IAAI,EAAC;AACjF;AAEA,SAAS,MAAM,KAAe,KAAK,OAAK;AACtC,QAAM,MAAM,IAAI;AAChB,MAAI,KAAK,IAAI,YAAY,GAAG;AAC5B,MAAI,KAAK,IAAI,YAAY,GAAG;AAC5B,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,UAAM,EAAE,GAAG,EAAC,IAAK,QAAQ,IAAI,CAAC,GAAG,EAAE;AACnC,KAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;EACxB;AACA,SAAO,CAAC,IAAI,EAAE;AAChB;AAIA,IAAM,QAAQ,CAAC,GAAW,IAAY,MAAsB,MAAM;AAClE,IAAM,QAAQ,CAAC,GAAW,GAAW,MAAuB,KAAM,KAAK,IAAO,MAAM;AAEpF,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,MAAM,IAAM,KAAM,KAAK;AACpF,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,KAAM,KAAK,IAAO,MAAM;AAErF,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,KAAM,KAAK,IAAO,MAAO,IAAI;AAC1F,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,MAAO,IAAI,KAAQ,KAAM,KAAK;AAE3F,IAAM,UAAU,CAAC,IAAY,MAAsB;AACnD,IAAM,UAAU,CAAC,GAAW,OAAuB;AAUnD,SAAS,IACP,IACA,IACA,IACA,IAAU;AAKV,QAAM,KAAK,OAAO,MAAM,OAAO;AAC/B,SAAO,EAAE,GAAI,KAAK,MAAO,IAAI,KAAK,KAAM,KAAM,GAAG,GAAG,IAAI,EAAC;AAC3D;AAEA,IAAM,QAAQ,CAAC,IAAY,IAAY,QAAwB,OAAO,MAAM,OAAO,MAAM,OAAO;AAChG,IAAM,QAAQ,CAAC,KAAa,IAAY,IAAY,OACjD,KAAK,KAAK,MAAO,MAAM,KAAK,KAAM,KAAM;AAC3C,IAAM,QAAQ,CAAC,IAAY,IAAY,IAAY,QAChD,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO;AACjD,IAAM,QAAQ,CAAC,KAAa,IAAY,IAAY,IAAY,OAC7D,KAAK,KAAK,KAAK,MAAO,MAAM,KAAK,KAAM,KAAM;AAChD,IAAM,QAAQ,CAAC,IAAY,IAAY,IAAY,IAAY,QAC5D,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO;AAC9D,IAAM,QAAQ,CAAC,KAAa,IAAY,IAAY,IAAY,IAAY,OACzE,KAAK,KAAK,KAAK,KAAK,MAAO,MAAM,KAAK,KAAM,KAAM;;;ACnDrD,IAAM,SAAyB,YAAY,KAAK;EAC9C;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAED,IAAM,OAAuB,IAAI,YAAY,EAAE;AAG/C,SAAS,IAAI,GAAW,GAAW,GAAW,GAAW,KAAkB,GAAS;AAElF,QAAM,KAAK,IAAI,CAAC,GAAG,KAAK,IAAI,IAAI,CAAC;AACjC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AACzC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AACzC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AACzC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AAEzC,MAAI,KAAS,MAAM,IAAI,IAAI,EAAE;AAC7B,OAAS,MAAM,IAAI,IAAI,IAAI,EAAE;AAC7B,OAAK,KAAK;AAEV,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAI,KAAK,IAAI,IAAI,KAAK,GAAE;AACxC,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAQ,QAAQ,IAAI,EAAE,GAAG,IAAQ,QAAQ,IAAI,EAAE,EAAC;AAEhE,GAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,IAAI,IAAI,IAAI,EAAE;AAE1C,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAI,KAAK,IAAI,IAAI,KAAK,GAAE;AACxC,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE,GAAG,IAAQ,OAAO,IAAI,IAAI,EAAE,EAAC;AACtE,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACvC,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACvC,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACvC,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACzC;AAEA,SAAS,IAAI,GAAW,GAAW,GAAW,GAAW,KAAkB,GAAS;AAElF,QAAM,KAAK,IAAI,CAAC,GAAG,KAAK,IAAI,IAAI,CAAC;AACjC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AACzC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AACzC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AACzC,MAAI,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,IAAI,CAAC;AAEzC,MAAI,KAAS,MAAM,IAAI,IAAI,EAAE;AAC7B,OAAS,MAAM,IAAI,IAAI,IAAI,EAAE;AAC7B,OAAK,KAAK;AAEV,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAI,KAAK,IAAI,IAAI,KAAK,GAAE;AACxC,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE,GAAG,IAAQ,OAAO,IAAI,IAAI,EAAE,EAAC;AAEtE,GAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,IAAI,IAAI,IAAI,EAAE;AAE1C,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAI,KAAK,IAAI,IAAI,KAAK,GAAE;AACxC,GAAC,EAAE,IAAI,GAAE,IAAK,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE,GAAG,IAAQ,OAAO,IAAI,IAAI,EAAE,EAAC;AACtE,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACvC,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACvC,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACvC,EAAC,KAAK,IAAI,CAAC,IAAI,IAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACzC;AAEA,SAAS,gBACP,WACA,OAA+B,CAAA,GAC/B,QACA,SACA,SAAe;AAEf,EAAAG,SAAQ,MAAM;AACd,MAAI,YAAY,KAAK,YAAY;AAAQ,UAAM,IAAI,MAAM,8BAA8B;AACvF,QAAM,EAAE,KAAK,MAAM,gBAAe,IAAK;AACvC,MAAI,QAAQ,WAAc,IAAI,SAAS,KAAK,IAAI,SAAS;AACvD,UAAM,IAAI,MAAM,wCAAwC,MAAM;AAChE,MAAI,SAAS,UAAa,KAAK,WAAW;AACxC,UAAM,IAAI,MAAM,+BAA+B,OAAO;AACxD,MAAI,oBAAoB,UAAa,gBAAgB,WAAW;AAC9D,UAAM,IAAI,MAAM,0CAA0C,OAAO;AACrE;AAGM,IAAgB,SAAhB,cAAoD,KAAO;EAc/D,YAAY,UAAkB,WAAiB;AAC7C,UAAK;AARG,SAAA,WAAW;AACX,SAAA,YAAY;AACZ,SAAA,SAAiB;AACjB,SAAA,MAAc;AAMtB,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,SAAS;AACjB,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,SAAS,IAAI,WAAW,QAAQ;AACrC,SAAK,WAAW,IAAI,KAAK,MAAM;EACjC;EACA,OAAO,MAAW;AAChB,YAAQ,IAAI;AACZ,WAAO,QAAQ,IAAI;AACnB,IAAAC,QAAO,IAAI;AAKX,UAAM,EAAE,UAAU,QAAQ,SAAQ,IAAK;AACvC,UAAM,MAAM,KAAK;AACjB,UAAM,SAAS,KAAK;AACpB,UAAM,MAAM,KAAK;AACjB,aAAS,MAAM,GAAG,MAAM,OAAO;AAE7B,UAAI,KAAK,QAAQ,UAAU;AACzB,mBAAW,QAAQ;AACnB,aAAK,SAAS,UAAU,GAAG,KAAK;AAChC,mBAAW,QAAQ;AACnB,aAAK,MAAM;MACb;AACA,YAAM,OAAO,KAAK,IAAI,WAAW,KAAK,KAAK,MAAM,GAAG;AACpD,YAAM,aAAa,SAAS;AAE5B,UAAI,SAAS,YAAY,EAAE,aAAa,MAAM,MAAM,OAAO,KAAK;AAC9D,cAAM,SAAS,IAAI,YAAY,KAAK,YAAY,KAAK,OAAO,MAAM,OAAO,CAAC,CAAC;AAC3E,mBAAW,MAAM;AACjB,iBAAS,QAAQ,GAAG,MAAM,WAAW,KAAK,SAAS,SAAS,QAAQ,OAAO,UAAU;AACnF,eAAK,UAAU;AACf,eAAK,SAAS,QAAQ,OAAO,KAAK;QACpC;AACA,mBAAW,MAAM;AACjB;MACF;AACA,aAAO,IAAI,KAAK,SAAS,KAAK,MAAM,IAAI,GAAG,KAAK,GAAG;AACnD,WAAK,OAAO;AACZ,WAAK,UAAU;AACf,aAAO;IACT;AACA,WAAO;EACT;EACA,WAAW,KAAe;AACxB,YAAQ,IAAI;AACZ,YAAQ,KAAK,IAAI;AACjB,UAAM,EAAE,KAAK,SAAQ,IAAK;AAC1B,SAAK,WAAW;AAEhB,UAAM,KAAK,OAAO,SAAS,GAAG,CAAC;AAC/B,eAAW,QAAQ;AACnB,SAAK,SAAS,UAAU,GAAG,IAAI;AAC/B,eAAW,QAAQ;AACnB,UAAM,QAAQ,IAAI,GAAG;AACrB,SAAK,IAAG,EAAG,QAAQ,CAAC,GAAG,MAAO,MAAM,CAAC,IAAI,UAAU,CAAC,CAAE;EACxD;EACA,SAAM;AACJ,UAAM,EAAE,QAAQ,UAAS,IAAK;AAC9B,SAAK,WAAW,MAAM;AACtB,UAAM,MAAM,OAAO,MAAM,GAAG,SAAS;AACrC,SAAK,QAAO;AACZ,WAAO;EACT;EACA,WAAW,IAAM;AACf,UAAM,EAAE,QAAQ,QAAQ,UAAU,WAAW,WAAW,IAAG,IAAK;AAChE,WAAA,KAAO,IAAK,KAAK,YAAoB,EAAE,OAAO,UAAS,CAAE;AACzD,OAAG,IAAI,GAAG,KAAK,IAAG,CAAE;AACpB,OAAG,OAAO,IAAI,MAAM;AACpB,OAAG,YAAY;AACf,OAAG,WAAW;AACd,OAAG,SAAS;AACZ,OAAG,MAAM;AAET,OAAG,YAAY;AACf,WAAO;EACT;EACA,QAAK;AACH,WAAO,KAAK,WAAU;EACxB;;AAGI,IAAO,UAAP,cAAuB,OAAe;EAmB1C,YAAY,OAAmB,CAAA,GAAE;AAC/B,UAAM,OAAO,KAAK,UAAU,SAAY,KAAK,KAAK;AAClD,UAAM,KAAK,IAAI;AAnBT,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,CAAC,IAAI;AAClB,SAAA,MAAM,OAAO,EAAE,IAAI;AACnB,SAAA,MAAM,OAAO,EAAE,IAAI;AACnB,SAAA,MAAM,OAAO,EAAE,IAAI;AACnB,SAAA,MAAM,OAAO,EAAE,IAAI;AACnB,SAAA,MAAM,OAAO,EAAE,IAAI;AACnB,SAAA,MAAM,OAAO,EAAE,IAAI;AAKzB,oBAAgB,MAAM,MAAM,IAAI,IAAI,EAAE;AACtC,QAAI,EAAE,KAAK,iBAAiB,KAAI,IAAK;AACrC,QAAI,YAAY;AAChB,QAAI,QAAQ,QAAW;AACrB,YAAM,QAAQ,GAAG;AACjB,kBAAY,IAAI;IAClB;AACA,SAAK,OAAO,KAAK,YAAa,aAAa,IAAM,KAAQ,KAAO,KAAQ;AACxE,QAAI,SAAS,QAAW;AACtB,aAAO,QAAQ,IAAI;AACnB,YAAM,MAAM,IAAI,IAAI;AACpB,WAAK,OAAO,UAAU,IAAI,CAAC,CAAC;AAC5B,WAAK,OAAO,UAAU,IAAI,CAAC,CAAC;AAC5B,WAAK,OAAO,UAAU,IAAI,CAAC,CAAC;AAC5B,WAAK,OAAO,UAAU,IAAI,CAAC,CAAC;IAC9B;AACA,QAAI,oBAAoB,QAAW;AACjC,wBAAkB,QAAQ,eAAe;AACzC,YAAM,OAAO,IAAI,eAAe;AAChC,WAAK,OAAO,UAAU,KAAK,CAAC,CAAC;AAC7B,WAAK,OAAO,UAAU,KAAK,CAAC,CAAC;AAC7B,WAAK,OAAO,UAAU,KAAK,CAAC,CAAC;AAC7B,WAAK,OAAO,UAAU,KAAK,CAAC,CAAC;IAC/B;AACA,QAAI,QAAQ,QAAW;AAErB,YAAM,MAAM,IAAI,WAAW,KAAK,QAAQ;AACxC,UAAI,IAAI,GAAG;AACX,WAAK,OAAO,GAAG;IACjB;EACF;;EAEU,MAAG;AAIX,QAAI,EAAE,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,IAAG,IAAK;AACzF,WAAO,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;EACxF;;EAEU,IACR,KAAa,KAAa,KAAa,KACvC,KAAa,KAAa,KAAa,KACvC,KAAa,KAAa,KAAa,KACvC,KAAa,KAAa,KAAa,KAAW;AAElD,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;EACnB;EACU,SAAS,KAAkB,QAAgB,QAAe;AAClE,SAAK,IAAG,EAAG,QAAQ,CAAC,GAAG,MAAO,KAAK,CAAC,IAAI,CAAE;AAC1C,SAAK,IAAI,QAAQ,EAAE;AACnB,QAAI,EAAE,GAAG,EAAC,IAAS,QAAQ,OAAO,KAAK,MAAM,CAAC;AAC9C,SAAK,EAAE,IAAI,OAAO,CAAC,IAAI;AACvB,SAAK,EAAE,IAAI,OAAO,CAAC,IAAI;AAEvB,QAAI,QAAQ;AACV,WAAK,EAAE,IAAI,CAAC,KAAK,EAAE;AACnB,WAAK,EAAE,IAAI,CAAC,KAAK,EAAE;IACrB;AACA,QAAI,IAAI;AACR,UAAM,IAAI;AACV,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AACzC,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AACzC,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AACzC,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AACzC,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAC1C,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAC1C,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAC1C,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAE1C,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAC1C,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAC1C,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAC1C,UAAI,GAAG,GAAG,IAAI,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AAC1C,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AACzC,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AACzC,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;AACzC,UAAI,GAAG,GAAG,GAAG,IAAI,KAAK,SAAS,IAAI,EAAE,GAAG,CAAC;IAC3C;AACA,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,CAAC,IAAI,KAAK,EAAE;AAC7B,SAAK,OAAO,KAAK,EAAE,IAAI,KAAK,EAAE;AAC9B,SAAK,OAAO,KAAK,EAAE,IAAI,KAAK,EAAE;AAC9B,SAAK,OAAO,KAAK,EAAE,IAAI,KAAK,EAAE;AAC9B,SAAK,OAAO,KAAK,EAAE,IAAI,KAAK,EAAE;AAC9B,SAAK,OAAO,KAAK,EAAE,IAAI,KAAK,EAAE;AAC9B,SAAK,OAAO,KAAK,EAAE,IAAI,KAAK,EAAE;AAC9B,UAAM,IAAI;EACZ;EACA,UAAO;AACL,SAAK,YAAY;AACjB,UAAM,KAAK,QAAQ;AACnB,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;EACzD;;AAQK,IAAM,UAAkC,gBAC7C,CAAC,SAAS,IAAI,QAAQ,IAAI,CAAC;AAgBvB,SAAU,SAAS,GAAe,QAAgB,KAAkB,QACxE,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IACpF,IAAY,IAAY,KAAa,KAAa,KAAa,KAAa,KAAa,KAAW;AAEpG,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC5E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC5E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC5E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC5E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAE9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC9E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC5E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC5E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;AAC5E,KAAC,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG,IAAK,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,SAAS,EAAE,GAAG,CAAC,CAAC;EAC9E;AACA,SAAO,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,IAAG;AAC/E;AAEA,IAAM,SAAS;AACT,IAAO,UAAP,cAAuB,OAAe;EAW1C,YAAY,OAAmB,CAAA,GAAE;AAC/B,UAAM,OAAO,KAAK,UAAU,SAAY,KAAK,KAAK;AAClD,UAAM,IAAI,IAAI;AAXR,SAAA,KAAK,OAAO,CAAC,IAAI;AACjB,SAAA,KAAK,OAAO,CAAC,IAAI;AACjB,SAAA,KAAK,OAAO,CAAC,IAAI;AACjB,SAAA,KAAK,OAAO,CAAC,IAAI;AACjB,SAAA,KAAK,OAAO,CAAC,IAAI;AACjB,SAAA,KAAK,OAAO,CAAC,IAAI;AACjB,SAAA,KAAK,OAAO,CAAC,IAAI;AACjB,SAAA,KAAK,OAAO,CAAC,IAAI;AAKvB,oBAAgB,MAAM,MAAM,IAAI,GAAG,CAAC;AACpC,QAAI,EAAE,KAAK,iBAAiB,KAAI,IAAK;AACrC,QAAI,YAAY;AAChB,QAAI,QAAQ,QAAW;AACrB,YAAM,QAAQ,GAAG;AACjB,kBAAY,IAAI;IAClB;AACA,SAAK,MAAM,KAAK,YAAa,aAAa,IAAM,KAAQ,KAAO,KAAQ;AACvE,QAAI,SAAS,QAAW;AACtB,aAAO,QAAQ,IAAI;AACnB,YAAM,MAAM,IAAI,IAAkB;AAClC,WAAK,MAAM,UAAU,IAAI,CAAC,CAAC;AAC3B,WAAK,MAAM,UAAU,IAAI,CAAC,CAAC;IAC7B;AACA,QAAI,oBAAoB,QAAW;AACjC,wBAAkB,QAAQ,eAAe;AACzC,YAAM,OAAO,IAAI,eAA6B;AAC9C,WAAK,MAAM,UAAU,KAAK,CAAC,CAAC;AAC5B,WAAK,MAAM,UAAU,KAAK,CAAC,CAAC;IAC9B;AACA,QAAI,QAAQ,QAAW;AAErB,MAAAA,QAAO,GAAG;AACV,YAAM,MAAM,IAAI,WAAW,KAAK,QAAQ;AACxC,UAAI,IAAI,GAAG;AACX,WAAK,OAAO,GAAG;IACjB;EACF;EACU,MAAG;AACX,UAAM,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAE,IAAK;AAC3C,WAAO,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;EACxC;;EAEU,IACR,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IAAU;AAE9F,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;EACjB;EACU,SAAS,KAAkB,QAAgB,QAAe;AAClE,UAAM,EAAE,GAAG,EAAC,IAAS,QAAQ,OAAO,KAAK,MAAM,CAAC;AAEhD,UAAM,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,IAAG,IAC1E,SACE,QAAQ,QAAQ,KAAK,IACrB,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IACpE,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAExH,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,KAAK;EAClB;EACA,UAAO;AACL,SAAK,YAAY;AACjB,UAAM,KAAK,QAAQ;AACnB,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;EACjC;;AAQK,IAAM,UAAkC,gBAC7C,CAAC,SAAS,IAAI,QAAQ,IAAI,CAAC;;;AC3dtB,IAAMC,WAAsB;;;ACDnC,IAAM,eAAe;AACrB,IAAM,eAAe;AAEd,IAAM,oBAAN,MAAM,mBAAkB;EAC9B,OAAO,aAAa,KAAa,mBAAmB,OAAgB;AACnE,QAAI,QAAQ,WAAW;AACtB,aAAO,EAAE,SAAS,KAAK;IACxB,WAAW,QAAQ,QAAQ;AAC1B,aAAO,EAAE,MAAM,KAAK;IACrB,WAAW,QAAQ,MAAM;AACxB,aAAO,EAAE,IAAI,KAAK;IACnB,WAAW,QAAQ,OAAO;AACzB,aAAO,EAAE,KAAK,KAAK;IACpB,WAAW,QAAQ,OAAO;AACzB,aAAO,EAAE,KAAK,KAAK;IACpB,WAAW,QAAQ,OAAO;AACzB,aAAO,EAAE,KAAK,KAAK;IACpB,WAAW,QAAQ,QAAQ;AAC1B,aAAO,EAAE,MAAM,KAAK;IACrB,WAAW,QAAQ,QAAQ;AAC1B,aAAO,EAAE,MAAM,KAAK;IACrB,WAAW,QAAQ,UAAU;AAC5B,aAAO,EAAE,QAAQ,KAAK;IACvB;AAEA,UAAM,cAAc,IAAI,MAAM,YAAY;AAC1C,QAAI,aAAa;AAChB,aAAO;QACN,QAAQ,mBAAkB,aAAa,YAAY,CAAC,GAAG,gBAAgB;MACxE;IACD;AAEA,UAAM,cAAc,IAAI,MAAM,YAAY;AAC1C,QAAI,aAAa;AAChB,YAAM,UAAU,mBAAmB,oBAAoB,YAAY,CAAC,CAAC,IAAI,YAAY,CAAC;AACtF,aAAO;QACN,QAAQ;UACP;UACA,QAAQ,YAAY,CAAC;UACrB,MAAM,YAAY,CAAC;UACnB,YACC,YAAY,CAAC,MAAM,SAChB,CAAC,IACD,mBAAkB,oBAAoB,YAAY,CAAC,GAAG,gBAAgB;QAC3E;MACD;IACD;AAEA,UAAM,IAAI,MAAM,2DAA2D,GAAG,EAAE;EACjF;EAEA,OAAO,oBAAoB,KAAa,mBAAmB,OAAkB;AAC5E,WAAO,uBAAuB,GAAG,EAAE;MAAI,CAAC,QACvC,mBAAkB,aAAa,KAAK,gBAAgB;IACrD;EACD;EAEA,OAAO,YAAY,KAAsB;AACxC,QAAI,UAAU,KAAK;AAClB,aAAO;IACR;AACA,QAAI,QAAQ,KAAK;AAChB,aAAO;IACR;AACA,QAAI,SAAS,KAAK;AACjB,aAAO;IACR;AACA,QAAI,SAAS,KAAK;AACjB,aAAO;IACR;AACA,QAAI,SAAS,KAAK;AACjB,aAAO;IACR;AACA,QAAI,UAAU,KAAK;AAClB,aAAO;IACR;AACA,QAAI,UAAU,KAAK;AAClB,aAAO;IACR;AACA,QAAI,aAAa,KAAK;AACrB,aAAO;IACR;AACA,QAAI,YAAY,KAAK;AACpB,aAAO;IACR;AACA,QAAI,YAAY,KAAK;AACpB,aAAO,UAAU,mBAAkB,YAAY,IAAI,MAAM,CAAC;IAC3D;AACA,QAAI,YAAY,KAAK;AACpB,YAAM,SAAS,IAAI;AACnB,YAAM,aAAa,OAAO,WAAW,IAAI,mBAAkB,WAAW,EAAE,KAAK,IAAI;AACjF,aAAO,GAAG,OAAO,OAAO,KAAK,OAAO,MAAM,KAAK,OAAO,IAAI,GACzD,aAAa,IAAI,UAAU,MAAM,EAClC;IACD;AACA,UAAM,IAAI,MAAM,iBAAiB;EAClC;AACD;;;AC/FA,SAAS,WAAW,SAAkC;AACrD,SAAO,IACL,IAAI;IACJ,MAAM;IACN,GAAI;EACL,CAAC,EACA,UAAU;IACV,OAAO,CAAC,QAAyB;IACjC,QAAQ,CAAC,QAAQ,OAAO,GAAG;EAC5B,CAAC;AACH;AAEA,SAAS,WAAwC,MAAS;AACzD,SAAO,IAAI,KAAK,UAAU;IACzB,MAAM;IACN,MAAM;EACP,CAAC;AACF;AAEO,IAAM,UAAU,IAAI,MAAM,kBAAkB,EAAE,UAAU;EAC9D,UAAU,CAAC,QAAQ;AAClB,UAAM,UAAU,OAAO,QAAQ,WAAW,MAAM,MAAM,GAAG;AACzD,QAAI,CAAC,WAAW,CAAC,kBAAkB,oBAAoB,OAAO,CAAC,GAAG;AACjE,YAAM,IAAI,MAAM,uBAAuB,OAAO,EAAE;IACjD;EACD;EACA,OAAO,CAAC,QACP,OAAO,QAAQ,WAAW,QAAQ,oBAAoB,GAAG,CAAC,IAAI;EAC/D,QAAQ,CAAC,QAAQ,oBAAoB,MAAM,GAAG,CAAC;AAChD,CAAC;AAEM,IAAM,eAAe,IAAI,WAAW,EAAE,UAAU;EACtD,MAAM;EACN,OAAO,CAAC,UAAkB,WAAW,KAAK;EAC1C,QAAQ,CAAC,UAAU,SAAS,IAAI,WAAW,KAAK,CAAC;EACjD,UAAU,CAAC,UAAU;AACpB,QAAI,WAAW,KAAK,EAAE,WAAW,IAAI;AACpC,YAAM,IAAI,MAAM,+BAA+B;IAChD;EACD;AACD,CAAC;AAEM,IAAM,eAAe,IAAI,OAAO,gBAAgB;EACtD,UAAU;EACV,SAAS,IAAI,IAAI;EACjB,QAAQ;AACT,CAAC;AAEM,IAAM,kBAAkB,IAAI,OAAO,mBAAmB;EAC5D,UAAU;EACV,sBAAsB,IAAI,IAAI;EAC9B,SAAS,IAAI,KAAK;AACnB,CAAC;AAEM,IAAM,YAAY,IAAI,KAAK,aAAa;EAC9C,kBAAkB;EAClB,cAAc;EACd,WAAW;AACZ,CAAC;AAEM,IAAM,QAAQ,IAAI,KAAK,SAAS;EACtC,cAAc;EACd,aAAa;EACb,QAAQ,IAAI,OAAO,UAAU;IAC5B,sBAAsB,IAAI,IAAI;EAC/B,CAAC;EACD,WAAW;EACX,uBAAuB,IAAI,OAAO,yBAAyB;IAC1D,OAAO;IACP,cAAc,IAAI,IAAI;EACvB,CAAC;AACF,CAAC;AAEM,IAAM,UAAU,IAAI,KAAK,WAAW;EAC1C,MAAM,IAAI,OAAO,QAAQ;IACxB,OAAO,IAAI,WAAW,EAAE,UAAU;MACjC,OAAO,CAAC,QAA8B,OAAO,QAAQ,WAAW,WAAW,GAAG,IAAI;MAClF,QAAQ,CAAC,QAAQ,SAAS,IAAI,WAAW,GAAG,CAAC;IAC9C,CAAC;EACF,CAAC;EACD,QAAQ;AACT,CAAC;AAED,IAAM,eAAkD,IAAI,KAAK,WAAW;EAC3E,MAAM;EACN,IAAI;EACJ,KAAK;EACL,MAAM;EACN,SAAS;EACT,QAAQ;EACR,QAAQ,IAAI,KAAK,MAAM,YAAY;EACnC,QAAQ,IAAI,KAAK,MAAM,SAAS;EAChC,KAAK;EACL,KAAK;EACL,MAAM;AACP,CAAC;AAEM,IAAM,UAAU,aAAa,UAAU;EAC7C,OAAO,CAAC,YACP,OAAO,YAAY,WAAW,kBAAkB,aAAa,SAAS,IAAI,IAAI;EAC/E,QAAQ,CAAC,YAAyB,kBAAkB,YAAY,OAAO;AACxE,CAAC;AAEM,IAAM,WAAW,IAAI,KAAK,YAAY;EAC5C,SAAS;EACT,OAAO,IAAI,IAAI;EACf,QAAQ,IAAI,IAAI;EAChB,cAAc,IAAI,MAAM,CAAC,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,CAAC;AAC/C,CAAC;AAEM,IAAM,uBAAuB,IAAI,OAAO,wBAAwB;EACtE,SAAS;EACT,QAAQ,IAAI,OAAO;EACnB,UAAU,IAAI,OAAO;EACrB,eAAe,IAAI,OAAO,OAAO;EACjC,WAAW,IAAI,OAAO,QAAQ;AAC/B,CAAC;AAEM,IAAM,UAAU,IAAI,KAAK,WAAW;;;;;;EAM1C,UAAU;;;;EAIV,iBAAiB,IAAI,OAAO,mBAAmB;IAC9C,SAAS,IAAI,OAAO,QAAQ;IAC5B,SAAS;EACV,CAAC;;;;EAID,YAAY,IAAI,OAAO,cAAc;IACpC,MAAM;IACN,SAAS,IAAI,OAAO,QAAQ;EAC7B,CAAC;;;;EAID,YAAY,IAAI,OAAO,cAAc;IACpC,aAAa;IACb,SAAS,IAAI,OAAO,QAAQ;EAC7B,CAAC;;;;EAID,SAAS,IAAI,OAAO,WAAW;IAC9B,SAAS,IAAI;MACZ,IAAI,WAAW,EAAE,UAAU;QAC1B,OAAO,CAAC,QAA8B,OAAO,QAAQ,WAAW,WAAW,GAAG,IAAI;QAClF,QAAQ,CAAC,QAAQ,SAAS,IAAI,WAAW,GAAG,CAAC;MAC9C,CAAC;IACF;IACA,cAAc,IAAI,OAAO,OAAO;EACjC,CAAC;;;;;;EAMD,aAAa,IAAI,OAAO,eAAe;IACtC,MAAM,WAAW,OAAO,EAAE,UAAU;MACnC,OAAO,CAAC,QACP,QAAQ,OACL;QACA,MAAM;MACP,IACC;QACA,MAAM;MACP;MACH,QAAQ,CAAC,QAAQ,IAAI,QAAQ;IAC9B,CAAC;IACD,UAAU,IAAI,OAAO,QAAQ;EAC9B,CAAC;EACD,SAAS,IAAI,OAAO,WAAW;IAC9B,SAAS,IAAI;MACZ,IAAI,WAAW,EAAE,UAAU;QAC1B,OAAO,CAAC,QAA8B,OAAO,QAAQ,WAAW,WAAW,GAAG,IAAI;QAClF,QAAQ,CAAC,QAAQ,SAAS,IAAI,WAAW,GAAG,CAAC;MAC9C,CAAC;IACF;IACA,cAAc,IAAI,OAAO,OAAO;IAChC,SAAS;IACT,QAAQ;EACT,CAAC;AACF,CAAC;AAEM,IAAM,0BAA0B,IAAI,OAAO,2BAA2B;EAC5E,QAAQ,IAAI,OAAO,OAAO;EAC1B,UAAU,IAAI,OAAO,OAAO;AAC7B,CAAC;AAEM,IAAM,kBAAkB,IAAI,KAAK,mBAAmB;EAC1D;EACA,aAAa;EACb,SAAS;EACT,yBAAyB;AAC1B,CAAC;AAEM,IAAM,wBAAwB,IAAI,KAAK,yBAAyB;EACtE,MAAM;EACN,OAAO,WAAW;AACnB,CAAC;AAEM,IAAM,YAAY,IAAI,OAAO,aAAa;EAChD,SAAS;EACT,QAAQ,IAAI,OAAO;EACnB,MAAM,IAAI,OAAO;EACjB,YAAY,IAAI,OAAO,YAAY;AACpC,CAAC;AAEM,IAAM,UAAU,IAAI,OAAO,WAAW;EAC5C,SAAS,IAAI,OAAO,YAAY;EAChC,OAAO;EACP,OAAO,IAAI,IAAI;EACf,QAAQ,IAAI,IAAI;AACjB,CAAC;AAEM,IAAM,oBAAoB,IAAI,OAAO,qBAAqB;EAChE,MAAM;EACN,QAAQ;EACR,SAAS;EACT,YAAY;AACb,CAAC;AAEM,IAAM,kBAAkB,IAAI,KAAK,mBAAmB;EAC1D,IAAI;AACL,CAAC;AAEM,IAAM,cAAc,IAAI,KAAK,eAAe;EAClD,iBAAiB;EACjB,oBAAoB;EACpB,mBAAmB;EACnB,iBAAiB;AAClB,CAAC;AAEM,IAAM,gBAAgB,IAAI,KAAK,iBAAiB;EACtD,IAAI;AACL,CAAC;AAEM,IAAM,QAAQ,IAAI,KAAK,SAAS;EACtC,KAAK;AACN,CAAC;AAEM,IAAM,SAAS,IAAI,OAAO,UAAU;EAC1C,OAAO;EACP,SAAS;EACT,OAAO;AACR,CAAC;AAEM,SAAS,cAAsC,GAAM;AAC3D,SAAO,IAAI,OAAO,iBAAiB,EAAE,IAAI,KAAK;IAC7C,QAAQ;IACR,OAAO;EACR,CAAC;AACF;AAEO,IAAM,sBAAsB,IAAI,KAAK,uBAAuB;EAClE,SAAS,IAAI,MAAM,EAAE;EACrB,WAAW,IAAI,MAAM,EAAE;EACvB,WAAW,IAAI,MAAM,EAAE;EACvB,SAAS,IAAI,WAAW;EACxB,SAAS,IAAI,WAAW;AACzB,CAAC;AAEM,IAAM,YAAY,IAAI,KAAK,aAAa;EAC9C,SAAS,IAAI,MAAM,EAAE;EACrB,WAAW,IAAI,MAAM,EAAE;EACvB,WAAW,IAAI,MAAM,EAAE;EACvB,SAAS,IAAI,WAAW;EACxB,SAAS,IAAI,MAAM,EAAE;AACtB,CAAC;AAEM,IAAM,gBAAgB,IAAI,OAAO,iBAAiB;EACxD,QAAQ;EACR,QAAQ,IAAI,GAAG;AAChB,CAAC;AAEM,IAAM,oBAAoB,IAAI,OAAO,qBAAqB;EAChE,QAAQ,IAAI,OAAO,aAAa;EAChC,WAAW,IAAI,IAAI;AACpB,CAAC;AAEM,IAAM,WAAW,IAAI,OAAO,YAAY;EAC9C,MAAM,IAAI,OAAO,mBAAmB;EACpC,QAAQ,IAAI,IAAI;EAChB,aAAa;AACd,CAAC;AAEM,IAAM,eAAe,IAAI,WAAW,EAAE,UAAU;EACtD,OAAO,CAAC,QAA8B,OAAO,QAAQ,WAAW,WAAW,GAAG,IAAI;EAClF,QAAQ,CAAC,QAAQ,SAAS,IAAI,WAAW,GAAG,CAAC;AAC9C,CAAC;AAEM,IAAM,0BAA0B,IAAI,OAAO,2BAA2B;EAC5E,eAAe,cAAc,eAAe;EAC5C,cAAc,IAAI,OAAO,YAAY;AACtC,CAAC;AAEM,IAAM,mBAAmB,IAAI,OAAO,yBAAyB;EACnE,MAAM;AACP,CAAC;AAEM,IAAM,uBAAuB,IAAI,OAAO,wBAAwB;EACtE,mBAAmB,IAAI,WAAW;EAClC,gBAAgB,IAAI,OAAO;EAC3B,eAAe,IAAI,WAAW;AAC/B,CAAC;;;ACzTD,IAAM,sBAAsB,IAAI,KAAK,uBAAuB;EAC3D,sBAAsB,IAAI,OAAO,wBAAwB,EAAE,WAAW,QAAQ,CAAC;EAC/E,aAAa,IAAI,OAAO,eAAe,EAAE,UAAU,QAAQ,CAAC;EAC5D,qBAAqB;EACrB,oBAAoB,IAAI,OAAO,sBAAsB,EAAE,QAAQ,IAAI,WAAW,EAAE,CAAC;EACjF,sBAAsB,IAAI,OAAO,wBAAwB,EAAE,QAAQ,IAAI,GAAG,EAAE,CAAC;EAC7E,uBAAuB,IAAI,OAAO,yBAAyB;IAC1D,WAAW;IACX,UAAU;EACX,CAAC;AACF,CAAC;AAED,IAAM,WAAW,IAAI,OAAO,YAAY;EACvC,SAAS;EACT,MAAM,IAAI,OAAO;AAClB,CAAC;AACD,IAAM,eAAe,IAAI,OAAO,gBAAgB;EAC/C,QAAQ;EACR,UAAU,IAAI,IAAI;EAClB,aAAa,IAAI,IAAI;EACrB,cAAc,IAAI,OAAO,IAAI,OAAO,CAAC;AACtC,CAAC;AAED,IAAM,uBAAuB,IAAI,KAAK,wBAAwB;EAC7D,cAAc;EACd,iBAAiB;EACjB,uBAAuB;EACvB,uCAAuC;EACvC,kBAAkB,IAAI,OAAO,oBAAoB,EAAE,KAAK,IAAI,IAAI,EAAE,CAAC;EACnE,2BAA2B,IAAI,OAAO,6BAA6B;IAClE,WAAW,IAAI,IAAI;IACnB,cAAc,IAAI,IAAI;EACvB,CAAC;EACD,oBAAoB,IAAI,OAAO,sBAAsB,EAAE,WAAW,IAAI,IAAI,EAAE,CAAC;EAC7E,qBAAqB;EACrB,mBAAmB;EACnB,sBAAsB;EACtB,uBAAuB;EACvB,iCAAiC;AAClC,CAAC;AAED,IAAM,oBAAoB,IAAI,KAAK,qBAAqB;EACvD,cAAc;EACd,wBAAwB;AACzB,CAAC;AAED,IAAM,yBAAyB,IAAI,KAAK,0BAA0B;EACjE,iBAAiB;EACjB,kBAAkB;EAClB,oBAAoB;EACpB,wBAAwB;EACxB,kBAAkB,IAAI,OAAO,oBAAoB;IAChD,YAAY,IAAI,IAAI;IACpB,eAAe,IAAI,IAAI;EACxB,CAAC;EACD,mBAAmB,IAAI,OAAO,qBAAqB;IAClD,YAAY,IAAI,IAAI;IACpB,eAAe,IAAI,IAAI;EACxB,CAAC;EACD,yBAAyB,IAAI,OAAO,2BAA2B,EAAE,QAAQ,QAAQ,CAAC;EAClF,yBAAyB;EACzB,qBAAqB;EACrB,4BAA4B;EAC5B,0BAA0B;EAC1B,2BAA2B,IAAI,OAAO,YAAY;EAClD,WAAW,IAAI,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,CAAC;EAC9C,sCAAsC;EACtC,sBAAsB;EACtB,kBAAkB;EAClB,eAAe;EACf,mBAAmB;EACnB,yBAAyB;EACzB,sBAAsB,IAAI,OAAO,wBAAwB;IACxD,QAAQ,IAAI,IAAI;IAChB,MAAM;EACP,CAAC;EACD,mBAAmB,IAAI,OAAO,qBAAqB;IAClD,aAAa,IAAI,IAAI;IACrB,MAAM;EACP,CAAC;EACD,wBAAwB,IAAI,OAAO,0BAA0B;IAC5D,WAAW,IAAI,IAAI;IACnB,cAAc,IAAI,IAAI;EACvB,CAAC;EACD,iCAAiC,IAAI,OAAO,mCAAmC;IAC9E,KAAK,IAAI,IAAI;EACd,CAAC;EACD,uBAAuB;EACvB,iBAAiB,IAAI,OAAO,mBAAmB,EAAE,aAAa,IAAI,IAAI,GAAG,SAAS,IAAI,IAAI,EAAE,CAAC;EAC7F,iCAAiC;EACjC,mCAAmC;EACnC,qBAAqB,IAAI,OAAO,uBAAuB,EAAE,cAAc,oBAAoB,CAAC;EAC5F,wBAAwB,IAAI,OAAO,0BAA0B;IAC5D,aAAa,IAAI,IAAI;IACrB,SAAS,IAAI,IAAI;EAClB,CAAC;EACD,mBAAmB;EACnB,6BAA6B;EAC7B,iCAAiC;EACjC,oBAAoB;EACpB,+CAA+C,IAAI;IAClD;IACA;MACC,kBAAkB,IAAI,OAAO,OAAO;IACrC;EACD;EACA,sBAAsB,IAAI,OAAO,wBAAwB;IACxD,SAAS;IACT,UAAU,IAAI,OAAO;EACtB,CAAC;EACD,qBAAqB,IAAI,OAAO,uBAAuB,EAAE,UAAU,IAAI,OAAO,EAAE,CAAC;EACjF,8CAA8C;AAC/C,CAAC;AAED,IAAM,kBAAkB,IAAI,KAAK,mBAAmB;EACnD,SAAS;EACT,QAAQ,IAAI,OAAO,mBAAmB;IACrC,OAAO;IACP,SAAS,IAAI,OAAO,IAAI,IAAI,CAAC;EAC9B,CAAC;AACF,CAAC;AAED,IAAM,iBAAiB,IAAI,OAAO,kBAAkB;EACnD,iBAAiB,IAAI,IAAI;EACzB,aAAa,IAAI,IAAI;EACrB,eAAe,IAAI,IAAI;EACvB,yBAAyB,IAAI,IAAI;AAClC,CAAC;AAED,IAAM,uBAAuB,IAAI,OAAO,wBAAwB;EAC/D,QAAQ;EACR,eAAe,IAAI,IAAI;EACvB,SAAS;EACT,oBAAoB,IAAI,OAAO,IAAI,MAAM,CAAC,SAAS,IAAI,IAAI,CAAC,CAAC,CAAC;EAC9D,eAAe,IAAI,OAAO,YAAY;EACtC,mBAAmB;EACnB,SAAS,IAAI,OAAO,IAAI,MAAM,CAAC,cAAc,KAAK,CAAC,CAAC;EACpD,SAAS,IAAI,OAAO,IAAI,MAAM,CAAC,cAAc,KAAK,CAAC,CAAC;EACpD,WAAW,IAAI,OAAO,IAAI,MAAM,CAAC,cAAc,KAAK,CAAC,CAAC;EACtD,SAAS,IAAI,OAAO,YAAY;EAChC,sBAAsB,IAAI,OAAO,YAAY;EAC7C,SAAS,IAAI,OAAO,YAAY;EAChC,WAAW,IAAI,MAAM,CAAC,cAAc,KAAK,CAAC;EAC1C,cAAc,IAAI,OAAO,YAAY;EACrC,cAAc,IAAI,OAAO,YAAY;AACtC,CAAC;AAED,IAAM,gBAAgB,IAAI,MAAM,CAAC,IAAI,IAAI,GAAG,YAAY,CAAC;AAEzD,IAAM,WAAW,IAAI,KAAK,YAAY;EACrC,UAAU;EACV,OAAO,IAAI,MAAM,CAAC,eAAe,KAAK,CAAC;AACxC,CAAC;AAED,IAAM,YAAY,IAAI,KAAK,aAAa;EACvC,UAAU;EACV,aAAa,IAAI,MAAM,CAAC,cAAc,KAAK,CAAC;EAC5C,cAAc;AACf,CAAC;AAED,IAAM,cAAc,IAAI,KAAK,eAAe;EAC3C,MAAM;EACN,SAAS;EACT,SAAS;AACV,CAAC;AAED,IAAM,sBAAsB,IAAI,OAAO,uBAAuB;EAC7D,YAAY;EACZ,aAAa;EACb,aAAa;AACd,CAAC;AAED,IAAM,sBAAsB,IAAI,KAAK,uBAAuB;EAC3D,cAAc;;EAEd,eAAe,IAAI,IAAI;EACvB,aAAa,IAAI,IAAI;EACrB,WAAW,IAAI,IAAI;EACnB,gBAAgB;AACjB,CAAC;AAED,IAAM,uBAAuB,IAAI,OAAO,wBAAwB;EAC/D,QAAQ;EACR,eAAe,IAAI,IAAI;EACvB,SAAS;EACT,mBAAmB;EACnB,gBAAgB,IAAI,OAAO,IAAI,IAAI,CAAC;EACpC,cAAc,IAAI,OAAO,YAAY;EACrC,cAAc,IAAI,OAAO,YAAY;EACrC,gBAAgB,IAAI,IAAI;EACxB,gBAAgB,IAAI,OAAO,IAAI,MAAM,CAAC,SAAS,mBAAmB,CAAC,CAAC;EACpE,wBAAwB,IAAI,OAAO,IAAI,MAAM,CAAC,SAAS,mBAAmB,CAAC,CAAC;EAC5E,eAAe,IAAI,OAAO,YAAY;AACvC,CAAC;AAEM,IAAM,qBAAqB,IAAI,KAAK,sBAAsB;EAChE,IAAI;EACJ,IAAI;AACL,CAAC;;;ACtJM,SAAS,0BACf,MACoC;AACpC,UAAQ,MAAM;IACb,KAAK;AACJ,aAAO,IAAI,GAAG;IACf,KAAK;AACJ,aAAO,IAAI,IAAI;IAChB,KAAK;AACJ,aAAO,IAAI,IAAI;IAChB,KAAK;AACJ,aAAO,IAAI,IAAI;IAChB,KAAK;AACJ,aAAO,IAAI,KAAK;IACjB,KAAK;AACJ,aAAO,IAAI,KAAK;IACjB,KAAK;AACJ,aAAO,IAAI,KAAK;IACjB,KAAK;AACJ,aAAO,IAAI,OAAO;IACnB,KAAK;IACL,KAAK;AACJ,aAAO;EACT;AAEA,QAAM,UAAW,KAAgB,MAAM,yBAAyB;AAChE,MAAI,SAAS;AACZ,UAAM,CAAC,MAAM,KAAK,IAAI,QAAQ,MAAM,CAAC;AACrC,QAAI,SAAS,UAAU;AACtB,aAAO,IAAI,OAAO,0BAA0B,KAAqB,CAAC;IACnE,OAAO;AACN,aAAO,IAAI,OAAO,0BAA0B,KAAqB,CAAC;IACnE;EACD;AAEA,QAAM,IAAI,MAAM,2BAA2B,IAAI,EAAE;AAClD;;;AC9CA,IAAM,SAAS;EACd,GAAG;EACH,IAAI,IAAI,GAAG;EACX,KAAK,IAAI,IAAI;EACb,KAAK,IAAI,IAAI;EACb,KAAK,IAAI,IAAI;EACb,MAAM,IAAI,KAAK;EACf,MAAM,IAAI,KAAK;EACf,SAAS,IAAI,QAAQ;EACrB,MAAM,IAAI,KAAK;EACf,QAAQ,IAAI,OAAO;EACnB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACD;;;AC/EO,SAAS,qBACf,UACA,SACA,KACC;AACD,QAAM,UAAU,OAAI,QAAQ,UAAU,QAAQ,EAAE,QAAQ;AACxD,QAAM,MAAM,OAAI,QAAQ,UAAU,OAAO,EAAE,QAAQ;AACnD,QAAM,YAAY,OAAI,IAAI,EAAE,UAAU,IAAI,MAAM,EAAE,QAAQ;AAE1D,QAAM,OAAOC,SAAQ,OAAO;IAC3B,OAAO;EACR,CAAC;AAED,OAAK,OAAO,IAAI,WAAW,CAAC,GAAI,CAAC,CAAC;AAClC,OAAK,OAAO,OAAO;AACnB,OAAK,OAAO,SAAS;AACrB,OAAK,OAAO,GAAG;AACf,OAAK,OAAO,GAAG;AAEf,SAAO,KAAK,MAAM,KAAK,OAAO,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC;AAC9C;;;AClBA,IAAM,qBAAqB;AAC3B,IAAM,iBAAiB;AAEvB,IAAM,wBAAwB;AAC9B,IAAM,wBAAwB;AAE9B,IAAM,uBAAuB;AAC7B,IAAM,uBAAuB;AAE7B,IAAM,yBAAyB;AAC/B,IAAM,yBAAyB;AAExB,SAAS,YAAY,OAAuC;AAClE,QAAM,SACL,OAAO,MAAM,SAAS,YAAY,cAAc,MAAM,OAAO,MAAM,KAAK,WAAW;AAEpF,SACC,CAAC,CAAC,UACF,oBAAoB,OAAO,OAAO,MAAM,oBAAoB,KAAK,KACjE,OAAO,WAAW,gBAClB,OAAO,SAAS;AAElB;AAEO,SAAS,iBAAiB,eAA+D;AAC/F,MAAI,OAAO,kBAAkB,UAAU;AACtC,YAAQ,eAAe;MACtB,KAAK;AACJ,eAAO,OAAI;MACZ,KAAK;AACJ,eAAO,OAAI;MACZ,KAAK;AACJ,eAAO,OAAI;MACZ,KAAK;AACJ,eAAO,OAAI;MACZ,KAAK;AACJ,eAAO,OAAI;MACZ,KAAK;AACJ,eAAO,OAAI;MACZ,KAAK;AACJ,eAAO,OAAI;MACZ,KAAK;AACJ,eAAO,OAAI;MACZ;AACC,cAAM,IAAI,MAAM,0BAA0B,aAAa,EAAE;IAC3D;EACD;AAEA,MAAI,YAAY,eAAe;AAC9B,QAAI,cAAc,WAAW,MAAM;AAClC,aAAO,OAAI,WAAW,EAAE,UAAU;QACjC,OAAO,CAAC,QACP,OAAO,QAAQ,WAAW,IAAI,YAAY,EAAE,OAAO,GAAG,IAAI;QAC3D,QAAQ,CAAC,QAAQ;MAClB,CAAC;IACF;AACA,UAAM,OAAO,iBAAiB,cAAc,MAAM;AAClD,WAAO,OAAO,OAAI,OAAO,IAAI,IAAI;EAClC;AAEA,MAAI,cAAc,eAAe;AAChC,UAAM,MAAM,oBAAoB,cAAc,SAAS,OAAO;AAE9D,QAAI,QAAQ,oBAAoB,mBAAmB,GAAG;AACrD,UACC,cAAc,SAAS,WAAW,yBAClC,cAAc,SAAS,SAAS,uBAC/B;AACD,eAAO,OAAI;MACZ;AAEA,UACC,cAAc,SAAS,WAAW,wBAClC,cAAc,SAAS,SAAS,sBAC/B;AACD,eAAO,OAAI;MACZ;AAEA,UACC,cAAc,SAAS,WAAW,0BAClC,cAAc,SAAS,SAAS,wBAC/B;AACD,cAAM,OAAO,iBAAiB,cAAc,SAAS,eAAe,CAAC,CAAC;AACtE,eAAO,OAAO,OAAI,OAAO,IAAI,IAAI;MAClC;IACD;AAEA,QACC,QAAQ,oBAAoB,qBAAqB,KACjD,cAAc,SAAS,WAAW,sBAClC,cAAc,SAAS,SAAS,gBAC/B;AACD,aAAO,OAAI;IACZ;EACD;AAEA,SAAO;AACR;AAEO,SAAS,kCACf,MACwB;AACxB,MAAI,OAAO,SAAS,YAAY,eAAe,MAAM;AACpD,WAAO;MACN,KAAK;MACL,MAAM,sCAAsC,KAAK,SAAS;IAC3D;EACD;AACA,MAAI,OAAO,SAAS,YAAY,sBAAsB,MAAM;AAC3D,WAAO;MACN,KAAK;MACL,MAAM,sCAAsC,KAAK,gBAAgB;IAClE;EACD;AAEA,SAAO;IACN,KAAK;IACL,MAAM,sCAAsC,IAAI;EACjD;AACD;AAEA,SAAS,sCACR,MAC4B;AAC5B,MAAI,OAAO,SAAS,UAAU;AAC7B,YAAQ,MAAM;MACb,KAAK;AACJ,eAAO;MACR,KAAK;AACJ,eAAO;MACR,KAAK;AACJ,eAAO;MACR,KAAK;AACJ,eAAO;MACR,KAAK;AACJ,eAAO;MACR,KAAK;AACJ,eAAO;MACR,KAAK;AACJ,eAAO;MACR,KAAK;AACJ,eAAO;MACR;AACC,cAAM,IAAI,MAAM,mBAAmB,IAAI,EAAE;IAC3C;EACD;AAEA,MAAI,YAAY,MAAM;AACrB,WAAO,EAAE,QAAQ,sCAAsC,KAAK,MAAM,EAAE;EACrE;AAEA,MAAI,YAAY,MAAM;AACrB,WAAO;MACN,UAAU;QACT,SAAS,KAAK,OAAO;QACrB,QAAQ,KAAK,OAAO;QACpB,MAAM,KAAK,OAAO;QAClB,gBAAgB,KAAK,OAAO,cAAc,IAAI,qCAAqC;MACpF;IACD;EACD;AAEA,MAAI,mBAAmB,MAAM;AAC5B,WAAO,EAAE,eAAe,KAAK,cAAc;EAC5C;AAEA,QAAM,IAAI,MAAM,mBAAmB,KAAK,UAAU,IAAI,CAAC,EAAE;AAC1D;;;ACzKA,SAAS,KAAK,MAA4E;AACzF,SAAO;IACN,OAAO;IACP,MAAM;MACL,OAAO,gBAAgB,aAAa,SAAS,IAAI,IAAI,KAAK,SAAS;IACpE;EACD;AACD;AAEO,IAAM,SAAS;EACrB;EACA,UAAU,EAAE,UAAU,QAAQ,QAAQ,GAAqD;AAC1F,WAAO;MACN,OAAO;MACP,QAAQ;QACP,OAAO;QACP,kBAAkB;UACjB;UACA;UACA,UAAU,oBAAoB,QAAQ;QACvC;MACD;IACD;EACD;EACA,gBAAgB;IACf;IACA;IACA;EACD,GAI0C;AACzC,WAAO;MACN,OAAO;MACP,QAAQ;QACP,OAAO;QACP,cAAc;UACb;UACA;UACA,UAAU,oBAAoB,QAAQ;QACvC;MACD;IACD;EACD;EACA,aAAa,EAAE,UAAU,QAAQ,QAAQ,GAAqD;AAC7F,WAAO;MACN,OAAO;MACP,QAAQ;QACP,OAAO;QACP,WAAW;UACV;UACA;UACA,UAAU,oBAAoB,QAAQ;QACvC;MACD;IACD;EACD;AACD;;;AC3BA,IAAI,aAAa;AAGjB,IAAI;AAIJ,SAAS,gBAAgB,SAAS;AAChC,SAAO;AAAA,IACL,MAAM,SAAS,QAAQ,OAAO;AAAA,IAC9B,SAAS,SAAS;AAAA,IAClB,YAAY,SAAS,cAAc,OAAO;AAAA,IAC1C,gBAAgB,SAAS,kBAAkB,OAAO;AAAA,EACpD;AACF;AAMA,IAAI;AAKJ,SAAS,iBAAiB,MAAM;AAC9B,SAAO,QAAQ,IAAI,IAAI;AACzB;AAMA,IAAI;AAKJ,SAAS,iBAAiB,MAAM;AAC9B,SAAO,QAAQ,IAAI,IAAI;AACzB;AAMA,IAAI;AAMJ,SAAS,mBAAmB,WAAW,MAAM;AAC3C,SAAO,QAAQ,IAAI,SAAS,GAAG,IAAI,IAAI;AACzC;AAMA,SAAS,WAAW,OAAO;AACzB,QAAM,OAAO,OAAO;AACpB,MAAI,SAAS,UAAU;AACrB,WAAO,IAAI,KAAK;AAAA,EAClB;AACA,MAAI,SAAS,YAAY,SAAS,YAAY,SAAS,WAAW;AAChE,WAAO,GAAG,KAAK;AAAA,EACjB;AACA,MAAI,SAAS,YAAY,SAAS,YAAY;AAC5C,YAAQ,SAAS,OAAO,eAAe,KAAK,GAAG,aAAa,SAAS;AAAA,EACvE;AACA,SAAO;AACT;AAGA,SAAS,UAAU,SAAS,OAAO,SAAS,SAAS,OAAO;AAC1D,QAAM,QAAQ,SAAS,WAAW,QAAQ,MAAM,QAAQ,QAAQ;AAChE,QAAM,WAAW,OAAO,YAAY,QAAQ,WAAW;AACvD,QAAM,WAAW,OAAO,YAAY,WAAW,KAAK;AACpD,QAAM,QAAQ;AAAA,IACZ,MAAM,QAAQ;AAAA,IACd,MAAM,QAAQ;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS,WAAW,KAAK,KAAK,WAAW,YAAY,QAAQ,WAAW,GAAG,WAAW,QAAQ;AAAA;AAAA,IAE9F,aAAa,QAAQ;AAAA,IACrB,MAAM,OAAO;AAAA,IACb,QAAQ,OAAO;AAAA,IACf,MAAM,QAAQ;AAAA,IACd,YAAY,QAAQ;AAAA,IACpB,gBAAgB,QAAQ;AAAA,EAC1B;AACA,QAAM,WAAW,QAAQ,SAAS;AAClC,QAAM,UAAU,OAAO;AAAA,EACvB,QAAQ,WAAW,mBAAmB,QAAQ,WAAW,MAAM,IAAI,MAAM,WAAW,iBAAiB,MAAM,IAAI,IAAI,SAAS,QAAQ,WAAW,iBAAiB,MAAM,IAAI;AAC1K,MAAI,SAAS;AACX,UAAM,UAAU,OAAO,YAAY,aAAa,QAAQ,KAAK,IAAI;AAAA,EACnE;AACA,MAAI,UAAU;AACZ,YAAQ,QAAQ;AAAA,EAClB;AACA,MAAI,QAAQ,QAAQ;AAClB,YAAQ,OAAO,KAAK,KAAK;AAAA,EAC3B,OAAO;AACL,YAAQ,SAAS,CAAC,KAAK;AAAA,EACzB;AACF;AAkBA,SAAS,kBAAkB,SAAS,KAAK;AACvC,SAAO,OAAO,OAAO,SAAS,GAAG,KAAK,QAAQ,eAAe,QAAQ,eAAe,QAAQ;AAC9F;AA+CA,IAAI,YAAY,cAAc,MAAM;AAAA;AAAA;AAAA;AAAA,EAIlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,QAAQ;AAClB,UAAM,OAAO,CAAC,EAAE,OAAO;AACvB,SAAK,OAAO;AACZ,SAAK,SAAS;AAAA,EAChB;AACF;AA4DA,SAAS,MAAM,aAAa,SAAS;AACnC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,OAAO;AAAA,IACP,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,SAAS,CAAC,KAAK,YAAY,QAAQ,KAAK,GAAG;AACrD,kBAAU,MAAM,SAAS,SAAS,OAAO;AAAA,MAC3C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAwaA,SAAS,QAAQ,SAAS;AACxB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,OAAO;AAAA,IACP,SAAS;AAAA,IACT,aAAa,OAAO;AAAA,IACpB;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,SAAS,CAAC,KAAK,YAAY,QAAQ,KAAK,GAAG;AACrD,kBAAU,MAAM,WAAW,SAAS,OAAO;AAAA,MAC7C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA28BA,SAAS,UAAU,WAAW;AAC5B,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS;AACZ,cAAQ,QAAQ,KAAK,UAAU,QAAQ,KAAK;AAC5C,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA+EA,SAAS,IAAI,SAAS;AACpB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,OAAO;AAAA,IACP,SAAS;AAAA,IACT,YAAY,OAAO;AACjB,UAAI;AACF,YAAI,IAAI,KAAK;AACb,eAAO;AAAA,MACT,QAAQ;AACN,eAAO;AAAA,MACT;AAAA,IACF;AAAA,IACA;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,SAAS,CAAC,KAAK,YAAY,QAAQ,KAAK,GAAG;AACrD,kBAAU,MAAM,OAAO,SAAS,OAAO;AAAA,MACzC;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAGA,SAAS,KAAK,SAAS;AACrB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,OAAO;AAAA,IACP,SAAS;AAAA,IACT,aAAa;AAAA,IACb;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,SAAS,CAAC,KAAK,YAAY,KAAK,QAAQ,KAAK,GAAG;AAC1D,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAuLA,SAAS,WAAW,QAAQ,SAAS,SAAS;AAC5C,SAAO,OAAO,OAAO,YAAY;AAAA;AAAA,IAE/B,OAAO,QAAQ,SAAS,OAAO;AAAA;AAAA;AAAA,IAG/B,OAAO;AAAA;AAEX;AAqEA,SAAS,GAAG,QAAQ,OAAO;AACzB,SAAO,CAAC,OAAO,KAAK,EAAE,OAAO,OAAO,OAAO,MAAM,GAAG,EAAE,YAAY,KAAK,CAAC,EAAE;AAC5E;AAkBA,SAAS,MAAM,MAAM,SAAS;AAC5B,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,YAAM,QAAQ,QAAQ;AACtB,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAQ,QAAQ;AAChB,gBAAQ,QAAQ,CAAC;AACjB,iBAAS,MAAM,GAAG,MAAM,MAAM,QAAQ,OAAO;AAC3C,gBAAM,SAAS,MAAM,GAAG;AACxB,gBAAM,cAAc,KAAK,KAAK,KAAK,EAAE,OAAO,OAAO,OAAO,OAAO,GAAG,OAAO;AAC3E,cAAI,YAAY,QAAQ;AACtB,kBAAM,WAAW;AAAA,cACf,MAAM;AAAA,cACN,QAAQ;AAAA,cACR;AAAA,cACA;AAAA,cACA,OAAO;AAAA,YACT;AACA,uBAAW,SAAS,YAAY,QAAQ;AACtC,kBAAI,MAAM,MAAM;AACd,sBAAM,KAAK,QAAQ,QAAQ;AAAA,cAC7B,OAAO;AACL,sBAAM,OAAO,CAAC,QAAQ;AAAA,cACxB;AACA,sBAAQ,QAAQ,KAAK,KAAK;AAAA,YAC5B;AACA,gBAAI,CAAC,QAAQ,QAAQ;AACnB,sBAAQ,SAAS,YAAY;AAAA,YAC/B;AACA,gBAAI,QAAQ,YAAY;AACtB,sBAAQ,QAAQ;AAChB;AAAA,YACF;AAAA,UACF;AACA,cAAI,CAAC,YAAY,OAAO;AACtB,oBAAQ,QAAQ;AAAA,UAClB;AACA,kBAAQ,MAAM,KAAK,YAAY,KAAK;AAAA,QACtC;AAAA,MACF,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA4DA,SAAS,OAAO,SAAS;AACvB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,OAAO,QAAQ,UAAU,UAAU;AACrC,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAuBA,SAAS,QAAQ,SAAS;AACxB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,OAAO,QAAQ,UAAU,WAAW;AACtC,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA8TA,SAAS,KAAK,QAAQ;AACpB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,aAAO,KAAK,OAAO,QAAQ,KAAK,EAAE,KAAK,SAAS,OAAO;AAAA,IACzD;AAAA,EACF;AACF;AAkBA,SAAS,QAAQ,UAAU,SAAS;AAClC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,WAAW,QAAQ;AAAA,IAC5B,OAAO;AAAA,IACP,SAAS;AAAA,IACT;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,UAAU,KAAK,SAAS;AAClC,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAgmBA,SAAS,MAAM,SAAS;AACtB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,UAAU,MAAM;AAC1B,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAGA,SAAS,SAAS,YAAY,MAAM;AAClC,QAAM,SAAS;AAAA,IACb,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,GAAG,QAAQ,OAAO;AAAA,IAC3B,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,UAAU,MAAM;AAC1B,YAAI,aAAa,MAAM;AACrB,kBAAQ,QAAQ;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AACA,YAAI,QAAQ,UAAU,MAAM;AAC1B,kBAAQ,QAAQ;AAChB,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,KAAK,QAAQ,KAAK,SAAS,OAAO;AAAA,IAC3C;AAAA,EACF;AACA,MAAI,KAAK,MAAM;AACb,WAAO,UAAU,KAAK,CAAC;AAAA,EACzB;AACA,SAAO;AACT;AAmCA,SAAS,QAAQ,YAAY,MAAM;AACjC,QAAM,SAAS;AAAA,IACb,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,GAAG,QAAQ,OAAO;AAAA,IAC3B,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,UAAU,QAAQ,QAAQ,UAAU,QAAQ;AACtD,YAAI,aAAa,MAAM;AACrB,kBAAQ,QAAQ;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AACA,YAAI,QAAQ,UAAU,QAAQ,QAAQ,UAAU,QAAQ;AACtD,kBAAQ,QAAQ;AAChB,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,KAAK,QAAQ,KAAK,SAAS,OAAO;AAAA,IAC3C;AAAA,EACF;AACA,MAAI,KAAK,MAAM;AACb,WAAO,UAAU,KAAK,CAAC;AAAA,EACzB;AACA,SAAO;AACT;AAmCA,SAAS,OAAO,SAAS;AACvB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,OAAO,QAAQ,UAAU,YAAY,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC9D,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAGA,SAAS,OAAO,SAAS,SAAS;AAChC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,YAAM,QAAQ,QAAQ;AACtB,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,gBAAQ,QAAQ;AAChB,gBAAQ,QAAQ,CAAC;AACjB,mBAAW,OAAO,KAAK,SAAS;AAC9B,gBAAM,SAAS,MAAM,GAAG;AACxB,gBAAM,eAAe,KAAK,QAAQ,GAAG,EAAE;AAAA,YACrC,EAAE,OAAO,OAAO,OAAO,OAAO;AAAA,YAC9B;AAAA,UACF;AACA,cAAI,aAAa,QAAQ;AACvB,kBAAM,WAAW;AAAA,cACf,MAAM;AAAA,cACN,QAAQ;AAAA,cACR;AAAA,cACA;AAAA,cACA,OAAO;AAAA,YACT;AACA,uBAAW,SAAS,aAAa,QAAQ;AACvC,kBAAI,MAAM,MAAM;AACd,sBAAM,KAAK,QAAQ,QAAQ;AAAA,cAC7B,OAAO;AACL,sBAAM,OAAO,CAAC,QAAQ;AAAA,cACxB;AACA,sBAAQ,QAAQ,KAAK,KAAK;AAAA,YAC5B;AACA,gBAAI,CAAC,QAAQ,QAAQ;AACnB,sBAAQ,SAAS,aAAa;AAAA,YAChC;AACA,gBAAI,QAAQ,YAAY;AACtB,sBAAQ,QAAQ;AAChB;AAAA,YACF;AAAA,UACF;AACA,cAAI,CAAC,aAAa,OAAO;AACvB,oBAAQ,QAAQ;AAAA,UAClB;AACA,cAAI,aAAa,UAAU,UAAU,OAAO,OAAO;AACjD,oBAAQ,MAAM,GAAG,IAAI,aAAa;AAAA,UACpC;AAAA,QACF;AAAA,MACF,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAyRA,SAAS,SAAS,YAAY,MAAM;AAClC,QAAM,SAAS;AAAA,IACb,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,GAAG,QAAQ,OAAO;AAAA,IAC3B,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,QAAQ,UAAU,QAAQ;AAC5B,YAAI,aAAa,MAAM;AACrB,kBAAQ,QAAQ;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AACA,YAAI,QAAQ,UAAU,QAAQ;AAC5B,kBAAQ,QAAQ;AAChB,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,KAAK,QAAQ,KAAK,SAAS,OAAO;AAAA,IAC3C;AAAA,EACF;AACA,MAAI,KAAK,MAAM;AACb,WAAO,UAAU,KAAK,CAAC;AAAA,EACzB;AACA,SAAO;AACT;AA4EA,SAAS,OAAO,KAAK,QAAQ,SAAS;AACpC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,YAAM,QAAQ,QAAQ;AACtB,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,gBAAQ,QAAQ;AAChB,gBAAQ,QAAQ,CAAC;AACjB,mBAAW,YAAY,OAAO;AAC5B,cAAI,kBAAkB,OAAO,QAAQ,GAAG;AACtC,kBAAM,aAAa,MAAM,QAAQ;AACjC,kBAAM,aAAa,KAAK,IAAI;AAAA,cAC1B,EAAE,OAAO,OAAO,OAAO,SAAS;AAAA,cAChC;AAAA,YACF;AACA,gBAAI,WAAW,QAAQ;AACrB,oBAAM,WAAW;AAAA,gBACf,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR;AAAA,gBACA,KAAK;AAAA,gBACL,OAAO;AAAA,cACT;AACA,yBAAW,SAAS,WAAW,QAAQ;AACrC,sBAAM,OAAO,CAAC,QAAQ;AACtB,wBAAQ,QAAQ,KAAK,KAAK;AAAA,cAC5B;AACA,kBAAI,CAAC,QAAQ,QAAQ;AACnB,wBAAQ,SAAS,WAAW;AAAA,cAC9B;AACA,kBAAI,QAAQ,YAAY;AACtB,wBAAQ,QAAQ;AAChB;AAAA,cACF;AAAA,YACF;AACA,kBAAM,eAAe,KAAK,MAAM;AAAA,cAC9B,EAAE,OAAO,OAAO,OAAO,WAAW;AAAA,cAClC;AAAA,YACF;AACA,gBAAI,aAAa,QAAQ;AACvB,oBAAM,WAAW;AAAA,gBACf,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR;AAAA,gBACA,KAAK;AAAA,gBACL,OAAO;AAAA,cACT;AACA,yBAAW,SAAS,aAAa,QAAQ;AACvC,oBAAI,MAAM,MAAM;AACd,wBAAM,KAAK,QAAQ,QAAQ;AAAA,gBAC7B,OAAO;AACL,wBAAM,OAAO,CAAC,QAAQ;AAAA,gBACxB;AACA,wBAAQ,QAAQ,KAAK,KAAK;AAAA,cAC5B;AACA,kBAAI,CAAC,QAAQ,QAAQ;AACnB,wBAAQ,SAAS,aAAa;AAAA,cAChC;AACA,kBAAI,QAAQ,YAAY;AACtB,wBAAQ,QAAQ;AAChB;AAAA,cACF;AAAA,YACF;AACA,gBAAI,CAAC,WAAW,SAAS,CAAC,aAAa,OAAO;AAC5C,sBAAQ,QAAQ;AAAA,YAClB;AACA,gBAAI,WAAW,OAAO;AACpB,sBAAQ,MAAM,WAAW,KAAK,IAAI,aAAa;AAAA,YACjD;AAAA,UACF;AAAA,QACF;AAAA,MACF,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAuhBA,SAAS,OAAO,SAAS;AACvB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI,OAAO,QAAQ,UAAU,UAAU;AACrC,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAuBA,SAAS,MAAM,OAAO,SAAS;AAC7B,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,YAAM,QAAQ,QAAQ;AACtB,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAQ,QAAQ;AAChB,gBAAQ,QAAQ,CAAC;AACjB,iBAAS,MAAM,GAAG,MAAM,KAAK,MAAM,QAAQ,OAAO;AAChD,gBAAM,SAAS,MAAM,GAAG;AACxB,gBAAM,cAAc,KAAK,MAAM,GAAG,EAAE;AAAA,YAClC,EAAE,OAAO,OAAO,OAAO,OAAO;AAAA,YAC9B;AAAA,UACF;AACA,cAAI,YAAY,QAAQ;AACtB,kBAAM,WAAW;AAAA,cACf,MAAM;AAAA,cACN,QAAQ;AAAA,cACR;AAAA,cACA;AAAA,cACA,OAAO;AAAA,YACT;AACA,uBAAW,SAAS,YAAY,QAAQ;AACtC,kBAAI,MAAM,MAAM;AACd,sBAAM,KAAK,QAAQ,QAAQ;AAAA,cAC7B,OAAO;AACL,sBAAM,OAAO,CAAC,QAAQ;AAAA,cACxB;AACA,sBAAQ,QAAQ,KAAK,KAAK;AAAA,YAC5B;AACA,gBAAI,CAAC,QAAQ,QAAQ;AACnB,sBAAQ,SAAS,YAAY;AAAA,YAC/B;AACA,gBAAI,QAAQ,YAAY;AACtB,sBAAQ,QAAQ;AAChB;AAAA,YACF;AAAA,UACF;AACA,cAAI,CAAC,YAAY,OAAO;AACtB,oBAAQ,QAAQ;AAAA,UAClB;AACA,kBAAQ,MAAM,KAAK,YAAY,KAAK;AAAA,QACtC;AAAA,MACF,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAgSA,SAAS,WAAW,UAAU;AAC5B,MAAI;AACJ,MAAI,UAAU;AACZ,eAAW,WAAW,UAAU;AAC9B,UAAI,QAAQ;AACV,eAAO,KAAK,GAAG,QAAQ,MAAM;AAAA,MAC/B,OAAO;AACL,iBAAS,QAAQ;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAGA,SAAS,MAAM,SAAS,SAAS;AAC/B,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,CAAC,GAAG,IAAI,IAAI,QAAQ,IAAI,CAACC,YAAWA,QAAO,OAAO,CAAC,CAAC,EAAE,KAAK,KAAK,KAAK;AAAA,IAC9E,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,iBAAW,UAAU,KAAK,SAAS;AACjC,cAAM,gBAAgB,OAAO;AAAA,UAC3B,EAAE,OAAO,OAAO,OAAO,QAAQ,MAAM;AAAA,UACrC;AAAA,QACF;AACA,YAAI,cAAc,OAAO;AACvB,cAAI,cAAc,QAAQ;AACxB,gBAAI,eAAe;AACjB,4BAAc,KAAK,aAAa;AAAA,YAClC,OAAO;AACL,8BAAgB,CAAC,aAAa;AAAA,YAChC;AAAA,UACF,OAAO;AACL,2BAAe;AACf;AAAA,UACF;AAAA,QACF,OAAO;AACL,cAAI,iBAAiB;AACnB,4BAAgB,KAAK,aAAa;AAAA,UACpC,OAAO;AACL,8BAAkB,CAAC,aAAa;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AACA,UAAI,cAAc;AAChB,eAAO;AAAA,MACT;AACA,UAAI,eAAe;AACjB,YAAI,cAAc,WAAW,GAAG;AAC9B,iBAAO,cAAc,CAAC;AAAA,QACxB;AACA,kBAAU,MAAM,QAAQ,SAAS,SAAS;AAAA,UACxC,QAAQ,WAAW,aAAa;AAAA,QAClC,CAAC;AACD,gBAAQ,QAAQ;AAAA,MAClB,WAAW,iBAAiB,WAAW,GAAG;AACxC,eAAO,gBAAgB,CAAC;AAAA,MAC1B,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,SAAS;AAAA,UACxC,QAAQ,WAAW,eAAe;AAAA,QACpC,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAgEA,SAAS,UAAU;AACjB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP,KAAK,SAAS;AACZ,cAAQ,QAAQ;AAChB,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAGA,SAAS,gBAAgB,KAAK,SAAS,OAAuB,oBAAI,IAAI,GAAG;AACvE,aAAW,UAAU,SAAS;AAC5B,QAAI,OAAO,SAAS,WAAW;AAC7B,sBAAgB,KAAK,OAAO,SAAS,IAAI;AAAA,IAC3C,OAAO;AACL,WAAK,IAAI,OAAO,QAAQ,GAAG,EAAE,OAAO;AAAA,IACtC;AAAA,EACF;AACA,SAAO;AACT;AAGA,SAAS,QAAQ,KAAK,SAAS,SAAS;AACtC,MAAI;AACJ,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK,SAAS,SAAS;AACrB,YAAM,QAAQ,QAAQ;AACtB,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,cAAM,gBAAgB,MAAM,KAAK,GAAG;AACpC,YAAI,KAAK,OAAO,OAAO;AACrB,cAAI;AACJ,qBAAW,UAAU,KAAK,SAAS;AACjC,gBAAI,OAAO,SAAS,aAAa,CAAC,OAAO,QAAQ,KAAK,GAAG,EAAE;AAAA,cACzD,EAAE,OAAO,OAAO,OAAO,cAAc;AAAA,cACrC;AAAA,YACF,EAAE,QAAQ;AACR,oBAAM,gBAAgB,OAAO;AAAA,gBAC3B,EAAE,OAAO,OAAO,OAAO,MAAM;AAAA,gBAC7B;AAAA,cACF;AACA,kBAAI,CAAC,cAAc,QAAQ;AACzB,uBAAO;AAAA,cACT;AACA,kBAAI,CAAC,iBAAiB,CAAC,cAAc,SAAS,cAAc,OAAO;AACjE,gCAAgB;AAAA,cAClB;AAAA,YACF;AAAA,UACF;AACA,cAAI,eAAe;AACjB,mBAAO;AAAA,UACT;AAAA,QACF;AACA,YAAI,CAAC,wBAAwB;AAC3B,mCAAyB,CAAC,GAAG,gBAAgB,KAAK,KAAK,KAAK,OAAO,CAAC,EAAE,KAAK,KAAK,KAAK;AAAA,QACvF;AACA,kBAAU,MAAM,QAAQ,SAAS,SAAS;AAAA,UACxC,OAAO;AAAA,UACP,UAAU;AAAA,UACV,MAAM;AAAA,YACJ;AAAA,cACE,MAAM;AAAA,cACN,QAAQ;AAAA,cACR;AAAA,cACA,KAAK,KAAK;AAAA,cACV,OAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AACL,kBAAU,MAAM,QAAQ,SAAS,OAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAsGA,SAAS,MAAM,QAAQ,OAAO,SAAS;AACrC,QAAM,UAAU,OAAO;AAAA,IACrB,EAAE,OAAO,OAAO,OAAO,MAAM;AAAA,IAC7B,gBAAgB,OAAO;AAAA,EACzB;AACA,MAAI,QAAQ,QAAQ;AAClB,UAAM,IAAI,UAAU,QAAQ,MAAM;AAAA,EACpC;AACA,SAAO,QAAQ;AACjB;AA0DA,SAAS,QAAQ,OAAO;AACtB,SAAO;AAAA,IACL,GAAG,MAAM,CAAC;AAAA,IACV,MAAM;AAAA,IACN,KAAK,SAAS,SAAS;AACrB,eAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,YAAI,QAAQ,WAAW,MAAM,KAAK,EAAE,SAAS,YAAY,MAAM,KAAK,EAAE,SAAS,mBAAmB;AAChG,kBAAQ,QAAQ;AAChB;AAAA,QACF;AACA,YAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,cAAc,CAAC,QAAQ,gBAAgB;AACrE,oBAAU,MAAM,KAAK,EAAE,KAAK,SAAS,OAAO;AAAA,QAC9C;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA8CA,SAAS,UAAU,QAAQ,OAAO,SAAS;AACzC,QAAM,UAAU,OAAO;AAAA,IACrB,EAAE,OAAO,OAAO,OAAO,MAAM;AAAA,IAC7B,gBAAgB,OAAO;AAAA,EACzB;AACA,SAAO;AAAA,IACL,OAAO,QAAQ;AAAA,IACf,SAAS,CAAC,QAAQ;AAAA,IAClB,QAAQ,QAAQ;AAAA,IAChB,QAAQ,QAAQ;AAAA,EAClB;AACF;;;AC/rKO,SAAS,SAAuD,SAA2B;AACjG,QAAM,eAAe,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,OAAO,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC;AAE3F,SAAO;IACN,MAAM,YAAY;IAClB,UAAU,CAAC,WAAW;MACrB,GAAG;MACH,OAAO,OAAO,KAAK,KAAK,EAAE,CAAC;IAC5B,EAAE;EACH;AACD;AAEO,IAAM,aAAa;EACzB,OAAO;EACP,UAAU,CAAC,UAAU,oBAAoB,KAAK,CAAC;EAC/C,MAAM,iBAAiB;AACxB;AACO,IAAM,WAAW;AACjB,IAAM,WAAW,OAAO;AACxB,IAAM,UAAU;EACtB,MAAM,CAAC,OAAO,GAAG,KAAK,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC;EAE3C,MAAM,CAAC,QAAQ;AACd,QAAI;AACH,aAAO,GAAG;AACV,aAAO,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG,KAAK;IAC3C,QAAQ;AACP,aAAO;IACR;EACD,GAAG,aAAa;AACjB;AAGO,IAAM,kBAAkB,OAAO;EACrC,UAAU;EACV,SAAS;EACT,QAAQ,OAAO;AAChB,CAAC;AAIM,IAAM,iBAAiB;EAC7B,MAAM;IACL,OAAO,EAAE,SAAS,QAAQ,IAAI,EAAE,CAAC;IACjC,OAAO,EAAE,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC,GAAG,MAAM,SAAS,QAAQ,MAAM,CAAC,EAAE,CAAC;IAC5E,OAAO,EAAE,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC,GAAG,MAAM,SAAS,QAAQ,QAAQ,CAAC,EAAE,CAAC;IAC9E,OAAO,EAAE,QAAQ,KAAK,OAAO,GAAG,QAAQ,CAAC,EAAE,CAAC;IAC5C,OAAO,EAAE,cAAc,MAAM,CAAC,KAAK,OAAO,GAAG,QAAQ,CAAC,GAAG,KAAK,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;EACvF,CAAC;EACD,UAAU,CAAC,WAAW;IACrB,GAAG;IACH,OAAO,OAAO,KAAK,KAAK,EAAE,CAAC;EAC5B,EAAE;;AAEH;AAiBO,IAAM,gBAAgB,OAAO;EACnC,QAAQ,SAAS,OAAO;EACxB,OAAO,SAAS,OAAO;EACvB,OAAO,SAAS,UAAU;EAC1B,SAAS,SAAS,MAAM,eAAe,CAAC;AACzC,CAAC;AAIM,IAAM,kBAAkB,OAAO;EACrC,SAAS,OAAO;EAChB,QAAQ,OAAO;EACf,MAAM,OAAO;;EAEb,YAAY,MAAM,OAAO,CAAC;AAC3B,CAAC;AAwBM,IAAM,kCAA4E,MAAM;EAC9F,QAAQ,SAAS;EACjB,QAAQ,MAAM;EACd,QAAQ,IAAI;EACZ,QAAQ,KAAK;EACb,QAAQ,KAAK;EACb,QAAQ,KAAK;EACb,QAAQ,MAAM;EACd,QAAQ,MAAM;EACd,OAAO,EAAE,QAAQ,KAAK,MAAM,+BAA+B,EAAE,CAAC;EAC9D,OAAO;IACN,UAAU,OAAO;MAChB,SAAS,OAAO;MAChB,QAAQ,OAAO;MACf,MAAM,OAAO;MACb,gBAAgB,MAAM,KAAK,MAAM,+BAA+B,CAAC;IAClE,CAAC;EACF,CAAC;EACD,OAAO,EAAE,eAAe,KAAK,OAAO,GAAG,QAAQ,CAAC,EAAE,CAAC;AACpD,CAAC;AAGM,IAAM,8BAA8B,OAAO;EACjD,KAAK,SAAS,MAAM,CAAC,QAAQ,GAAG,GAAG,QAAQ,MAAM,CAAC,CAAC,CAAC;EACpD,MAAM;AACP,CAAC;AAID,IAAM,6BAA6B,OAAO;EACzC,SAAS;EACT,QAAQ,OAAO;EACf,UAAU,OAAO;;EAEjB,eAAe,MAAM,OAAO,CAAC;EAC7B,WAAW,MAAM,cAAc;EAC/B,gBAAgB,SAAS,SAAS,MAAM,2BAA2B,CAAC,CAAC;AACtE,CAAC;AAGM,IAAM,UAAU,OAAO;EAC7B,MAAM,OAAO;EACb,QAAQ,OAAO,OAAO,GAAG,MAAM,CAAC,gBAAgB,MAAM,cAAc,CAAC,CAAC,CAAC;EACvE,MAAM,OAAO,OAAO,GAAG,QAAQ,CAAC;AACjC,CAAC;AAGM,IAAM,gBAAgB,SAAS;EACrC,UAAU;EACV,iBAAiB,OAAO;IACvB,SAAS,MAAM,cAAc;IAC7B,SAAS;EACV,CAAC;EACD,YAAY,OAAO;IAClB,MAAM;IACN,SAAS,MAAM,cAAc;EAC9B,CAAC;EACD,YAAY,OAAO;IAClB,aAAa;IACb,SAAS,MAAM,cAAc;EAC9B,CAAC;EACD,SAAS,OAAO;IACf,SAAS,MAAM,QAAQ;IACvB,cAAc,MAAM,QAAQ;EAC7B,CAAC;EACD,aAAa,OAAO;IACnB,MAAM,SAAS,OAAO,CAAC;IACvB,UAAU,MAAM,cAAc;EAC/B,CAAC;EACD,SAAS,OAAO;IACf,SAAS,MAAM,QAAQ;IACvB,cAAc,MAAM,QAAQ;IAC5B,SAAS;IACT,QAAQ;EACT,CAAC;EACD;AACD,CAAC;AA6CM,IAAM,kBAAkB,SAAS;EACvC,kBAAkB;EAClB,cAAc,OAAO;IACpB,UAAU;;IAEV,sBAAsB;IACtB,SAAS,QAAQ;EAClB,CAAC;EACD,WAAW;AACZ,CAAC;AAGD,IAAM,gBAAgB,SAAS;EAC9B,QAAQ;EACR,MAAM,OAAO;IACZ,OAAO;EACR,CAAC;EACD,gBAAgB,OAAO;IACtB,OAAO,QAAQ;EAChB,CAAC;EACD,kBAAkB,OAAO;IACxB,UAAU;IACV,SAAS,SAAS,SAAS,OAAO,CAAC;IACnC,QAAQ,SAAS,SAAS,OAAO,CAAC,CAAC;IACnC,sBAAsB,SAAS,SAAS,OAAO,CAAC;IAChD,SAAS,SAAS,SAAS,QAAQ,CAAC,CAAC;EACtC,CAAC;AACF,CAAC;AAGM,IAAM,oBAAoB,SAAS;EACzC,QAAQ;EACR,MAAM,OAAO;IACZ,OAAO;EACR,CAAC;AACF,CAAC;AAEM,IAAMC,yBAAwB,SAAS;EAC7C,MAAM,QAAQ,IAAI;EAClB,OAAO;AACR,CAAC;AAIM,IAAM,wBAAwB,OAAO;EAC3C,SAAS,QAAQ,CAAC;EAClB,QAAQ,QAAQ,UAAU;EAC1B,YAAY,QAAQA,sBAAqB;EACzC,SAAS;EACT,QAAQ,MAAM,aAAa;EAC3B,UAAU,MAAM,aAAa;AAC9B,CAAC;;;AChTM,IAAK,iBAAL,CAAKC,mBAAL;AACNA,iBAAAA,eAAA,YAAA,IAAa,CAAA,IAAb;AACAA,iBAAAA,eAAA,UAAA,IAAW,GAAA,IAAX;AACAA,iBAAAA,eAAA,UAAA,IAAW,GAAA,IAAX;AAHW,SAAAA;AAAA,GAAA,iBAAA,CAAA,CAAA;AAaL,IAAM,WAAW;EACvB,SACC,OAa+B;AAC/B,UAAM,CAAC,KAAK,MAAM,IAAI,KAAK,EAAE,IAC5B,YAAY,QAAQ,MAAM,OAAO,MAAM,IAAI,IAAI,CAAC,MAAM,SAAS,MAAM,QAAQ,MAAM,QAAQ;AAE5F,WAAO;MACN,OAAO;MACP,UAAU;QACT,SAAS;QACT,QAAQ;QACR,UAAU;QACV,eAAe,MAAM,iBAAiB,CAAC;QACvC,WAAW,MAAM,aAAa,CAAC;MAChC;IACD;EACD;EAEA,gBACC,SACA,SACsC;AACtC,WAAO;MACN,OAAO;MACP,iBAAiB;QAChB,SAAS,QAAQ,IAAI,CAAC,MAAM,MAAM,gBAAgB,CAAC,CAAC;QACpD,SAAS,MAAM,gBAAgB,OAAO;MACvC;IACD;EACD;EACA,WACC,MACA,SACiC;AACjC,WAAO;MACN,OAAO;MACP,YAAY;QACX,MAAM,MAAM,gBAAgB,IAAI;QAChC,SAAS,QAAQ,IAAI,CAAC,MAAM,MAAM,gBAAgB,CAAC,CAAC;MACrD;IACD;EACD;EACA,WACC,aACA,SACiC;AACjC,WAAO;MACN,OAAO;MACP,YAAY;QACX,aAAa,MAAM,gBAAgB,WAAW;QAC9C,SAAS,QAAQ,IAAI,CAAC,MAAM,MAAM,gBAAgB,CAAC,CAAC;MACrD;IACD;EACD;EACA,QAAQ;IACP;IACA;EACD,GAGgC;AAC/B,WAAO;MACN,OAAO;MACP,SAAS;QACR,SAAS,QAAQ;UAAI,CAAC,WACrB,OAAO,WAAW,WAAW,SAAS,SAAS,IAAI,WAAW,MAAM,CAAC;QACtE;QACA,cAAc,aAAa,IAAI,CAAC,QAAQ,qBAAqB,GAAG,CAAC;MAClE;IACD;EACD;EACA,QAAQ;IACP;IACA;IACA,SAAS;IACT;EACD,GAKgC;AAC/B,WAAO;MACN,OAAO;MACP,SAAS;QACR,SAAS,QAAQ;UAAI,CAAC,WACrB,OAAO,WAAW,WAAW,SAAS,SAAS,IAAI,WAAW,MAAM,CAAC;QACtE;QACA,cAAc,aAAa,IAAI,CAAC,QAAQ,qBAAqB,GAAG,CAAC;QACjE,SAAS;QACT,QAAQ,MAAM,gBAAgB,MAAM;MACrC;IACD;EACD;EACA,YAAY;IACX;IACA;EACD,GAGoC;AACnC,WAAO;MACN,OAAO;MACP,aAAa;QACZ,MAAM,QAAQ;QACd,UAAU,SAAS,IAAI,CAAC,MAAM,MAAM,gBAAgB,CAAC,CAAC;MACvD;IACD;EACD;EACA,OAAO;IACN;IACA,SAAS,CAAC;IACV,OAAO,CAAC;EACT,GAOgC;AAC/B,WAAO;MACN,OAAO;MACP,SAAS;QACR;QACA,QAAQ,OAAO;UACd,OAAO,QAAQ,MAAM,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;YAC5C;YACA,MAAM,QAAQ,KAAK,IAChB,MAAM,IAAI,CAAC,MAAM,MAAM,gBAAgB,CAAC,CAAC,IACzC,MAAM,gBAAgB,KAAK;UAC/B,CAAC;QACF;QACA;MACD;IACD;EACD;AACD;;;ACzIO,SAAS,iBAAiB,KAAuB;AACvD,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO,oBAAoB,GAAG;EAC/B;AAEA,MAAI,IAAI,QAAQ;AACf,QAAI,IAAI,OAAO,kBAAkB;AAChC,aAAO,oBAAoB,IAAI,OAAO,iBAAiB,QAAQ;IAChE;AAEA,QAAI,IAAI,OAAO,WAAW;AACzB,aAAO,oBAAoB,IAAI,OAAO,UAAU,QAAQ;IACzD;AAEA,WAAO,oBAAoB,IAAI,OAAO,aAAa,QAAQ;EAC5D;AAEA,MAAI,IAAI,kBAAkB;AACzB,WAAO,oBAAoB,IAAI,iBAAiB,QAAQ;EACzD;AAEA,SAAO;AACR;AAEO,SAAS,WAAW,OAAmC;AAC7D,SAAO,GAAG,gBAAgB,KAAK;AAChC;AAEO,SAAS,sBACf,SACA,cACA,gBACC;AACD,QAAM,WAAW,CAAC,QAA4B;AAC7C,YAAQ,IAAI,OAAO;MAClB,KAAK,SAAS;AACb,cAAM,gBAAgB,aAAa,IAAI,IAAI,KAAK;AAChD,YAAI,kBAAkB,QAAW;AAChC,gBAAM,IAAI,MAAM,SAAS,IAAI,KAAK,6BAA6B;QAChE;AACA,eAAO,EAAE,GAAG,KAAK,OAAO,cAAc;MACvC;MACA,KAAK,UAAU;AACd,cAAM,kBAAkB,eAAe,IAAI,IAAI,MAAM;AACrD,YAAI,oBAAoB,QAAW;AAClC,iBAAO,EAAE,GAAG,KAAK,QAAQ,gBAAgB;QAC1C;AACA,eAAO;MACR;MACA,KAAK,gBAAgB;AACpB,cAAM,kBAAkB,eAAe,IAAI,IAAI,aAAa,CAAC,CAAC;AAC9D,YAAI,oBAAoB,QAAW;AAClC,iBAAO,EAAE,GAAG,KAAK,cAAc,CAAC,iBAAiB,IAAI,aAAa,CAAC,CAAC,EAAE;QACvE;AACA,eAAO;MACR;MACA;AACC,eAAO;IACT;EACD;AAEA,UAAQ,QAAQ,OAAO;IACtB,KAAK;AACJ,cAAQ,SAAS,YAAY,QAAQ,SAAS,UAAU,IAAI,QAAQ;AACpE;IACD,KAAK;AACJ,cAAQ,gBAAgB,UAAU,QAAQ,gBAAgB,QAAQ,IAAI,QAAQ;AAC9E,cAAQ,gBAAgB,UAAU,SAAS,QAAQ,gBAAgB,OAAO;AAC1E;IACD,KAAK;AACJ,cAAQ,WAAW,OAAO,SAAS,QAAQ,WAAW,IAAI;AAC1D,cAAQ,WAAW,UAAU,QAAQ,WAAW,QAAQ,IAAI,QAAQ;AACpE;IACD,KAAK;AACJ,cAAQ,WAAW,cAAc,SAAS,QAAQ,WAAW,WAAW;AACxE,cAAQ,WAAW,UAAU,QAAQ,WAAW,QAAQ,IAAI,QAAQ;AACpE;IACD,KAAK;AACJ,cAAQ,YAAY,WAAW,QAAQ,YAAY,SAAS,IAAI,QAAQ;AACxE;IACD,KAAK;AACJ,cAAQ,QAAQ,SAAS,SAAS,QAAQ,QAAQ,MAAM;AACxD;IACD,KAAK,WAAW;AACf,YAAM,SAAS,QAAQ,QAAQ;AAC/B,cAAQ,QAAQ,SAAS,CAAC;AAE1B,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,gBAAQ,QAAQ,OAAO,GAAG,IAAI,MAAM,QAAQ,KAAK,IAAI,MAAM,IAAI,QAAQ,IAAI,SAAS,KAAK;MAC1F;AACA;IACD;IACA,KAAK;AACJ;EACF;AACD;;;AC9GO,IAAM,YAAY,OAAO;EAC/B,QAAQ,OAAO;EACf,UAAU,OAAO;EACjB,SAAS,MAAM,CAAC,KAAK,OAAO,GAAG,QAAQ,CAAC,GAAG,OAAO,GAAG,OAAO,CAAC,CAAC;AAC/D,CAAC;AAED,IAAMC,aAAY,SAAS;EAC1B,YAAY;EACZ,QAAQ,OAAO;IACd,UAAU;IACV,sBAAsB;IACtB,SAAS,QAAQ;EAClB,CAAC;EACD,WAAW;AACZ,CAAC;AAEM,IAAMC,qBAAoB,SAAS;EACzC,QAAQD;EACR,MAAM,MAAM,KAAK,OAAO,GAAG,QAAQ,CAAC,CAAC;AACtC,CAAC;AAED,IAAM,mBAAmB,MAAM;EAC9B,OAAO;IACN,MAAM,QAAQ,OAAO;IACrB,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC;IAC/B,OAAO,QAAQ;IACf,MAAM,SAAS,QAAQ,QAAQ,CAAC;EACjC,CAAC;EACD,OAAO;IACN,MAAM,QAAQ,OAAO;IACrB,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC;IAC/B,OAAO,QAAQ;IACf,MAAM,QAAQ,MAAM;EACrB,CAAC;AACF,CAAC;AAED,IAAME,yBAAwB,MAAM;EACnC,OAAO,EAAE,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC,EAAE,CAAC;EAC3C,OAAO,EAAE,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;AACzC,CAAC;AAED,IAAM,sBAAsB;EAC3B,MAAM,CAAC,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC,CAAC;EACpC,MAAM,CAAC,QAAQ;AACd,QAAI,CAAC,CAAC,UAAU,UAAU,QAAQ,EAAE,SAAS,OAAO,GAAG,EAAG,QAAO;AAEjE,QAAI;AACH,aAAO,GAAa;AACpB,aAAO;IACR,QAAQ;AACP,aAAO;IACR;EACD,CAAC;AACF;AAEO,IAAMC,WAAsC,MAAM;EACxD,OAAO,EAAE,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EACxC,OAAO,EAAE,IAAI,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EACtC,OAAO,EAAE,KAAK,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EACvC,OAAO,EAAE,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EACxC,OAAO,EAAE,SAAS,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EAC3C,OAAO,EAAE,QAAQ,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EAC1C,OAAO,EAAE,QAAQ,KAAK,MAAMA,QAAO,EAAE,CAAC;EACtC,OAAO,EAAE,QAAQ,KAAK,MAAMC,UAAS,EAAE,CAAC;EACxC,OAAO,EAAE,KAAK,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EACvC,OAAO,EAAE,KAAK,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;EACvC,OAAO,EAAE,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC;AACzC,CAAC;AAGM,IAAMA,aAA0C,OAAO;EAC7D,SAAS,OAAO;EAChB,QAAQ,OAAO;EACf,MAAM,OAAO;EACb,YAAY,MAAMD,QAAO;AAC1B,CAAC;AAED,IAAM,YAAY,OAAO;EACxB,QAAQ,SAAS,mBAAmB;EACpC,OAAO,SAAS,mBAAmB;EACnC,SAAS,SAAS,MAAM,SAAS,CAAC;EAClC,OAAO,SAAS,OAAO,CAAC;AACzB,CAAC;AAED,IAAM,2BAA2B;EAChC;EACA,OAAO,EAAE,MAAM,QAAQ,SAAS,EAAE,CAAC;EACnC,OAAO,EAAE,MAAM,QAAQ,QAAQ,GAAG,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC,EAAE,CAAC;EACpE,OAAO;IACN,MAAM,QAAQ,cAAc;IAC5B,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC;IAC/B,aAAa,KAAK,OAAO,GAAG,QAAQ,CAAC;EACtC,CAAC;AACF;AAGO,IAAM,sBAAsB,MAAM,CAAC,GAAG,wBAAwB,CAAC;AAEtE,IAAM,sBAAsB,OAAO;EAClC,MAAM,QAAQ,UAAU;EACxB,QAAQ;IACP,OAAO;IACP,MAAM,CAAC,WAAW,OAAO,MAAM,IAAI,EAAE,WAAW,CAAC;EAClD;EACA,eAAe,MAAM,OAAO,CAAC;EAC7B,WAAW,MAAM,mBAAmB;AACrC,CAAC;AAED,IAAM,6BAA6B,OAAO;EACzC,MAAM,QAAQ,iBAAiB;EAC/B,SAAS,MAAM,mBAAmB;EAClC,SAAS;AACV,CAAC;AAED,IAAM,wBAAwB,OAAO;EACpC,MAAM,QAAQ,YAAY;EAC1B,MAAM;EACN,SAAS,MAAM,mBAAmB;AACnC,CAAC;AAED,IAAM,wBAAwB,OAAO;EACpC,MAAM,QAAQ,YAAY;EAC1B,aAAa;EACb,SAAS,MAAM,mBAAmB;AACnC,CAAC;AAED,IAAM,yBAAyB,OAAO;EACrC,MAAM,QAAQ,aAAa;EAC3B,MAAM,MAAM,CAAC,OAAO,EAAE,MAAMA,SAAQ,CAAC,GAAG,OAAO,EAAE,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;EAClF,SAAS,MAAM,mBAAmB;AACnC,CAAC;AAED,IAAM,qBAAqB,OAAO;EACjC,MAAM,QAAQ,SAAS;EACvB,SAAS,MAAM,MAAM,KAAK,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC;EAC/C,cAAc,MAAM,OAAO,CAAC;AAC7B,CAAC;AAED,IAAM,qBAAqB,OAAO;EACjC,MAAM,QAAQ,SAAS;EACvB,SAAS,MAAM,MAAM,KAAK,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC;EAC/C,cAAc,MAAM,OAAO,CAAC;EAC5B,WAAW,OAAO;EAClB,QAAQ;AACT,CAAC;AAED,IAAM,mBAAmB;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;AACD;AAEA,IAAM,kBAAkB,MAAM,CAAC,GAAG,gBAAgB,CAAC;AAE5C,IAAM,8BAA8B,OAAO;EACjD,SAAS,QAAQ,CAAC;EAClB,QAAQ,SAAS,OAAO,CAAC;EACzB,YAAY,QAAQD,sBAAqB;EACzC,WAAW;EACX,QAAQ,MAAM,gBAAgB;EAC9B,cAAc,MAAM,eAAe;AACpC,CAAC;AAIM,SAAS,2BACf,iBAC8B;AAC9B,QAAM,SAAiD,gBAAgB,OAAO;IAC7E,CAAC,OAAO,UAAU;AACjB,UAAI,MAAM,QAAQ;AACjB,eAAO;UACN,MAAM;UACN;UACA,OAAO;YACN,QAAQ,MAAM,OAAO,mBAClB;cACA,YAAY,MAAM,OAAO;YAC1B,IACC,MAAM,OAAO,YACZ;cACA,WAAW;gBACV,QAAQ,MAAM,OAAO,UAAU;gBAC/B,SAAS,MAAM,OAAO,UAAU;gBAChC,UAAU,MAAM,OAAO,UAAU;cAClC;YACD,IACC;cACA,QAAQ;gBACP,SAAS,MAAM,OAAO,aAAa;gBACnC,sBAAsB,MAAM,OAAO,aAAa;gBAChD,UAAU,MAAM,OAAO,aAAa;cACrC;YACD;UACJ;UACA,MAAM;QACP;MACD;AACA,UAAI,MAAM,MAAM;AACf,eAAO;UACN,MAAM;UACN;UACA,OAAO;YACN,MAAM,MAAM,KAAK,WAAW,MAAM,KAAK,KAAK,CAAC;UAC9C;UACA,MAAM;QACP;MACD;AAEA,UAAI,MAAM,gBAAgB;AACzB,eAAO;UACN,MAAM;UACN,MAAM;UACN;UACA,OAAO,MAAM,eAAe;QAC7B;MACD;AAEA,UAAI,MAAM,kBAAkB;AAC3B,eAAO;UACN,MAAM;UACN,MAAM;UACN;UACA,OAAO,MAAM,iBAAiB;QAC/B;MACD;AAEA,YAAM,IAAI,MAAM,eAAe;IAChC;EACD;AAEA,SAAO;IACN,SAAS;IACT,QAAQ,gBAAgB,UAAU;IAClC,YACC,gBAAgB,YAAY,UAAU,UACnC,EAAE,OAAO,OAAO,gBAAgB,WAAW,KAAK,EAAE,IAClD,gBAAgB,aACf,EAAE,MAAM,KAAK,IACb;IACL,WAAW;MACV,OAAO,gBAAgB,QAAQ,SAAS;MACxC,QAAQ,gBAAgB,QAAQ,UAAU;MAC1C,OAAO,gBAAgB,QAAQ,SAAS;MACxC,SAAS,gBAAgB,QAAQ,WAAW;IAC7C;IACA;IACA,cAAc,gBAAgB,SAAS,IAAI,CAAC,YAAiD;AAC5F,UAAI,QAAQ,aAAa;AACxB,eAAO;UACN,MAAM;UACN,MACC,QAAQ,YAAY,SAAS,OAC1B,EAAE,MAAM,KAAK,IACb,EAAE,MAAM,kBAAkB,aAAa,QAAQ,YAAY,IAAI,EAAE;UACrE,SAAS,QAAQ,YAAY,SAAS;YAAI,CAAC,QAC1C,2BAA2B,KAAK,MAAM;UACvC;QACD;MACD;AACA,UAAI,QAAQ,YAAY;AACvB,eAAO;UACN,MAAM;UACN,aAAa,2BAA2B,QAAQ,WAAW,aAAa,MAAM;UAC9E,SAAS,QAAQ,WAAW,QAAQ,IAAI,CAAC,QAAQ,2BAA2B,KAAK,MAAM,CAAC;QACzF;MACD;AACA,UAAI,QAAQ,UAAU;AACrB,eAAO;UACN,MAAM;UACN,QAAQ,GAAG,QAAQ,SAAS,OAAO,KAAK,QAAQ,SAAS,MAAM,KAAK,QAAQ,SAAS,QAAQ;UAC7F,eAAe,QAAQ,SAAS;UAChC,WAAW,QAAQ,SAAS,UAAU;YAAI,CAAC,QAC1C,2BAA2B,KAAK,MAAM;UACvC;QACD;MACD;AACA,UAAI,QAAQ,SAAS;AACpB,eAAO;UACN,MAAM;UACN,SAAS,QAAQ,QAAQ,QAAQ,IAAI,CAAC,QAAQ,MAAM,KAAK,WAAW,GAAG,CAAC,CAAC;UACzE,cAAc,QAAQ,QAAQ;QAC/B;MACD;AACA,UAAI,QAAQ,YAAY;AACvB,eAAO;UACN,MAAM;UACN,MAAM,2BAA2B,QAAQ,WAAW,MAAM,MAAM;UAChE,SAAS,QAAQ,WAAW,QAAQ,IAAI,CAAC,QAAQ,2BAA2B,KAAK,MAAM,CAAC;QACzF;MACD;AACA,UAAI,QAAQ,iBAAiB;AAC5B,eAAO;UACN,MAAM;UACN,SAAS,QAAQ,gBAAgB,QAAQ;YAAI,CAAC,QAC7C,2BAA2B,KAAK,MAAM;UACvC;UACA,SAAS,2BAA2B,QAAQ,gBAAgB,SAAS,MAAM;QAC5E;MACD;AAEA,UAAI,QAAQ,SAAS;AACpB,eAAO;UACN,MAAM;UACN,SAAS,QAAQ,QAAQ,QAAQ,IAAI,CAAC,QAAQ,MAAM,KAAK,WAAW,GAAG,CAAC,CAAC;UACzE,cAAc,QAAQ,QAAQ;UAC9B,WAAW,QAAQ,QAAQ;UAC3B,QAAQ,2BAA2B,QAAQ,QAAQ,QAAQ,MAAM;QAClE;MACD;AAEA,YAAM,IAAI,MAAM,uBAAuB,OAAO,KAAK,OAAO,CAAC,EAAE;IAC9D,CAAC;EACF;AACD;AAEA,SAAS,2BACR,KACA,QAC0C;AAC1C,MAAI,IAAI,UAAU,WAAW;AAC5B,WAAO,EAAE,MAAM,UAAU;EAC1B;AACA,MAAI,IAAI,UAAU,UAAU;AAC3B,WAAO,EAAE,MAAM,UAAU,OAAO,IAAI,OAAO;EAC5C;AACA,MAAI,IAAI,UAAU,gBAAgB;AACjC,WAAO,EAAE,MAAM,gBAAgB,OAAO,IAAI,aAAa,CAAC,GAAG,aAAa,IAAI,aAAa,CAAC,EAAE;EAC7F;AACA,MAAI,IAAI,UAAU,SAAS;AAC1B,WAAO,OAAO,IAAI,KAAK;EACxB;AAEA,QAAM,IAAI,MAAM,oBAAoB,OAAO,KAAK,GAAG,CAAC,EAAE;AACvD;AAEO,SAAS,sBAAsB,MAAoD;AACzF,SAAO,MAAM,uBAAuB;IACnC,SAAS;IACT,QAAQ,KAAK,UAAU;IACvB,YAAY,KAAK,aACd,WAAW,KAAK,aACf,EAAE,OAAO,KAAK,WAAW,MAAM,IAC/B,EAAE,MAAM,KAAK,IACd;IACH,SAAS;MACR,OAAO,KAAK,UAAU,SAAS;MAC/B,QAAQ,KAAK,UAAU,QAAQ,SAAS,KAAK;MAC7C,OAAO,KAAK,UAAU,OAAO,SAAS,KAAK;MAC3C,SACC,KAAK,UAAU,SAAS,IAAI,CAAC,SAAS;QACrC,QAAQ,IAAI;QACZ,UAAU,IAAI;QACd,SAAS,IAAI,QAAQ,SAAS;MAC/B,EAAE,KAAK;IACT;IACA,QAAQ,KAAK,OAAO,IAAI,CAAC,UAAU;AAClC,UAAI,MAAM,SAAS,SAAS;AAC3B,YAAI,GAAGD,oBAAmB,MAAM,KAAK,GAAG;AACvC,gBAAM,QAAQ,MAAMA,oBAAmB,MAAM,KAAK;AAElD,cAAI,MAAM,QAAQ;AACjB,gBAAI,MAAM,OAAO,YAAY;AAC5B,qBAAO;gBACN,QAAQ;kBACP,kBAAkB;oBACjB,UAAU,MAAM,OAAO,WAAW;oBAClC,SAAS,OAAO,MAAM,OAAO,WAAW,OAAO;oBAC/C,QAAQ,MAAM,OAAO,WAAW;kBACjC;gBACD;cACD;YACD;AACA,gBAAI,MAAM,OAAO,QAAQ;AACxB,qBAAO;gBACN,QAAQ;kBACP,cAAc;oBACb,SAAS,MAAM,OAAO,OAAO,WAAW;oBACxC,sBAAsB,MAAM,OAAO,OAAO;oBAC1C,UAAU,MAAM,OAAO,OAAO;kBAC/B;gBACD;cACD;YACD;AACA,gBAAI,MAAM,OAAO,WAAW;AAC3B,qBAAO;gBACN,QAAQ;kBACP,WAAW;oBACV,QAAQ,MAAM,OAAO,UAAU;oBAC/B,SAAS,OAAO,MAAM,OAAO,UAAU,OAAO;oBAC9C,UAAU,MAAM,OAAO,UAAU;kBAClC;gBACD;cACD;YACD;AAEA,kBAAM,IAAI,MAAM,sBAAsB;UACvC;AAEA,iBAAO;YACN,MAAM;cACL,OAAO,SAAS,IAAI,WAAW,MAAM,IAAI,CAAC;YAC3C;UACD;QACD;AAEA,YAAI,MAAM,SAAS,UAAU;AAC5B,iBAAO;YACN,kBAAkB;cACjB,UAAU,MAAM;YACjB;UACD;QACD;AAEA,eAAO;UACN,gBAAgB;YACf,OAAO,MAAM;UACd;QACD;MACD;AAEA,YAAM,IAAI,MAAM,eAAe;IAChC,CAAC;IACD,UAAU,KAAK,aAAa,IAAI,CAAC,gBAAgB;AAChD,cAAQ,YAAY,MAAM;QACzB,KAAK;AACJ,iBAAO;YACN,aAAa;cACZ,MACC,UAAU,YAAY,OACnB,kBAAkB,YAAY,YAAY,KAAK,IAAI,IACnD;cACJ,UAAU,YAAY,QAAQ,IAAI,CAAC,QAAQ,2BAA2B,GAAG,CAAC;YAC3E;UACD;QACD,KAAK,cAAc;AAClB,iBAAO;YACN,YAAY;cACX,aAAa,2BAA2B,YAAY,WAAW;cAC/D,SAAS,YAAY,QAAQ,IAAI,CAAC,QAAQ,2BAA2B,GAAG,CAAC;YAC1E;UACD;QACD;QACA,KAAK,YAAY;AAChB,gBAAM,CAAC,KAAK,KAAK,EAAE,IAAI,YAAY,OAAO,MAAM,IAAI;AACpD,iBAAO;YACN,UAAU;cACT,SAAS;cACT,QAAQ;cACR,UAAU;cACV,eAAe,YAAY;cAC3B,WAAW,YAAY,UAAU,IAAI,CAAC,QAAQ,2BAA2B,GAAG,CAAC;YAC9E;UACD;QACD;QACA,KAAK,WAAW;AACf,iBAAO;YACN,SAAS;cACR,SAAS,YAAY,QAAQ,IAAI,CAAC,QAAQ,SAAS,WAAW,KAAK,GAAG,CAAC,CAAC;cACxE,cAAc,YAAY;YAC3B;UACD;QACD;QACA,KAAK,cAAc;AAClB,iBAAO;YACN,YAAY;cACX,MAAM,2BAA2B,YAAY,IAAI;cACjD,SAAS,YAAY,QAAQ,IAAI,CAAC,QAAQ,2BAA2B,GAAG,CAAC;YAC1E;UACD;QACD;QACA,KAAK,mBAAmB;AACvB,iBAAO;YACN,iBAAiB;cAChB,SAAS,YAAY,QAAQ,IAAI,CAAC,QAAQ,2BAA2B,GAAG,CAAC;cACzE,SAAS,2BAA2B,YAAY,OAAO;YACxD;UACD;QACD;QACA,KAAK,WAAW;AACf,iBAAO;YACN,SAAS;cACR,SAAS,YAAY,QAAQ,IAAI,CAAC,QAAQ,SAAS,WAAW,KAAK,GAAG,CAAC,CAAC;cACxE,cAAc,YAAY;cAC1B,SAAS,YAAY;cACrB,QAAQ,2BAA2B,YAAY,MAAM;YACtD;UACD;QACD;MACD;AAEA,YAAM,IAAI,MAAM,uBAAuB,OAAO,KAAK,WAAW,CAAC,EAAE;IAClE,CAAC;EACF,CAAoD;AACrD;AAEA,SAAS,2BACR,KACoC;AACpC,UAAQ,IAAI,MAAM;IACjB,KAAK,WAAW;AACf,aAAO,EAAE,SAAS,KAAK;IACxB;IACA,KAAK;AACJ,aAAO,EAAE,QAAQ,IAAI,MAAM;IAC5B,KAAK,gBAAgB;AACpB,aAAO,EAAE,cAAc,CAAC,IAAI,OAAO,IAAI,WAAW,EAAE;IACrD;IACA,KAAK,SAAS;AACb,aAAO,EAAE,OAAO,IAAI,MAAM;IAC3B;EACD;AACD;;;ACxhBO,SAAS,cAAc,SAAiB,MAA8B;AAC5E,QAAM,eAAe,MAAM,KAAK,GAAG,OAAO,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AAE1E,QAAM,cAAc,IAAI,WAAW,aAAa,SAAS,KAAK,MAAM;AACpE,cAAY,IAAI,YAAY;AAC5B,cAAY,IAAI,MAAM,aAAa,MAAM;AAEzC,SAAOI,SAAQ,aAAa,EAAE,OAAO,GAAG,CAAC;AAC1C;;;ACKA,SAAS,kBAAkB,SAAiB;AAC3C,SAAO,oBAAoB,OAAO,EAAE,QAAQ,MAAM,EAAE;AACrD;AAEO,IAAM,yBAAN,MAAM,wBAAkD;EAkF9D,YAAY,OAAyB;AAPrC,SAAA,UAAU;AAQT,SAAK,SAAS,OAAO,UAAU;AAC/B,SAAK,aAAa,OAAO,cAAc;AACvC,SAAK,SAAS,OAAO,UAAU,CAAC;AAChC,SAAK,WAAW,OAAO,YAAY,CAAC;AACpC,SAAK,UAAU,OAAO,WAAW;MAChC,QAAQ;MACR,OAAO;MACP,OAAO;MACP,SAAS;IACV;EACD;EA5FA,OAAO,cAAc,OAAmB;AACvC,UAAM,OAAO,OAAI,gBAAgB,MAAM,KAAK;AAE5C,UAAM,iBAAiB,KAAK;AAC5B,QAAI,CAAC,gBAAgB;AACpB,YAAM,IAAI,MAAM,mCAAmC;IACpD;AAEA,WAAO,wBAAuB,QAAQ;MACrC,SAAS;MACT,QAAQ;MACR,YAAY;MACZ,SAAS;QACR,QAAQ;QACR,OAAO;QACP,SAAS;QACT,OAAO;MACR;MACA,QAAQ,eAAe;MACvB,UAAU,eAAe;IAC1B,CAAC;EACF;EAEA,OAAO,UAAU,OAAmB;AACnC,UAAM,UAAU,OAAI,gBAAgB,MAAM,KAAK;AAC/C,UAAM,OAAO,SAAS;AACtB,UAAM,iBAAiB,KAAK,KAAK;AAEjC,QAAI,CAAC,QAAQ,CAAC,gBAAgB;AAC7B,YAAM,IAAI,MAAM,mCAAmC;IACpD;AAEA,WAAO,wBAAuB,QAAQ;MACrC,SAAS;MACT,QAAQ,KAAK;MACb,YAAY,KAAK;MACjB,SAAS,KAAK;MACd,QAAQ,eAAe;MACvB,UAAU,eAAe;IAC1B,CAAC;EACF;EAEA,OAAO,QACN,MAGC;AACD,QAAI,KAAK,YAAY,GAAG;AACvB,aAAO,IAAI,wBAAuB,MAAM,uBAAuB,IAAI,CAAC;IACrE,OAAO;AACN,aAAO,IAAI,wBAAuB,MAAM,uBAAuB,sBAAsB,IAAI,CAAC,CAAC;IAC5F;EACD;;;;;;;EAQA,OAAO,mBAAmB,OAAmB;AAC5C,UAAM,OAAO,cAAc,mBAAmB,KAAK;AACnD,WAAO,SAAS,IAAI;EACrB;;EAGA,IAAI,YAAY;AACf,WAAO,KAAK;EACb;;EAEA,IAAI,UAAU,OAAO;AACpB,SAAK,UAAU;EAChB;EAsBA,MAAM;IACL,eAAe;IACf;IACA;EACD,IAUI,CAAC,GAAG;AAEP,UAAM,SAAS,KAAK;AACpB,UAAM,WAAW,KAAK;AAKtB,UAAM,OAAO;MACZ,yBAAyB;QACxB;QACA;MACD;IACD;AAEA,QAAI,qBAAqB;AACxB,aAAO,OAAI,gBAAgB,UAAU,MAAM,EAAE,SAAS,aAAa,CAAC,EAAE,QAAQ;IAC/E;AAEA,UAAM,aAAa,WAAW,cAAc,KAAK;AACjD,UAAM,SAAS,WAAW,UAAU,KAAK;AACzC,UAAM,UAAU,EAAE,GAAG,KAAK,SAAS,GAAG,WAAW,WAAW,GAAG,WAAW,QAAQ;AAElF,QAAI,CAAC,QAAQ;AACZ,YAAM,IAAI,MAAM,4BAA4B;IAC7C;AAEA,QAAI,CAAC,QAAQ,QAAQ;AACpB,YAAM,IAAI,MAAM,oBAAoB;IACrC;AAEA,QAAI,CAAC,QAAQ,SAAS;AACrB,YAAM,IAAI,MAAM,qBAAqB;IACtC;AAEA,QAAI,CAAC,QAAQ,OAAO;AACnB,YAAM,IAAI,MAAM,mBAAmB;IACpC;AAEA,UAAM,kBAAkB;MACvB,QAAQ,kBAAkB,MAAM;MAChC,YAAY,aAAa,aAAa,EAAE,MAAM,KAAK;MACnD,SAAS;QACR,SAAS,QAAQ;QACjB,OAAO,kBAAkB,KAAK,QAAQ,SAAS,MAAM;QACrD,OAAO,OAAO,QAAQ,KAAK;QAC3B,QAAQ,OAAO,QAAQ,MAAM;MAC9B;MACA,MAAM;QACL,yBAAyB;UACxB;UACA;QACD;MACD;IACD;AAEA,WAAO,OAAI,gBAAgB;MAC1B,EAAE,IAAI,gBAAgB;MACtB,EAAE,SAAS,aAAa;IACzB,EAAE,QAAQ;EACX;EAEA,SAAsC,MAAS,KAAc;AAC5D,UAAM,QAAQ,KAAK,OAAO;AAC1B,SAAK,OAAO,KAAK,GAAG;AACpB,WAAO,EAAE,OAAO,OAAO,MAAM,OAAO,QAAiB;EACtD;EAEA,aAAa,OAAe,IAA+C;AAC1E,SAAK,aAAa,CAAC,KAAK,YAAY;AACnC,UAAI,IAAI,UAAU,WAAW,IAAI,UAAU,OAAO;AACjD,WAAG,KAAK,OAAO;MAChB;AAEA,aAAO;IACR,CAAC;EACF;EAEA,oBACC,OACA,IACC;AACD,UAAM,UAAU,KAAK,SAAS,KAAK;AAEnC,YAAQ,QAAQ,OAAO;MACtB,KAAK;AACJ,gBAAQ,SAAS,YAAY,QAAQ,SAAS,UAAU;UAAI,CAAC,QAC5D,GAAG,KAAK,SAAS,KAAK;QACvB;AACA;MACD,KAAK;AACJ,gBAAQ,gBAAgB,UAAU,QAAQ,gBAAgB,QAAQ;UAAI,CAAC,QACtE,GAAG,KAAK,SAAS,KAAK;QACvB;AACA,gBAAQ,gBAAgB,UAAU,GAAG,QAAQ,gBAAgB,SAAS,SAAS,KAAK;AACpF;MACD,KAAK;AACJ,gBAAQ,WAAW,OAAO,GAAG,QAAQ,WAAW,MAAM,SAAS,KAAK;AACpE,gBAAQ,WAAW,UAAU,QAAQ,WAAW,QAAQ;UAAI,CAAC,QAC5D,GAAG,KAAK,SAAS,KAAK;QACvB;AACA;MACD,KAAK;AACJ,gBAAQ,WAAW,cAAc,GAAG,QAAQ,WAAW,aAAa,SAAS,KAAK;AAClF,gBAAQ,WAAW,UAAU,QAAQ,WAAW,QAAQ;UAAI,CAAC,QAC5D,GAAG,KAAK,SAAS,KAAK;QACvB;AACA;MACD,KAAK;AACJ,gBAAQ,YAAY,WAAW,QAAQ,YAAY,SAAS;UAAI,CAAC,QAChE,GAAG,KAAK,SAAS,KAAK;QACvB;AACA;MACD,KAAK;AACJ,gBAAQ,QAAQ,SAAS,GAAG,QAAQ,QAAQ,QAAQ,SAAS,KAAK;AAClE;MACD,KAAK;AACJ,cAAM,SAAS,QAAQ,QAAQ;AAC/B,gBAAQ,QAAQ,SAAS,CAAC;AAE1B,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,kBAAQ,QAAQ,OAAO,GAAG,IAAI,MAAM,QAAQ,KAAK,IAC9C,MAAM,IAAI,CAAC,QAAQ,GAAG,KAAK,SAAS,KAAK,CAAC,IAC1C,GAAG,OAAO,SAAS,KAAK;QAC5B;AAEA;MACD,KAAK;AACJ;MACD;AACC,cAAM,IAAI,MAAM,gCAAiC,QAA+B,KAAK,EAAE;IACzF;EACD;EAEA,aAAa,IAAyE;AACrF,eAAW,gBAAgB,KAAK,SAAS,KAAK,GAAG;AAChD,WAAK,oBAAoB,cAAc,EAAE;IAC1C;EACD;EAEA,eACC,OACA,aACA,cAAgF,OAC/E;AACD,QAAI,CAAC,MAAM,QAAQ,WAAW,GAAG;AAChC,WAAK,SAAS,KAAK,IAAI;AACvB;IACD;AAEA,UAAM,WAAW,YAAY,SAAS;AAEtC,SAAK,SAAS,OAAO,OAAO,GAAG,GAAG,gBAAgB,WAAW,CAAC;AAE9D,SAAK,aAAa,CAAC,KAAK,UAAU,iBAAiB;AAClD,UAAI,eAAe,QAAQ,YAAY,QAAQ;AAC9C,eAAO;MACR;AAEA,UAAI,OAAO,gBAAgB,UAAU;AACpC,YACE,IAAI,UAAU,YAAY,IAAI,WAAW,SACzC,IAAI,UAAU,kBAAkB,IAAI,aAAa,CAAC,MAAM,OACxD;AACD,cAAI,EAAE,kBAAkB,QAAQ,IAAI,aAAa,CAAC,MAAM,GAAG;AAC1D,mBAAO,MAAM,gBAAgB,gBAAgB,WAAW,CAAC;UAC1D,OAAO;AACN,kBAAM,IAAI;cACT,0BAA0B,KAAK,8CAA8C,KAAK,KAAK,IAAI,aAAa,CAAC,CAAC;YAC3G;UACD;QACD;MACD;AAGA,cAAQ,IAAI,OAAO;QAClB,KAAK;AACJ,cAAI,IAAI,WAAW,SAAS,OAAO,gBAAgB,UAAU;AAC5D,gBAAI,SAAS;UACd;AACA,cAAI,IAAI,SAAS,OAAO;AACvB,gBAAI,UAAU;UACf;AACA;QAED,KAAK;AACJ,cAAI,IAAI,aAAa,CAAC,MAAM,SAAS,OAAO,gBAAgB,UAAU;AACrE,mBAAO;cACN,OAAO;cACP,cAAc,CAAC,aAAa,IAAI,aAAa,CAAC,CAAC;YAChD;UACD;AACA,cAAI,IAAI,aAAa,CAAC,IAAI,OAAO;AAChC,gBAAI,aAAa,CAAC,KAAK;UACxB;AACA;MACF;AACA,aAAO;IACR,CAAC;EACF;EAEA,8BACC,OACA,kBACA,QACC;AACD,QAAI,OAAO,UAAU,YAAY,OAAO,UAAU,gBAAgB;AACjE,YAAM,IAAI,MAAM,+CAA+C;IAChE;AAEA,SAAK,kBAAkB,OAAO,gBAAgB;AAE9C,SAAK;MACJ,QAAQ,iBAAiB,SAAS;MAClC,CAAC;MACD,YAAY,SACT,EAAE,cAAc,CAAC,OAAO,SAAS,OAAO,CAAC,EAAE,IAC3C;QACA,cAAc;UACZ,OAA8C,aAAa,CAAC,IAAI;UAChE,OAA8C,aAAa,CAAC;QAC9D;MACD;IACH;EACD;EAEA,kBAAkB,gBAAwB,kBAAmC;AAC5E,UAAM,eAAe,oBAAI,IAAoB;AAC7C,UAAM,iBAAiB,oBAAI,IAAoB;AAE/C,aAAS,IAAI,GAAG,IAAI,iBAAiB,OAAO,QAAQ,KAAK;AACxD,YAAM,aAAa,iBAAiB,OAAO,CAAC;AAC5C,YAAM,KAAK,iBAAiB,UAAU;AAEtC,UAAI,gBAAgB;AACpB,UAAI,OAAO,QAAW;AACrB,wBAAgB,KAAK,OAAO,UAAU,CAAC,UAAU,iBAAiB,KAAK,MAAM,EAAE;AAE/E,YACC,kBAAkB,MAClB,KAAK,OAAO,aAAa,EAAE,QAAQ,gBACnC,WAAW,QAAQ,cAClB;AACD,eAAK,OAAO,aAAa,EAAE,OAAQ,aAAc,UAChD,KAAK,OAAO,aAAa,EAAE,OAAQ,aAAc,WACjD,WAAW,OAAO,aAAa;QACjC;MACD;AAEA,UAAI,kBAAkB,IAAI;AACzB,qBAAa,IAAI,GAAG,aAAa;MAClC,OAAO;AACN,cAAM,WAAW,KAAK,OAAO;AAC7B,aAAK,OAAO,KAAK,UAAU;AAC3B,qBAAa,IAAI,GAAG,QAAQ;MAC7B;IACD;AAEA,aAAS,IAAI,GAAG,IAAI,iBAAiB,SAAS,QAAQ,KAAK;AAC1D,qBAAe,IAAI,GAAG,iBAAiB,CAAC;IACzC;AAEA,UAAM,mBAA8B,CAAC;AACrC,aAAS,IAAI,GAAG,IAAI,iBAAiB,SAAS,QAAQ,KAAK;AAC1D,YAAM,UAAU,gBAAgB,iBAAiB,SAAS,CAAC,CAAC;AAE5D,4BAAsB,SAAS,cAAc,cAAc;AAE3D,uBAAiB,KAAK,OAAO;IAC9B;AAEA,SAAK,SAAS,OAAO,gBAAgB,GAAG,GAAG,gBAAgB;AAE3D,UAAM,WAAW,iBAAiB;AAClC,QAAI,WAAW,GAAG;AACjB,WAAK,aAAa,CAAC,KAAK,UAAU,iBAAiB;AAClD,YACC,gBAAgB,kBAChB,eAAe,iBAAiB,iBAAiB,QAChD;AACD,iBAAO;QACR;AAEA,gBAAQ,IAAI,OAAO;UAClB,KAAK;AACJ,gBAAI,IAAI,UAAU,gBAAgB;AACjC,kBAAI,UAAU;YACf;AACA;UAED,KAAK;AACJ,gBAAI,IAAI,aAAa,CAAC,KAAK,gBAAgB;AAC1C,kBAAI,aAAa,CAAC,KAAK;YACxB;AACA;QACF;AACA,eAAO;MACR,CAAC;IACF;EACD;EAEA,YAAY;AACX,UAAM,QAAQ,KAAK,MAAM,EAAE,qBAAqB,MAAM,CAAC;AACvD,WAAO,wBAAuB,mBAAmB,KAAK;EACvD;EAEA,WAA4B;AAC3B,WAAO,MAAM,uBAAuB,IAAI;EACzC;EAEA,eAAe;AACd,WAAO,IAAI,wBAAuB;MACjC,SAAS,KAAK;MACd,QAAQ,KAAK;MACb,YAAY,KAAK;MACjB,SAAS;QACR,GAAG,KAAK;MACT;MACA,QAAQ,CAAC,GAAG,KAAK,MAAM;MACvB,UAAU,CAAC,GAAG,KAAK,QAAQ;IAC5B,CAAC;EACF;EAEA,kBAAkB,UAA2B;AAC5C,QAAI,CAAC,KAAK,QAAQ;AACjB,WAAK,SAAS,SAAS,UAAU;IAClC;AAEA,QAAI,CAAC,KAAK,YAAY;AACrB,WAAK,aAAa,SAAS,cAAc;IAC1C;AAEA,QAAI,CAAC,KAAK,QAAQ,QAAQ;AACzB,WAAK,QAAQ,SAAS,SAAS,QAAQ;IACxC;AAEA,QAAI,CAAC,KAAK,QAAQ,OAAO;AACxB,WAAK,QAAQ,QAAQ,SAAS,QAAQ,SAAS;IAChD;AAEA,QAAI,CAAC,KAAK,QAAQ,SAAS;AAC1B,WAAK,QAAQ,UAAU,SAAS,QAAQ;IACzC;AAEA,QAAI,CAAC,KAAK,QAAQ,OAAO;AACxB,WAAK,QAAQ,QAAQ,SAAS,QAAQ;IACvC;AAEA,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KAAK;AAC5C,YAAM,QAAQ,KAAK,OAAO,CAAC;AAC3B,YAAM,gBAAgB,SAAS,OAAO,CAAC;AAEvC,cAAQ,MAAM,OAAO;QACpB,KAAK;AACJ,cAAI,cAAc,UAAU,QAAQ;AACnC,kBAAM,IAAI;cACT,2BAA2B,CAAC,2CAA2C,KAAK;gBAC3E;cACD,CAAC;YACF;UACD;AACA,eAAK,OAAO,CAAC,IAAI;AACjB;QACD,KAAK;AACJ,cAAI,cAAc,UAAU,UAAU;AACrC,kBAAM,IAAI;cACT,2BAA2B,CAAC,8CAA8C,KAAK;gBAC9E;cACD,CAAC;YACF;UACD;AAEA,cACC,cAAc,OAAO,UAAU,sBAC/B,cAAc,OAAO,UAAU,aAC9B;AACD,kBAAM,WAAW,MAAM;AACvB,kBAAMC,YACL,cAAc,OAAO,oBAAoB,cAAc,OAAO;AAE/D,gBACC,oBAAoB,SAAS,QAAQ,MAAM,oBAAoBA,UAAS,QAAQ,KAC/E,SAAS,WAAW,QAAQ,SAAS,YAAYA,UAAS,WAC1D,SAAS,UAAU,QAAQ,SAAS,WAAWA,UAAS;YAEzD,SAAS,WAAW,QACpB,SAAS,wBAAwB,MAChC;AACD,oBAAM,IAAI;gBACT,kBAAkB,CAAC,qCAAqC,KAAK,UAAU,QAAQ,CAAC,2BAA2B,KAAK,UAAUA,SAAQ,CAAC;cACpI;YACD;UACD,WAAW,cAAc,OAAO,UAAU,gBAAgB;AACzD,kBAAM,WAAW,MAAM;AACvB,kBAAMA,YAAW,cAAc,OAAO;AAEtC,gBACC,oBAAoB,SAAS,QAAQ,MAAM,oBAAoBA,UAAS,QAAQ,KAC/E,SAAS,wBAAwB,QACjC,SAAS,yBAAyBA,UAAS,wBAC3C,SAAS,WAAW,QAAQ,SAAS,YAAYA,UAAS;YAE3D,SAAS,WAAW,QACpB,SAAS,UAAU,MAClB;AACD,oBAAM,IAAI;gBACT,kBAAkB,CAAC,qCAAqC,KAAK,UAAU,QAAQ,CAAC,2BAA2B,KAAK,UAAUA,SAAQ,CAAC;cACpI;YACD;UACD,OAAO;AACN,kBAAM,IAAI;cACT,kBAAkB,CAAC,2CAA2C,KAAK;gBAClE,cAAc;cACf,CAAC;YACF;UACD;AAEA,eAAK,OAAO,CAAC,IAAI;AACjB;MACF;IACD;EACD;AACD;;;;;;;;;;AC/iBA,IAAA;AAAA,IAAA;AAQO,IAAM,eAAN,MAAMC,cAAY;EAIxB,YAAY,EAAE,QAAQ,MAAM,IAAwB,CAAC,GAAG;AAHxD,IAAAC,cAAA,MAAA,OAAA;AACA,IAAAA,cAAA,MAAA,MAAA;AAGC,IAAAC,cAAA,MAAK,SAAU,UAAU,CAAC,CAAA;AAC1B,IAAAA,cAAA,MAAK,QAAS,SAAS,oBAAI,IAAI,CAAA;EAChC;EAEA,KAAQ,KAA4B,MAA4C;AAC/E,UAAM,WAAW,CAACC,cAAA,MAAK,OAAA,GAAS,GAAG,GAAG,EAAE,KAAK,GAAG;AAEhD,QAAIA,cAAA,MAAK,MAAA,EAAO,IAAI,QAAQ,GAAG;AAC9B,aAAOA,cAAA,MAAK,MAAA,EAAO,IAAI,QAAQ;IAChC;AAEA,UAAM,SAAS,KAAK;AAEpB,IAAAA,cAAA,MAAK,MAAA,EAAO,IAAI,UAAU,MAAM;AAEhC,QAAI,OAAO,WAAW,YAAY,WAAW,QAAQ,UAAU,QAAQ;AACtE,aAAO,QAAQ,QAAQ,MAAM,EAC3B,KAAK,CAAC,MAAM;AACZ,QAAAA,cAAA,MAAK,MAAA,EAAO,IAAI,UAAU,CAAC;AAC3B,eAAO;MACR,CAAC,EACA,MAAM,CAAC,QAAQ;AACf,QAAAA,cAAA,MAAK,MAAA,EAAO,OAAO,QAAQ;AAC3B,cAAM;MACP,CAAC;IACH;AAEA,WAAO;EACR;EAEA,SAAY,KAA4B,MAAkB;AACzD,UAAM,WAAW,CAACA,cAAA,MAAK,OAAA,GAAS,GAAG,GAAG,EAAE,KAAK,GAAG;AAEhD,QAAIA,cAAA,MAAK,MAAA,EAAO,IAAI,QAAQ,GAAG;AAC9B,aAAOA,cAAA,MAAK,MAAA,EAAO,IAAI,QAAQ;IAChC;AAEA,UAAM,SAAS,KAAK;AAEpB,IAAAA,cAAA,MAAK,MAAA,EAAO,IAAI,UAAU,MAAM;AAEhC,WAAO;EACR;EAEA,MAAM,QAAmB;AACxB,UAAM,YAAY,CAAC,GAAGA,cAAA,MAAK,OAAA,GAAS,GAAI,UAAU,CAAC,CAAE,EAAE,KAAK,GAAG;AAC/D,QAAI,CAAC,WAAW;AACf,MAAAA,cAAA,MAAK,MAAA,EAAO,MAAM;AAClB;IACD;AAEA,eAAW,OAAOA,cAAA,MAAK,MAAA,EAAO,KAAK,GAAG;AACrC,UAAI,IAAI,WAAW,SAAS,GAAG;AAC9B,QAAAA,cAAA,MAAK,MAAA,EAAO,OAAO,GAAG;MACvB;IACD;EACD;EAEA,MAAM,QAA2B;AAChC,WAAO,IAAIH,cAAY;MACtB,QAAQ,CAAC,GAAGG,cAAA,MAAK,OAAA,GAAS,GAAI,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,MAAM,CAAE;MACxE,OAAOA,cAAA,MAAK,MAAA;IACb,CAAC;EACF;AACD;AApEC,UAAA,oBAAA,QAAA;AACA,SAAA,oBAAA,QAAA;AAFM,IAAM,cAAN;;;ACHA,IAAM,kBAAkB;AACxB,IAAM,uBAAuB;;;;;;;;;;;ACNpC,IAAAC;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAiBA,IAAMC,kBAAiB;AACvB,IAAM,iBAAiB;EACtB,cAAc,eAAe,eAAe;AAC7C;AAYO,IAAM,YAAN,MAAkE;EASxE,YAAY,EAAE,OAAO,KAAAC,MAAK,WAAW,IAAI,UAAU,GAAqB;AATlE,IAAAC,cAAA,MAAA,oBAAA;AACN,IAAAA,cAAA,MAAAH,OAAA;AACA,IAAAG,cAAA,MAAA,IAAA;AACA,IAAAA,cAAA,MAAA,SAAA;AACA,IAAAA,cAAA,MAAA,UAAA;AAMC,IAAAC,cAAA,MAAKJ,SAAS,KAAA;AACd,IAAAI,cAAA,MAAK,MAAOF,IAAA;AACZ,IAAAE,cAAA,MAAK,WAAY,QAAA;AACjB,IAAAA,cAAA,MAAK,YAAa;MACjB,UAAU,WAAW;MACrB,OAAO,WAAW;IACnB,CAAA;AAEA,sBAAkBC,cAAA,MAAK,UAAA,CAAU;EAClC;EAsIA,MAAM,eAAe;IACpB,SAAS;EACV,GAAyH;AACxH,QAAI,CAAC,WAAW,IAAI,GAAG;AACtB,aAAO;QACN,SAAS;MACV;IACD;AACA,UAAM,WAAW,MAAMA,cAAA,MAAK,sBAAA,wBAAA,EAAsB,KAAK,IAAI;AAC3D,WAAO;MACN,SAAS;IACV;EACD;EAEA,MAAM,YAAY;IACjB;EACD,GAAmH;AAClH,QAAI,CAAC,WAAW,IAAI,GAAG;AACtB,aAAO;QACN;MACD;IACD;AAEA,UAAM,WAAW,CAAC,GAAG,gBAAgB,IAAI,CAAC;AAC1C,UAAM,gBAAgB,MAAMA,cAAA,MAAK,sBAAA,qBAAA,EAAmB,SAAS,QAAQ;AAErE,UAAM,UAAkC,CAAC;AAEzC,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACzC,YAAM,eAAe,cAAc,CAAC;AACpC,UAAI,wBAAwB,OAAO;AAClC,cAAM;MACP;AACA,cAAQ,SAAS,CAAC,CAAC,IAAI;IACxB;AAEA,WAAO;MACN,MAAM,gBAAgB,MAAM,OAAO;IACpC;EACD;EAEA,MAAM,QAAQ;IACb,QAAQ,CAAC;IACT,WAAW,CAAC;EACb,GAA2G;AAC1G,UAAM,WAAW,oBAAI,IAAY;AAEjC,eAAW,QAAQ,SAAS,CAAC,GAAG;AAC/B,sBAAgB,MAAM,QAAQ;IAC/B;AAEA,UAAM,aAAa,CAAC,GAAG,QAAQ;AAC/B,UAAM,CAAC,eAAe,gBAAgB,IAAI,MAAM,QAAQ,IAAI;MAC3D,WAAW,SAAS,IAAIA,cAAA,MAAK,sBAAA,qBAAA,EAAmB,SAAS,UAAU,IAAI,CAAC;MACxE,SAAS,SAAS,IAAIA,cAAA,MAAK,sBAAA,wBAAA,EAAsB,SAAS,QAAQ,IAAI,CAAC;IACxE,CAAC;AAED,UAAM,UAAkC;MACvC,GAAGA,cAAA,MAAK,UAAA,GAAY;IACrB;AAEA,eAAW,CAAC,GAAG,IAAI,KAAK,WAAW,QAAQ,GAAG;AAC7C,YAAM,eAAe,cAAc,CAAC;AACpC,UAAI,wBAAwB,OAAO;AAClC,cAAM;MACP;AACA,cAAQ,IAAI,IAAI;IACjB;AAEA,UAAM,gBAKF,CAAC;AAEL,eAAW,QAAQ,SAAS,CAAC,GAAG;AAC/B,YAAM,eAAe,gBAAgB,MAAM,OAAO;AAElD,oBAAc,IAAI,IAAI;QACrB,MAAM;MACP;IACD;AAEA,UAAM,mBAKF,CAAC;AAEL,eAAW,CAAC,GAAG,GAAG,MAAM,YAAY,CAAC,GAAG,QAAQ,GAAG;AAClD,YAAM,cAAcA,cAAA,MAAK,UAAA,GAAY,WAAW,GAAG,KAAK,iBAAiB,CAAC;AAE1E,UAAI,uBAAuB,OAAO;AACjC,cAAM;MACP;AAEA,uBAAiB,GAAG,IAAI;QACvB,SAAS;MACV;IACD;AAEA,WAAO;MACN,OAAO;MACP,UAAU;IACX;EACD;AACD;AApQCL,UAAA,oBAAA,QAAA;AACA,OAAA,oBAAA,QAAA;AACA,YAAA,oBAAA,QAAA;AACA,aAAA,oBAAA,QAAA;AAJM,uBAAA,oBAAA,QAAA;AAqBF,2BAAqB,WAAG;AAC3B,SAAOK,cAAA,MAAKL,OAAA,EAAO,SAAS,CAAC,yBAAyBK,cAAA,MAAK,IAAA,KAAQ,EAAE,GAAG,MAAM;AAC7E,UAAM,SAAS,IAAI,WAA2B,OAAO,aAAa;AACjE,UAAI,CAACA,cAAA,MAAK,IAAA,GAAM;AACf,cAAM,IAAI;UACT,4DAA4D,SAAS,KAAK,IAAI,CAAC;QAChF;MACD;AACA,YAAM,WAAW,MAAM,gBAAA,MAAK,sBAAA,kBAAA,EAAL,KAAA,MAAsB,QAAA;AAE7C,aAAO,SAAS;QACf,CAAC,QAAQ,SAAS,GAAG,KAAK,IAAI,MAAM,8BAA8B,GAAG,EAAE;MACxE;IACD,CAAC;AACD,UAAM,YAAYA,cAAA,MAAK,UAAA,GAAY;AAEnC,QAAI,WAAW;AACd,iBAAW,CAAC,KAAK,EAAE,KAAK,OAAO,QAAQ,SAAS,GAAG;AAClD,eAAO,MAAM,KAAK,EAAE;MACrB;IACD;AAEA,WAAO;EACR,CAAC;AACF;AAEI,wBAAkB,WAAG;AACxB,SAAOA,cAAA,MAAKL,OAAA,EAAO,SAAS,CAAC,sBAAsBK,cAAA,MAAK,IAAA,KAAQ,EAAE,GAAG,MAAM;AAC1E,UAAM,SAAS,IAAI,WAA2B,OAAO,UAAU;AAC9D,UAAI,CAACA,cAAA,MAAK,IAAA,GAAM;AACf,cAAM,IAAI;UACT,4DAA4D,MAAM,KAAK,IAAI,CAAC;QAC7E;MACD;AACA,YAAM,WAAW,MAAM,gBAAA,MAAK,sBAAA,eAAA,EAAL,KAAA,MAAmB,KAAA;AAE1C,aAAO,MAAM,IAAI,CAAC,SAAS,SAAS,IAAI,KAAK,IAAI,MAAM,2BAA2B,IAAI,EAAE,CAAC;IAC1F,CAAC;AAED,UAAM,YAAYA,cAAA,MAAK,UAAA,GAAY;AAEnC,QAAI,WAAW;AACd,iBAAW,CAAC,MAAM,EAAE,KAAK,OAAO,QAAQ,SAAS,GAAG;AACnD,eAAO,MAAM,MAAM,EAAE;MACtB;IACD;AAEA,WAAO;EACR,CAAC;AACF;AAEM,qBAAgB,eAAC,UAA6B;AACnD,MAAI,SAAS,WAAW,EAAG,QAAO,CAAC;AAEnC,QAAM,UAAU,MAAM,UAAUA,cAAA,MAAK,SAAA,CAAS;AAC9C,QAAM,UAAkC,CAAC;AAEzC,QAAM,QAAQ;IACb,QAAQ,IAAI,OAAO,UAAU;AAC5B,YAAM,OAAO,MAAM,gBAAA,MAAK,sBAAA,QAAA,EAAL,KAAA,MAClB,uBACA;QACC,OAAO;MACR,CAAA;AAGD,UAAI,CAAC,MAAM,WAAY;AAEvB,iBAAW,OAAO,OAAO,KAAK,MAAM,UAAU,GAAG;AAChD,cAAM,UAAU,KAAK,WAAW,GAAG,GAAG;AAEtC,YAAI,CAAC,QAAS;AAEd,gBAAQ,GAAG,IAAI;MAChB;IACD,CAAC;EACF;AAEA,SAAO;AACR;AAEM,kBAAa,eAAC,OAA0B;AAC7C,MAAI,MAAM,WAAW,EAAG,QAAO,CAAC;AAEhC,QAAM,UAAU,MAAM,OAAOA,cAAA,MAAK,SAAA,CAAS;AAC3C,QAAM,UAAkC,CAAC;AAEzC,QAAM,QAAQ;IACb,QAAQ,IAAI,OAAO,UAAU;AAC5B,YAAM,OAAO,MAAM,gBAAA,MAAK,sBAAA,QAAA,EAAL,KAAA,MAClB,8BACA;QACC,OAAO;MACR,CAAA;AAGD,UAAI,CAAC,MAAM,WAAY;AAEvB,iBAAW,QAAQ,OAAO,KAAK,MAAM,UAAU,GAAG;AACjD,cAAM,WAAW,KAAK,WAAW,IAAI,GAAG;AACxC,YAAI,CAAC,SAAU;AAEf,gBAAQ,IAAI,IAAI;MACjB;IACD,CAAC;EACF;AAEA,SAAO;AACR;AAEM,WAAS,eAACH,MAAa,MAA2C;AACvE,MAAI,CAACG,cAAA,MAAK,IAAA,GAAM;AACf,UAAM,IAAI,MAAM,+CAA+C;EAChE;AAEA,QAAM,WAAW,MAAM,MAAM,GAAGA,cAAA,MAAK,IAAA,CAAI,GAAGH,IAAG,IAAI;IAClD,QAAQ;IACR,SAAS;MACR,gBAAgB;MAChB,GAAG;IACJ;IACA,MAAM,KAAK,UAAU,IAAI;EAC1B,CAAC;AAED,MAAI,CAAC,SAAS,IAAI;AACjB,UAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,OAAO,CAAC,EAAE;AACxD,UAAM,IAAI,MAAM,4BAA4B,WAAW,OAAO,EAAE;EACjE;AAEA,SAAO,SAAS,KAAK;AACtB;AAgHD,SAAS,kBAAkB,WAGxB;AACF,MAAI,WAAW,UAAU;AACxB,eAAW,CAAC,KAAK,EAAE,KAAK,OAAO,QAAQ,UAAU,QAAQ,GAAG;AAC3D,UAAI,CAAC,oBAAoB,GAAG,GAAG;AAC9B,cAAM,IAAI,MAAM,yBAAyB,GAAG,EAAE;MAC/C;AACA,UAAI,CAAC,kBAAkB,oBAAoB,EAAE,CAAC,GAAG;AAChD,cAAM,IAAI,MAAM,uBAAuB,EAAE,EAAE;MAC5C;IACD;EACD;AAEA,MAAI,WAAW,OAAO;AACrB,eAAW,CAAC,MAAM,GAAG,KAAK,OAAO,QAAQ,UAAU,KAAK,GAAG;AAE1D,UAAI,eAAe,IAAI,EAAE,WAAW,SAAS,GAAG;AAC/C,cAAM,IAAI;UACT;QACD;MACD;AAEA,YAAM,cAAc,eAAe,GAAG;AAEtC,UAAI,CAAC,kBAAkB,YAAY,OAAO,GAAG;AAC5C,cAAM,IAAI,MAAM,iBAAiB,GAAG,EAAE;MACvC;IACD;EACD;AACD;AAKO,SAAS,gBAAgB,MAA0B,QAAQ,oBAAI,IAAY,GAAG;AACpF,MAAI,OAAO,SAAS,YAAY,CAAC,WAAW,IAAI,EAAG,QAAO;AAE1D,QAAM,MAAM,YAAY,IAAI,IAAI,OAAO,eAAe,IAAI;AAE1D,MAAI,WAAW,IAAI,OAAO,EAAG,OAAM,IAAI,GAAG,IAAI,OAAO,KAAK,IAAI,MAAM,KAAK,IAAI,IAAI,EAAE;AAEnF,aAAW,SAAS,IAAI,YAAY;AACnC,oBAAgB,OAAO,KAAK;EAC7B;AAEA,SAAO;AACR;AAMA,SAAS,gBAAgB,KAAyB,WAA2C;AAC5F,QAAM,OAAO,YAAY,GAAG,IAAI,MAAM,eAAe,GAAG;AAExD,QAAM,UAAU,GAAG,KAAK,OAAO,KAAK,KAAK,MAAM,KAAK,KAAK,IAAI;AAC7D,QAAM,WAAW,UAAU,OAAO;AAElC,SAAO,mBAAmB;IACzB,GAAG;IACH,SAAS,WAAW,SAAS,MAAM,IAAI,EAAE,CAAC,IAAI,KAAK;IACnD,YAAY,KAAK,WAAW,IAAI,CAAC,UAAU,gBAAgB,OAAO,SAAS,CAAC;EAC7E,CAAC;AACF;AAEO,SAAS,WAAW,YAAoB;AAC9C,SACC,WAAW,SAASD,eAAc,KAAK,WAAW,SAAS,GAAG,KAAK,WAAW,SAAS,MAAM;AAE/F;AAEA,SAAS,YAAY,MAA6C;AACjE,SACC,OAAO,SAAS,YAChB,aAAa,QACb,YAAY,QACZ,UAAU,QACV,gBAAgB;AAElB;AAWO,SAAS,uBAAuB,SAGrC;AACD,QAAM,WAAwB,oBAAI,IAAI;AACtC,QAAM,QAAqB,oBAAI,IAAI;AAEnC,aAAW,WAAW,QAAQ,UAAU;AACvC,YAAQ,QAAQ,OAAO;MACtB,KAAK;AACJ,YAAI,QAAQ,YAAY,MAAM;AAC7B,+BAAqB,CAAC,QAAQ,YAAY,IAAI,CAAC,EAAE,QAAQ,CAAC,SAAS;AAClE,kBAAM,IAAI,IAAI;UACf,CAAC;QACF;AACA;MACD,KAAK;AACJ,cAAM,WAAW,QAAQ;AAEzB,cAAM,MAAM,SAAS,QAAQ,MAAM,IAAI,EAAE,CAAC;AAC1C,YAAI,WAAW,GAAG,GAAG;AACpB,cAAI,CAAC,oBAAoB,GAAG,EAAG,OAAM,IAAI,MAAM,yBAAyB,GAAG,EAAE;AAC7E,mBAAS,IAAI,GAAG;QACjB;AAEA,6BAAqB,SAAS,iBAAiB,CAAC,CAAC,EAAE,QAAQ,CAAC,SAAS;AACpE,gBAAM,IAAI,IAAI;QACf,CAAC;AAED;MACD;AACC;IACF;EACD;AAEA,SAAO;IACN,UAAU,CAAC,GAAG,QAAQ;IACtB,OAAO,CAAC,GAAG,KAAK;EACjB;AACD;AAMO,SAAS,aACf,SACA,UACC;AACD,aAAW,WAAW,QAAQ,UAAU;AAEvC,QAAI,QAAQ,aAAa,MAAM;AAC9B,UAAI,CAAC,WAAW,QAAQ,YAAY,IAAI,EAAG;AAC3C,UAAI,CAAC,SAAS,MAAM,QAAQ,YAAY,IAAI;AAC3C,cAAM,IAAI,MAAM,iCAAiC,QAAQ,YAAY,IAAI,EAAE;AAC5E,cAAQ,YAAY,OAAO,SAAS,MAAM,QAAQ,YAAY,IAAI,EAAE;IACrE;AAEA,UAAM,KAAK,QAAQ;AACnB,QAAI,CAAC,GAAI;AAET,UAAM,YAAY,GAAG,QAAQ,MAAM,IAAI;AACvC,UAAM,OAAO,UAAU,CAAC;AAExB,QAAI,WAAW,IAAI,KAAK,CAAC,SAAS,SAAS,IAAI;AAC9C,YAAM,IAAI,MAAM,iCAAiC,IAAI,EAAE;AAGxD,QAAI,WAAW,IAAI,GAAG;AACrB,gBAAU,CAAC,IAAI,SAAS,SAAS,IAAI,EAAE;AACvC,SAAG,UAAU,UAAU,KAAK,IAAI;IACjC;AAEA,UAAM,QAAQ,GAAG;AACjB,QAAI,CAAC,MAAO;AAEZ,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,UAAI,CAAC,WAAW,MAAM,CAAC,CAAC,EAAG;AAE3B,UAAI,CAAC,SAAS,MAAM,MAAM,CAAC,CAAC,EAAG,OAAM,IAAI,MAAM,iCAAiC,MAAM,CAAC,CAAC,EAAE;AAC1F,YAAM,CAAC,IAAI,SAAS,MAAM,MAAM,CAAC,CAAC,EAAE;IACrC;AAEA,OAAG,gBAAgB;EACpB;AACD;AAMA,SAAS,qBAAqB,OAAiB;AAC9C,QAAM,QAAQ,oBAAI,IAAY;AAC9B,aAAW,QAAQ,OAAO;AACzB,QAAI,WAAW,IAAI,GAAG;AACrB,UAAI,CAAC,iBAAiB,IAAI,EAAG,OAAM,IAAI,MAAM,4BAA4B,IAAI,EAAE;AAC/E,YAAM,IAAI,IAAI;IACf;EACD;AACA,SAAO;AACR;;;AC5bA,IAAM,WAAW,oBAAI,QAA6B;AAgB3C,IAAM,sBAAsB,CAAC,YAAyC;AAC5E,MAAI;AAEJ,MAAI,SAAS;AACZ,UAAM,YAAY,QAAQ,aAAa;MACtC,UAAU,CAAC;MACX,OAAO,CAAC;IACT;AAEA,QAAI,CAAC,SAAS,IAAI,SAAS,GAAG;AAC7B,eAAS,IAAI,WAAW,IAAI,YAAY,CAAC;IAC1C;AAEA,gBAAY,IAAI,UAAU;MACzB,OAAO,SAAS,IAAI,SAAS;MAC7B,KAAK,QAAQ;MACb,UAAU,QAAQ;MAClB;IACD,CAAC;EACF;AAEA,SAAO,OACN,iBACA,cACA,SACI;AACJ,UAAM,QAAQ,uBAAuB,eAAe;AAEpD,QAAI,MAAM,MAAM,WAAW,KAAK,MAAM,SAAS,WAAW,GAAG;AAC5D,aAAO,KAAK;IACb;AAEA,UAAM,WAAW,OAAO,aAAa,UAAU,YAAY,EAAE,KAAK,KAAK,QAAQ;MAC9E,OAAO,MAAM;MACb,UAAU,MAAM;IACjB,CAAC;AAED,iBAAa,iBAAiB,QAAQ;AAEtC,UAAM,KAAK;EACZ;AACD;AAEO,SAAS,UAAU,SAAkC;AAC3D,MAAI,CAAC,QAAQ,QAAQ;AACpB,UAAM,IAAI;MACT;IACD;EACD;AAEA,SAAO,QAAQ;AAChB;;;ACpFA,SAAS,UAAwD,SAAY;AAC5E,SAAO;IACN,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,OAAO,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC;EACvE;AAOD;AAGA,IAAMK,YAAW,UAAU;EAC1B,SAAS,QAAQ,IAAI;EACrB,OAAO,KAAK,OAAO,GAAG,QAAQ,CAAC;EAC/B,QAAQ,KAAK,OAAO,GAAG,QAAQ,CAAC;EAChC,cAAc,MAAM,CAAC,KAAK,OAAO,GAAG,QAAQ,CAAC,GAAG,KAAK,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC;AAC3E,CAAC;AAGD,IAAMC,WAAU,OAAO;EACtB,QAAQ,SAAS,OAAO;EACxB,OAAO,SAAS,OAAO;EACvB,OAAO,SAAS,UAAU;EAC1B,SAAS,SAAS,MAAM,eAAe,CAAC;AACzC,CAAC;AAGD,IAAMC,wBAAuB,OAAO;EACnC,SAAS;EACT,QAAQ,OAAO;EACf,UAAU,OAAO;;EAEjB,eAAe,MAAM,OAAO,CAAC;EAC7B,WAAW,MAAMF,SAAQ;AAC1B,CAAC;AAED,IAAMG,WAAU,OAAO;EACtB,MAAM,OAAO;EACb,QAAQ,OAAO,OAAO,GAAG,MAAM,CAACH,WAAU,MAAMA,SAAQ,CAAC,CAAC,CAAC;EAC3D,MAAM,OAAO,OAAO,GAAG,QAAQ,CAAC;AACjC,CAAC;AAGD,IAAMI,WAAU,UAAU;EACzB,UAAUF;EACV,iBAAiB,OAAO;IACvB,SAAS,MAAMF,SAAQ;IACvB,SAASA;EACV,CAAC;EACD,YAAY,OAAO;IAClB,MAAMA;IACN,SAAS,MAAMA,SAAQ;EACxB,CAAC;EACD,YAAY,OAAO;IAClB,aAAaA;IACb,SAAS,MAAMA,SAAQ;EACxB,CAAC;EACD,SAAS,OAAO;IACf,SAAS,MAAM,QAAQ;IACvB,cAAc,MAAM,QAAQ;EAC7B,CAAC;EACD,aAAa,OAAO;IACnB,MAAM,SAAS,OAAO,CAAC;IACvB,UAAU,MAAMA,SAAQ;EACzB,CAAC;EACD,SAAS,OAAO;IACf,SAAS,MAAM,QAAQ;IACvB,cAAc,MAAM,QAAQ;IAC5B,SAAS;IACT,QAAQA;EACT,CAAC;EACD,SAAAG;AACD,CAAC;AAGD,IAAME,aAAY,UAAU;EAC3B,kBAAkB;EAClB,cAAc,OAAO;IACpB,UAAU;;IAEV,sBAAsB;IACtB,SAAS,QAAQ;EAClB,CAAC;EACD,WAAW;AACZ,CAAC;AAGD,IAAMC,WAAU,UAAU;EACzB,QAAQD;EACR,MAAM,OAAO;IACZ,OAAO;EACR,CAAC;EACD,gBAAgB,OAAO;IACtB,OAAO,QAAQ;EAChB,CAAC;EACD,kBAAkB,OAAO;IACxB,UAAU;IACV,SAAS,SAAS,SAAS,OAAO,CAAC;IACnC,QAAQ,SAAS,SAAS,OAAO,CAAC,CAAC;IACnC,sBAAsB,SAAS,SAAS,OAAO,CAAC;IAChD,SAAS,SAAS,SAAS,QAAQ,CAAC,CAAC;EACtC,CAAC;AACF,CAAC;AAED,IAAME,yBAAwB,UAAU;EACvC,MAAM,QAAQ,IAAI;EAClB,OAAO;AACR,CAAC;AAEM,IAAM,oCAAoC,OAAO;EACvD,SAAS,QAAQ,CAAC;EAClB,QAAQ,QAAQ,UAAU;EAC1B,YAAY,QAAQA,sBAAqB;EACzC,SAASN;EACT,QAAQ,MAAMK,QAAO;EACrB,UAAU,MAAMF,QAAO;EACvB,QAAQ,SAAS,SAAS,OAAO,CAAC,CAAC;AACpC,CAAC;;;AC7HD,IAAM,wBAAwB;AAG9B,IAAM,oBAAoB;AAC1B,IAAM,UAAU;AAET,SAAS,sCAAsC,QAA0B;AAC/E,SAAO,eAAe,uBACrB,iBACA,SACA,MACC;AACD,UAAM,gBAAgB,iBAAiB,MAAM;AAC7C,UAAM,wBAAwB,iBAAiB,MAAM;AAErD,QAAI,CAAC,QAAQ,qBAAqB;AACjC,YAAM,YAAY,iBAAiB,MAAM;AACzC,YAAM,aAAa,iBAAiB,MAAM;AAC1C,YAAM,cAAc,iBAAiB,MAAM;IAC5C;AAEA,WAAO,MAAM,KAAK;EACnB;AACD;AAEA,eAAe,YAAY,iBAAyC,QAA0B;AAC7F,MAAI,CAAC,gBAAgB,UAAU,OAAO;AACrC,oBAAgB,UAAU,QAAQ,OAAO,MAAM,OAAO,qBAAqB,CAAC;EAC7E;AACD;AAEA,eAAe,aAAa,iBAAyC,QAA0B;AAC9F,MAAI,gBAAgB,UAAU,QAAQ;AACrC;EACD;AAEA,QAAM,eAAe,MAAM,OAAO,uBAAuB;IACxD,kBAAkB,gBAAgB,MAAM;MACvC,WAAW;QACV,SAAS;UACR,QAAQ,OAAO,OAAO;UACtB,SAAS,CAAC;QACX;MACD;IACD,CAAC;EACF,CAAC;AAED,MAAI,aAAa,QAAQ,OAAO,WAAW,WAAW;AACrD,UAAM,IAAI;MACT,+DAA+D,aAAa,QAAQ,OAAO,KAAK;MAChG,EAAE,OAAO,aAAa;IACvB;EACD;AAEA,QAAM,eAAe,oBAAoB,OAAO,gBAAgB,UAAU,SAAS,EAAE;AAErF,QAAM,kCACL,OAAO,aAAa,QAAQ,QAAQ,eAAe,IAAI;AAExD,QAAM,YACL,kCACA,OAAO,aAAa,QAAQ,QAAQ,WAAW,IAC/C,OAAO,aAAa,QAAQ,QAAQ,aAAa;AAElD,kBAAgB,UAAU,SAAS;IAClC,YAAY,kCAAkC,YAAY;EAC3D;AACD;AAGA,eAAe,cAAc,iBAAyC,QAA0B;AAC/F,MAAI,CAAC,gBAAgB,UAAU,SAAS;AACvC,UAAM,QAAQ,MAAM,OAAO,SAAS;MACnC,OAAO,gBAAgB,UAAU,SAAS,gBAAgB;MAC1D,UAAU;IACX,CAAC;AAED,UAAM,eAAe,MAAM,KAEzB,OAAO,CAAC,SAAS;AACjB,YAAM,gBAAgB,gBAAgB,OAAO,KAAK,CAAC,UAAU;AAC5D,YAAI,MAAM,QAAQ,kBAAkB;AACnC,iBAAO,KAAK,iBAAiB,MAAM,OAAO,iBAAiB;QAC5D;AAEA,eAAO;MACR,CAAC;AAED,aAAO,CAAC;IACT,CAAC,EACA,IAAI,CAAC,UAAU;MACf,UAAU,KAAK;MACf,QAAQ,KAAK;MACb,SAAS,KAAK;IACf,EAAE;AAEH,QAAI,CAAC,aAAa,QAAQ;AACzB,YAAM,IAAI,MAAM,+CAA+C;IAChE;AAEA,oBAAgB,UAAU,UAAU,aAAa;MAAI,CAAC,YACrD,MAAM,iBAAiB,OAAO;IAC/B;EACD;AACD;AAEA,eAAe,wBACd,iBACA,QACC;AAGD,QAAM,mBAAmB,gBAAgB,OAAO,OAAO,CAAC,UAAU;AACjE,WACC,MAAM,oBACN,EAAE,MAAM,iBAAiB,WAAW,MAAM,kBAAkB;EAE9D,CAAC;AAED,QAAM,aAAa;IAClB,GAAG,IAAI;MACN,iBAAiB,IAAI,CAAC,UAAU,qBAAqB,MAAM,iBAAiB,QAAQ,CAAC;IACtF;EACD;AAEA,QAAM,eAAe,WAAW,SAAS,MAAM,YAAY,qBAAqB,IAAI,CAAC;AACrF,QAAM,YACL,MAAM,QAAQ;IACb,aAAa;MAAI,CAACI,WACjB,OAAO,gBAAgB;QACtB,KAAKA;QACL,SAAS,EAAE,WAAW,KAAK;MAC5B,CAAC;IACF;EACD,GACC,KAAK;AAEP,QAAM,gBAAgB,IAAI;IACzB,WAAW,IAAI,CAAC,IAAI,UAAU;AAC7B,aAAO,CAAC,IAAI,SAAS,KAAK,CAAC;IAC5B,CAAC;EACF;AAEA,QAAM,iBAAiB,MAAM,KAAK,aAAa,EAC7C,OAAO,CAAC,CAAC,GAAG,GAAG,MAAM,IAAI,KAAK,EAC9B,IAAI,CAAC,CAAC,GAAG,GAAG,MAAM,KAAK,UAAU,IAAI,KAAK,CAAC;AAE7C,MAAI,eAAe,QAAQ;AAC1B,UAAM,IAAI,MAAM,4CAA4C,eAAe,KAAK,IAAI,CAAC,EAAE;EACxF;AAEA,QAAM,UAAU,SAAS,IAAI,CAACC,YAAW;AACxC,QAAIA,QAAO,SAAS,CAACA,QAAO,MAAM;AACjC,YAAM,IAAI,MAAM,2BAA2BA,QAAO,KAAK,EAAE;IAC1D;AACA,UAAM,QAAQA,QAAO,KAAK;AAC1B,UAAM,uBACL,SAAS,OAAO,UAAU,WACvB,YAAY,QACX,MAAM,OAAO,yBACb,2BAA2B,QAC1B,MAAM,sBAAsB,gBAC5B,OACF;AAEJ,WAAO;MACN,UAAUA,QAAO,KAAK;MACtB,QAAQA,QAAO,KAAK;MACpB,SAASA,QAAO,KAAK;MACrB;IACD;EACD,CAAC;AAED,QAAM,cAAc,IAAI;IACvB,WAAW,IAAI,CAAC,IAAI,UAAU;AAC7B,aAAO,CAAC,IAAI,QAAQ,KAAK,CAAC;IAC3B,CAAC;EACF;AAEA,aAAW,CAAC,OAAO,KAAK,KAAK,gBAAgB,OAAO,QAAQ,GAAG;AAC9D,QAAI,CAAC,MAAM,kBAAkB;AAC5B;IACD;AAEA,QAAI;AACJ,UAAM,KAAK,oBAAoB,MAAM,iBAAiB,QAAQ;AAC9D,UAAMA,UAAS,YAAY,IAAI,EAAE;AAEjC,QAAI,MAAM,iBAAiB,wBAAwBA,SAAQ,sBAAsB;AAChF,gBAAU,OAAO,gBAAgB;QAChC,UAAU;QACV,sBACC,MAAM,iBAAiB,wBAAwBA,SAAQ;QACxD,SAAS,MAAM,iBAAiB,WAAW,gBAAgB,iBAAiB,KAAK;MAClF,CAAC;IACF,WAAW,kBAAkB,iBAAiB,KAAK,GAAG;AACrD,gBAAU,OAAO;QAChB;UACC,UAAU;UACV,QAAQ,MAAM,iBAAiB,UAAUA,SAAQ;UACjD,SAAS,MAAM,iBAAiB,WAAWA,SAAQ;QACpD;MACD;IACD;AAEA,oBAAgB,OAAO,gBAAgB,OAAO,QAAQ,KAAK,CAAC,IAC3D,WACA,OAAO,UAAU;MAChB,UAAU;MACV,QAAQ,MAAM,iBAAiB,UAAUA,SAAQ;MACjD,SAAS,MAAM,iBAAiB,WAAWA,SAAQ;IACpD,CAAC;EACH;AACD;AAEA,eAAe,gBAAgB,iBAAyC,QAA0B;AACjG,QAAM,EAAE,QAAQ,SAAS,IAAI;AAC7B,QAAM,qBAA4E,CAAC;AACnF,QAAM,yBAAyB,oBAAI,IAAY;AAE/C,WAAS,QAAQ,CAAC,YAAY;AAE7B,QAAI,QAAQ,UAAU;AAMrB,UAAI,QAAQ,SAAS,gBAAgB;AACpC;MACD;AAEA,YAAMC,UAAS,QAAQ,SAAS,UAAU,IAAI,CAAC,QAAQ;AACtD,YAAI,IAAI,UAAU,SAAS;AAC1B,iBAAO,gBAAgB,OAAO,IAAI,KAAK;QACxC;AACA,eAAO;MACR,CAAC;AACD,YAAM,kBAAkBA,QAAO;QAC9B,CAAC,UACA,OAAO,kBACN,OAAO,oBAAoB,OAAO,OAAO,iBAAiB,YAAY;MACzE;AAEA,UAAI,iBAAiB;AACpB,cAAM,eAAe,GAAG,QAAQ,SAAS,OAAO,KAAK,QAAQ,SAAS,MAAM,KAAK,QAAQ,SAAS,QAAQ;AAC1G,+BAAuB,IAAI,YAAY;AACvC,2BAAmB,KAAK,QAAQ,QAAQ;MACzC;IACD;EACD,CAAC;AAED,QAAM,yBAAyB,oBAAI,IAAqC;AACxE,MAAI,uBAAuB,OAAO,GAAG;AACpC,UAAM,QAAQ;MACb,CAAC,GAAG,sBAAsB,EAAE,IAAI,OAAO,iBAAiB;AACvD,cAAM,CAAC,WAAW,UAAU,UAAU,IAAI,aAAa,MAAM,IAAI;AACjE,cAAM,MAAM,MAAM,OAAO,0BAA0B;UAClD,SAAS;UACT,QAAQ;UACR,UAAU;QACX,CAAC;AAED,+BAAuB;UACtB;UACA,IAAI,WAAW,IAAI,CAAC,UAAU,kCAAkC,KAAK,CAAC;QACvE;MACD,CAAC;IACF;EACD;AAEA,MAAI,mBAAmB,QAAQ;AAC9B,UAAM,QAAQ;MACb,mBAAmB,IAAI,OAAO,aAAa;AAC1C,cAAM,aAAa,uBAAuB;UACzC,GAAG,SAAS,OAAO,KAAK,SAAS,MAAM,KAAK,SAAS,QAAQ;QAC9D;AAEA,YAAI,CAAC,YAAY;AAChB;QACD;AAKA,cAAM,eAAe,WAAW,SAAS,KAAK,YAAY,WAAW,GAAG,EAAE,CAAE;AAC5E,cAAM,SAAS,eAAe,WAAW,MAAM,GAAG,WAAW,SAAS,CAAC,IAAI;AAE3E,iBAAS,iBAAiB;MAC3B,CAAC;IACF;EACD;AAEA,WAAS,QAAQ,CAAC,YAAY;AAC7B,QAAI,CAAC,QAAQ,UAAU;AACtB;IACD;AAEA,UAAM,WAAW,QAAQ;AACzB,UAAM,SAAS,GAAG,SAAS,OAAO,KAAK,SAAS,MAAM,KAAK,SAAS,QAAQ;AAC5E,UAAM,SAAS,SAAS;AAExB,QAAI,CAAC,QAAQ;AACZ;IACD;AAEA,QAAI,OAAO,WAAW,QAAQ,SAAS,UAAU,QAAQ;AACxD,YAAM,IAAI,MAAM,qCAAqC,MAAM,EAAE;IAC9D;AAEA,WAAO,QAAQ,CAAC,OAAO,MAAM;AAC5B,YAAM,MAAM,SAAS,UAAU,CAAC;AAChC,UAAI,IAAI,UAAU,QAAS;AAC3B,YAAM,QAAQ,OAAO,IAAI,KAAK;AAG9B,UAAI,CAAC,MAAM,kBAAkB,CAAC,MAAM,kBAAkB;AACrD;MACD;AAEA,YAAM,aAAa,MAAM,gBAAgB,SAAS,MAAM,kBAAkB;AAE1E,YAAM,SAAS,iBAAiB,MAAM,IAAI;AAC1C,UAAI,QAAQ;AACX,YAAI,OAAO;AACX,eAAO,OAAO,QAAQ,KAAK,CAAC,IAAI,OAAO,KAAK,OAAO,UAAU,UAAU,CAAC;AACxE;MACD;AAEA,UAAI,OAAO,eAAe,UAAU;AACnC,cAAM,IAAI;UACT,sDAAsD,KAAK;YAC1D;YACA;YACA;UACD,CAAC;QACF;MACD;AAEA,UAAI,OAAO;AACX,YAAM,mBAAiC,MAAM,iBAC1C;QACA,OAAO;QACP,kBAAkB;UACjB,UAAU;QACX;MACD,IACC;AAEH,aAAO,IAAI,KAAK,IAAI;IACrB,CAAC;EACF,CAAC;AACF;AAEA,SAAS,gBAAgB,iBAAyC,OAAe;AAChF,MAAI,gBAAgB;AAEpB,kBAAgB,aAAa,OAAO,CAAC,KAAK,OAAO;AAChD,QAAI,GAAG,YAAY,GAAG,SAAS,gBAAgB;AAC9C,YAAM,WAAW,GAAG,SAAS,UAAU,QAAQ,GAAG;AAClD,sBAAgB,GAAG,SAAS,eAAe,QAAQ,EAAE,QAAQ,OAAO;IACrE;AAEA,QACC,GAAG,UAAU,iBACb,GAAG,UAAU,gBACb,GAAG,UAAU,gBACb,GAAG,UAAU,mBACZ;AACD,sBAAgB;IACjB;EACD,CAAC;AAED,SAAO;AACR;AAEA,SAAS,kBAAkB,iBAAyC,OAAe;AAClF,MAAI,kBAAkB;AAEtB,kBAAgB,aAAa,OAAO,CAAC,KAAK,OAAO;AAChD,QAAI,GAAG,YAAY,GAAG,SAAS,gBAAgB;AAC9C,YAAM,WAAW,GAAG,SAAS,UAAU,QAAQ,GAAG;AAClD,wBAAkB,gBAAgB,GAAG,SAAS,eAAe,QAAQ,CAAC,KAAK;IAC5E;EACD,CAAC;AAED,SAAO;AACR;AAEA,SAAS,gBAAgB,MAAsC;AAC9D,MAAI,OAAO,KAAK,SAAS,YAAY,EAAE,cAAc,KAAK,OAAO;AAChE,WAAO;EACR;AAEA,SACC,KAAK,KAAK,SAAS,YAAY,SAC/B,KAAK,KAAK,SAAS,WAAW,cAC9B,KAAK,KAAK,SAAS,SAAS;AAE9B;;;ACvYO,SAAS,2BACf,MACA,SACU;AACV,MACC,KAAK,OAAO,KAAK,CAAC,UAAU;AAC3B,WAAO,MAAM,oBAAoB,MAAM;EACxC,CAAC,GACA;AACD,WAAO;EACR;AAEA,MAAI,CAAC,QAAQ,qBAAqB;AACjC,QAAI,CAAC,KAAK,UAAU,SAAS,CAAC,KAAK,UAAU,UAAU,CAAC,KAAK,UAAU,SAAS;AAC/E,aAAO;IACR;EACD;AAEA,SAAO;AACR;AAEA,eAAsB,yBACrB,iBACA,SACA,MACC;AACD,wBAAsB,eAAe;AACrC,MAAI,CAAC,2BAA2B,iBAAiB,OAAO,GAAG;AAC1D,UAAM,SAAS,eAAe;AAC9B,WAAO,KAAK;EACb;AAEA,QAAM,SAASC,WAAU,OAAO;AAChC,QAAM,SACL,OAAO,MAAM,yBAAyB,KACtC,sCAAsC,MAA0B;AAEjE,SAAO,OAAO,iBAAiB,SAAS,YAAY;AACnD,UAAM,SAAS,eAAe;AAC9B,UAAM,KAAK;EACZ,CAAC;AACF;AAEA,SAAS,SAAS,iBAAyC;AAC1D,kBAAgB,OAAO,QAAQ,CAAC,OAAO,UAAU;AAChD,QAAI,MAAM,UAAU,YAAY,MAAM,UAAU,QAAQ;AACvD,YAAM,IAAI;QACT,kBAAkB,KAAK,uEAAuE,KAAK;UAClG;QACD,CAAC;MACF;IACD;EACD,CAAC;AACF;AAEO,SAASA,WAAU,SAAkC;AAC3D,MAAI,CAAC,QAAQ,QAAQ;AACpB,UAAM,IAAI;MACT;IACD;EACD;AAEA,SAAO,QAAQ;AAChB;AAEA,SAAS,sBAAsB,iBAAyC;AACvE,aAAW,WAAW,gBAAgB,UAAU;AAC/C,YAAQ,QAAQ,OAAO;MACtB,KAAK;AACJ,gBAAQ,WAAW,QAAQ,QAAQ,CAAC,WAAW;AAC9C,+BAAqB,QAAQ,OAAI,KAAK,eAAe;QACtD,CAAC;AACD;MACD,KAAK;AACJ,6BAAqB,QAAQ,gBAAgB,SAAS,OAAI,SAAS,eAAe;AAClF;IACF;EACD;AACD;AAEA,SAAS,qBACR,KACA,QACA,iBACC;AACD,MAAI,IAAI,UAAU,SAAS;AAC1B;EACD;AACA,QAAM,QAAQ,gBAAgB,OAAO,IAAI,KAAK;AAE9C,MAAI,MAAM,UAAU,kBAAkB;AACrC;EACD;AAEA,kBAAgB,OAAO,IAAI,KAAK,IAAI,OAAO,KAAK,OAAO,UAAU,MAAM,eAAe,KAAK,CAAC;AAC7F;;;ACrHO,SAAS,oBAAuB,YAAkD;AACxF,WAASC,QAAO,OAA+B;AAC9C,WAAO,WAAW,KAAK;EACxB;AAEA,EAAAA,QAAO,SAAS,CAAC,YAAoC;AACpD,UAAM,UAAU,SAAS;AAEzB,QAAI,YAAY,QAAW;AAC1B,aAAOA;QACN,OAAO,gBAAgB;UACtB,UAAU;UACV,sBAAsB;UACtB;QACD,CAAC;MACF;IACD;AAEA,WAAOA,QAAO;MACb,OAAO;MACP,kBAAkB;QACjB,UAAU;QACV,sBAAsB;MACvB;IACD,CAAC;EACF;AACA,EAAAA,QAAO,QAAQ,MACdA;IACC,OAAO,gBAAgB;MACtB,UAAU;MACV,sBAAsB;MACtB,SAAS;IACV,CAAC;EACF;AACD,EAAAA,QAAO,SAAS,MACfA,QAAO;IACN,OAAO;IACP,kBAAkB;MACjB,UAAU;MACV,SAAS;IACV;EACD,CAAC;AACF,EAAAA,QAAO,WAAW,CAAC,YAAoC;AACtD,WAAOA,QAAO;MACb,OAAO;MACP,kBAAkB;QACjB,UAAU;QACV,SAAS,SAAS;MACnB;IACD,CAAC;EACF;AACA,EAAAA,QAAO,SACN,CAAC,EAAE,MAAM,MAAM,MACf,CAAC,OACA,GAAG,SAAS;IACX,eAAe,CAAC,IAAI;IACpB,QAAQ,gBAAgB,UAAU,OAAO,SAAS,MAAM;IACxD,WAAW,UAAU,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,KAAK,CAAC;EACnD,CAAC;AAEH,SAAOA;AACR;;;ACzDO,SAAS,WAAc,UAA8D;AAc3F,WAAS,KACR,uBACA,OACI;AACJ,QAAI,OAAO,0BAA0B,UAAU;AAC9C,aAAO,SAAS,0BAA0B,qBAAqB,EAAE,UAAU,KAAc,CAAC;IAC3F;AAEA,QAAI,iCAAiC,cAAc,gBAAgB,qBAAqB,GAAG;AAC1F,aAAO,SAAS,qBAAqB;IACtC;AAEA,UAAM,IAAI,MAAM,0EAA0E;EAC3F;AAEA,OAAK,KAAK,CAAC,UAAkB,SAAS,OAAI,GAAG,UAAU,KAAK,CAAC;AAC7D,OAAK,MAAM,CAAC,UAAkB,SAAS,OAAI,IAAI,UAAU,KAAK,CAAC;AAC/D,OAAK,MAAM,CAAC,UAAkB,SAAS,OAAI,IAAI,UAAU,KAAK,CAAC;AAC/D,OAAK,MAAM,CAAC,UAAoC,SAAS,OAAI,IAAI,UAAU,KAAK,CAAC;AACjF,OAAK,OAAO,CAAC,UAAoC,SAAS,OAAI,KAAK,UAAU,KAAK,CAAC;AACnF,OAAK,OAAO,CAAC,UAAoC,SAAS,OAAI,KAAK,UAAU,KAAK,CAAC;AACnF,OAAK,OAAO,CAAC,UAAmB,SAAS,OAAI,KAAK,UAAU,KAAK,CAAC;AAClE,OAAK,SAAS,CAAC,UAAkB,SAAS,OAAI,OAAO,UAAU,KAAK,CAAC;AACrE,OAAK,UAAU,CAAC,UAAkB,SAAS,OAAI,QAAQ,UAAU,KAAK,CAAC;AACvE,OAAK,KAAK,KAAK;AACf,OAAK,SAAS,CACb,MACA,UACI;AACJ,WAAO;MACN,OAAI,OAAO,0BAA0B,IAAoB,CAAC,EAAE,UAAU,KAAc;IACrF;EACD;AACA,OAAK,SAAS,CACb,MACA,UACI;AACJ,WAAO,SAAS,OAAI,OAAO,0BAA0B,IAAI,CAAC,EAAE,UAAU,KAAc,CAAC;EACtF;AAEA,SAAO;AACR;;;;;;;;;;;ACjEA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAqDA,SAAS,wBACR,OACA,SAAS,UACW;AACpB,QAAM,aAAa;IAClB,OAAO;IACP,IAAI,SAAS;AACZ,aAAO,OAAO,UAAU,aAAa,MAAM,IAAI;IAChD;EACD;AAEA,QAAM,gBAGA,CAAC;AACP,QAAM,kBAAkB,CACvB,gBAKC,cAAA,WAAA,MAAA,cAAA,WAAA,IAA+B;IAC/B,OAAO;IACP,IAAI,eAAe;AAClB,aAAO,CAAC,OAAO,UAAU,aAAa,MAAM,IAAI,OAAO,WAAW;IACnE;EACD;AAED,SAAO,IAAI,MAAM,YAAY;IAC5B,MAAM;AACL,YAAM,IAAI;QACT;MACD;IACD;;;;IAIA,IAAI,QAAQ,UAAU;AAErB,UAAI,YAAY,QAAQ;AACvB,eAAO,QAAQ,IAAI,QAAQ,QAAQ;MACpC;AAGA,UAAI,aAAa,OAAO,UAAU;AACjC,eAAO,aAAa;AACnB,cAAI,IAAI;AACR,iBAAO,IAAI,QAAQ;AAClB,kBAAM,gBAAgB,CAAC;AACvB;UACD;QACD;MACD;AAEA,UAAI,OAAO,aAAa,SAAU;AAElC,YAAM,cAAc,SAAS,UAAU,EAAE;AACzC,UAAI,OAAO,MAAM,WAAW,KAAK,cAAc,EAAG;AAClD,aAAO,gBAAgB,WAAW;IACnC;EACD,CAAC;AACF;AAEA,IAAM,oBAAoB,OAAO,IAAI,qBAAqB;AAMnD,SAAS,cAAc,KAAsC;AACnE,SAAO,CAAC,CAAC,OAAO,OAAO,QAAQ,YAAa,IAAY,iBAAiB,MAAM;AAChF;AAWA,IAAM,uBAAkD;EACvD,cAAc,oBAAI,IAAI;EACtB,sBAAsB,oBAAI,IAAI;AAC/B;AAEA,IAAM,2BAA2B,OAAO,IAAI,8BAA8B;AAC1E,SAAS,0BAA0B;AAClC,MAAI;AACH,UAAM,SAAS;AAIf,QAAI,CAAC,OAAO,wBAAwB,GAAG;AACtC,aAAO,wBAAwB,IAAI;IACpC;AAEA,WAAO,OAAO,wBAAwB;EACvC,QAAQ;AACP,WAAO;EACR;AACD;AAYO,IAAM,eAAN,MAAMC,cAAY;EA4LxB,cAAc;AA5LR,IAAAC,cAAA,MAAA,sBAAA;AACN,IAAAA,cAAA,MAAA,qBAAA;AACA,IAAAA,cAAA,MAAA,aAAA;AACA,IAAAA,cAAA,MAAA,kBAAmB,oBAAI,IAA+B,CAAA;AACtD,IAAAA,cAAA,MAAA,eAA8B,CAAC,CAAA;AAC/B,IAAAA,cAAA,MAAA,iBAAkC,CAAC,CAAA;AACnC,IAAAA,cAAA,MAAA,mBAAiC,oBAAI,IAAI,CAAA;AACzC,IAAAA,cAAA,MAAA,kBAAmB,oBAAI,IAAsB,CAAA;AAC7C,IAAAA,cAAA,MAAA,QAAS,oBAAI,IAA0C,CAAA;AAqIvD,IAAAA,cAAA,MAAA,KAAA;AA8DA,SAAA,SAEI;MACH,CAAC,UAAsF;AACtF,YAAI,OAAO,UAAU,YAAY;AAChC,iBAAO,KAAK,OAAO,KAAK,IAAI,KAAuD,CAAC;QACrF;AAEA,YAAI,OAAO,UAAU,YAAY,GAAG,gBAAgB,KAAK,GAAG;AAC3D,iBAAO;QACR;AAEA,cAAM,KAAK,iBAAiB,KAAK;AAEjC,cAAM,WAAWC,cAAA,MAAK,KAAA,EAAM,OAAO,KAAK,CAAC,MAAM,OAAO,iBAAiB,CAAC,CAAC;AAGzE,YACC,UAAU,QAAQ,gBAClB,OAAO,UAAU,YACjB,MAAM,QAAQ,cACb;AACD,mBAAS,OAAO,aAAa,UAC5B,SAAS,OAAO,aAAa,WAAW,MAAM,OAAO,aAAa;QACpE;AAEA,eAAO,WACJ,EAAE,OAAO,SAAS,OAAOA,cAAA,MAAK,KAAA,EAAM,OAAO,QAAQ,QAAQ,GAAG,MAAM,SAAS,IAC7EC,iBAAA,MAAK,wBAAA,WAAA,EAAL,KAAA,MACA,UACA,OAAO,UAAU,WACd;UACA,OAAO;UACP,kBAAkB,EAAE,UAAU,oBAAoB,KAAK,EAAE;QAC1D,IACC,KAAA;MAEP;IACD;AApDC,UAAM,gBAAgB,wBAAwB;AAC9C,IAAAC,cAAA,MAAK,OAAQ,IAAI,uBAAuB,CAAA;AACxC,IAAAA,cAAA,MAAK,eAAgB,CAAC,GAAG,cAAc,aAAa,OAAO,CAAC,CAAA;AAC5D,IAAAA,cAAA,MAAK,uBAAwB,CAAC,GAAG,cAAc,qBAAqB,OAAO,CAAC,CAAA;EAC7E;;;;;EAnLA,OAAO,SAAS,YAAiC;AAChD,UAAM,KAAK,IAAIJ,cAAY;AAE3B,IAAAI,cAAA,IAAG,OAAQ,uBAAuB;MACjC,OAAO,eAAe,WAAW,WAAW,UAAU,IAAI;IAC3D,CAAA;AAEA,IAAAA,cAAA,IAAG,eAAgBF,cAAA,IAAG,KAAA,EAAM,OAAO,MAAM,CAAA;AACzC,IAAAE,cAAA,IAAG,iBAAkBF,cAAA,IAAG,KAAA,EAAM,SAAS,MAAM,CAAA;AAC7C,IAAAE,cAAA,IAAG,mBAAoB,IAAI,IAAIF,cAAA,IAAG,eAAA,EAAgB,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,CAAA;AAElE,WAAO;EACR;;;;;;;EAQA,OAAO,KAAK,aAAoD;AAC/D,UAAM,iBAAiB,IAAIF,cAAY;AAEvC,QAAI,cAAc,WAAW,GAAG;AAC/B,MAAAI,cAAA,gBAAe,OAAQ,uBAAuB;QAC7C,YAAY,QAAQ;MACrB,CAAA;IACD,WAAW,OAAO,gBAAgB,YAAY,CAAC,YAAY,WAAW,GAAG,GAAG;AAC3E,MAAAA,cAAA,gBAAe,OAAQ,uBAAuB;QAC7C,OAAO,gBAAgB,WAAW,WAAW,WAAW,IAAI;MAC7D,CAAA;IACD,OAAO;AACN,MAAAA,cAAA,gBAAe,OAAQ,uBAAuB,QAAQ,KAAK,MAAM,WAAW,CAAC,CAAA;IAC9E;AAEA,IAAAA,cAAA,gBAAe,eAAgBF,cAAA,gBAAe,KAAA,EAAM,OAAO,MAAM,CAAA;AACjE,IAAAE,cAAA,gBAAe,iBAAkBF,cAAA,gBAAe,KAAA,EAAM,SAAS,MAAM,CAAA;AACrE,IAAAE,cAAA,gBAAe,mBAAoB,IAAI,IAAIF,cAAA,gBAAe,eAAA,EAAgB,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,CAAA;AAE1F,WAAO;EACR;EAKA,OAAO,kCACN,YACA,MACC;AACD,4BAAwB,EAAE,qBAAqB;MAC9C;MACA,QAAS;IACV;EACD;EAEA,OAAO,oCAAoC,MAAc;AACxD,4BAAwB,EAAE,qBAAqB,OAAO,IAAI;EAC3D;EAKA,OAAO,0BACN,YACA,MACC;AACD,4BAAwB,EAAE,aAAa;MACtC;MACA,QAAS;IACV;EACD;EAEA,OAAO,4BAA4B,MAAc;AAChD,4BAAwB,EAAE,aAAa,OAAO,IAAI;EACnD;EAEA,uBAAuB,MAAyB;AAC/C,IAAAA,cAAA,MAAK,qBAAA,EAAsB,KAAK,IAAI;EACrC;EAEA,eAAe,MAAyB;AACvC,IAAAA,cAAA,MAAK,aAAA,EAAc,KAAK,IAAI;EAC7B;EAEA,kBAAkB,QAAgB,UAA6B;AAC9D,QAAIA,cAAA,MAAK,gBAAA,EAAiB,IAAI,MAAM,KAAKA,cAAA,MAAK,gBAAA,EAAiB,IAAI,MAAM,MAAM,UAAU;AACxF,YAAM,IAAI,MAAM,uBAAuB,MAAM,iBAAiB;IAC/D;AAEA,IAAAA,cAAA,MAAK,gBAAA,EAAiB,IAAI,QAAQ,QAAQ;EAC3C;EAEA,UAAU,QAAgB;AACzB,IAAAA,cAAA,MAAK,KAAA,EAAM,SAAS;EACrB;;;;;EAKA,kBAAkB,QAAgB;AACjC,QAAI,CAACA,cAAA,MAAK,KAAA,EAAM,QAAQ;AACvB,MAAAA,cAAA,MAAK,KAAA,EAAM,SAAS;IACrB;EACD;EACA,cAAc,YAA8D;AAC3E,IAAAA,cAAA,MAAK,KAAA,EAAM,aAAa,aAAa,MAAMG,wBAAuB,UAAU,IAAI;EACjF;EACA,YAAY,OAAwB;AACnC,IAAAH,cAAA,MAAK,KAAA,EAAM,UAAU,QAAQ,OAAO,KAAK;EAC1C;EACA,aAAa,QAAyB;AACrC,IAAAA,cAAA,MAAK,KAAA,EAAM,UAAU,SAAS,OAAO,MAAM;EAC5C;EAEA,qBAAqB,QAAyB;AAC7C,QAAIA,cAAA,MAAK,KAAA,EAAM,QAAQ,UAAU,MAAM;AACtC,MAAAA,cAAA,MAAK,KAAA,EAAM,UAAU,SAAS,OAAO,MAAM;IAC5C;EACD;EAEA,YAAY,OAAe;AAC1B,IAAAA,cAAA,MAAK,KAAA,EAAM,UAAU,QAAQ;EAC9B;EACA,cAAc,UAAuB;AACpC,IAAAA,cAAA,MAAK,KAAA,EAAM,UAAU,UAAU,SAAS,IAAI,CAAC,YAAY,MAAM,iBAAiB,OAAO,CAAC;EACzF;;EAKA,IAAI,YAAY;AACf,WAAO,2BAA2BA,cAAA,MAAK,KAAA,EAAM,SAAS,CAAC;EACxD;;EAGA,UAAU;AACT,WAAOA,cAAA,MAAK,KAAA,EAAM,SAAS;EAC5B;;;EAIA,KAAK,iBAAiB,IAAI;AACzB,WAAO;EACR;;EAGA,IAAI,OAAgD;AACnD,WAAO,eAAe,MAAM,QAAQ;MACnC,YAAY;MACZ,OAAO,WAAqB,CAAC,UAAoB;AAChD,YAAI,gBAAgB,KAAK,GAAG;AAC3B,iBAAOC,iBAAA,MAAK,wBAAA,WAAA,EAAL,KAAA,MAAe,QAAQ;YAC7B,OAAO;YACP,MAAM;cACL,OAAO,MAAM,SAAS;YACvB;UACD,CAAA;QACD;AAGA,eAAOA,iBAAA,MAAK,wBAAA,WAAA,EAAL,KAAA,MACN,QACA,GAAG,mBAAmB,KAAK,IACxB,MAAM,mBAAmB,KAAK,IAC9B,iBAAiB,aAChB,OAAO,KAAK,KAAK,IACjB,EAAE,OAAO,kBAAkB,gBAAgB,EAAE,MAAM,EAAE,CAAA;MAE3D,CAAC;IACF,CAAC;AAED,WAAO,KAAK;EACb;;EAUA,IAAI,MAAM;AACT,WAAO,EAAE,OAAO,WAAoB,SAAS,KAAc;EAC5D;;;;;EAiDA,aAAa,MAAgD;AAC5D,WAAO,KAAK,OAAO,OAAO,UAAU,GAAG,IAAI,CAAC;EAC7C;;;;;EAMA,gBAAgB,MAAmD;AAClE,WAAO,KAAK,OAAO,OAAO,aAAa,GAAG,IAAI,CAAC;EAChD;;;;;EAMA,mBAAmB,MAAsD;AACxE,WAAO,KAAK,OAAO,OAAO,gBAAgB,GAAG,IAAI,CAAC;EACnD;EA2BA,IAAI,SAAoF;AACvF,QAAI,OAAO,YAAY,YAAY;AAClC,UAAID,cAAA,MAAK,MAAA,EAAO,IAAI,OAAO,GAAG;AAC7B,eAAOA,cAAA,MAAK,MAAA,EAAO,IAAI,OAAO;MAC/B;AAEA,YAAM,OAAOC,iBAAA,MAAK,wBAAA,OAAA,EAAL,KAAA,IAAA;AACb,YAAM,SAAS,QAAQ,IAAI;AAE3B,UAAI,EAAE,UAAU,OAAO,WAAW,YAAY,UAAU,SAAS;AAChE,QAAAC,cAAA,MAAK,mBAAoBF,cAAA,MAAK,iBAAA,CAAA;AAC9B,QAAAA,cAAA,MAAK,MAAA,EAAO,IAAI,SAAS,MAAM;AAC/B,eAAO;MACR;AAEA,YAAM,cAAcC,iBAAA,MAAK,wBAAA,aAAA,EAAL,KAAA,MAAiB;QACpC,OAAO;QACP,SAAS;UACR,MAAM;UACN,QAAQ,CAAC;UACT,MAAM;YACL,aAAaD,cAAA,MAAK,KAAA,EAAM,SAAS;YACjC,QAAQ;UACT;QACD;MACD,CAAA;AAEA,MAAAA,cAAA,MAAK,gBAAA,EAAiB;QACrB,QAAQ,QAAQ,MAAoC,EAAE,KAAK,CAACI,YAAW;AACtE,sBAAY,QAAQ,KAAK,SAASA;QACnC,CAAC;MACF;AACA,YAAM,WAAW,wBAAwB,MAAM,YAAY,QAAQ,KAAK,WAAW;AACnF,MAAAJ,cAAA,MAAK,MAAA,EAAO,IAAI,SAAS,QAAQ;AACjC,aAAO;IACR,OAAO;AACN,MAAAC,iBAAA,MAAK,wBAAA,aAAA,EAAL,KAAA,MAAiB,OAAA;IAClB;AAEA,WAAO,wBAAwBD,cAAA,MAAK,KAAA,EAAM,SAAS,SAAS,CAAC;EAC9D;;EA8DA,WAEE,MAA0C,SAAkB;AAC7D,UAAM,UAAU,SAAS;MACxB,OAAO,SAAS,WAAW,KAAK,OAAO,IAAI,IAAIC,iBAAA,MAAK,wBAAA,kBAAA,EAAL,KAAA,MAAsB,IAAA;MACrE,QAAQ;QAAI,CAAC,WACZ,OAAO,WAAW,YAAY,OAAO,WAAW,YAAY,OAAO,WAAW,WAC3E,KAAK,KAAK,IAAI,MAAM,IACpBA,iBAAA,MAAK,wBAAA,+BAAA,EAAL,KAAA,MAAmC,MAAA;MACvC;IACD;AACA,IAAAA,iBAAA,MAAK,wBAAA,aAAA,EAAL,KAAA,MAAiB,OAAA;AACjB,WAAO,wBAAwBD,cAAA,MAAK,KAAA,EAAM,SAAS,SAAS,GAAG,QAAQ,MAAM;EAM9E;EACA,WACC,aACA,SACC;AACD,WAAO,KAAK;MACX,SAAS;QACR,KAAK,OAAO,WAAW;QACvB,QAAQ,IAAI,CAAC,QAAQ,KAAK,OAAO,GAAG,CAAC;MACtC;IACD;EACD;EACA,QAAQ,EAAE,SAAS,aAAa,GAA+D;AAC9F,WAAO,KAAK;MACX,SAAS,QAAQ;QAChB;QACA;MACD,CAAC;IACF;EACD;EACA,QAAQ;IACP;IACA;IACA,SAAS;IACT;EACD,GAKG;AACF,WAAO,KAAK;MACX,SAAS,QAAQ;QAChB;QACA;QACA,SAAS;QACT,QAAQ,KAAK,OAAO,MAAM;MAC3B,CAAC;IACF;EACD;EACA,SAAS;IACR,WAAW;IACX,GAAG;EACJ,GAYM;AACL,WAAO,KAAK;MACX,SAAS,SAAS;QACjB,GAAG;QACH,WAAW,MAAM,IAAI,CAAC,QAAQC,iBAAA,MAAK,wBAAA,+BAAA,EAAL,KAAA,MAAmC,GAAA,CAAI;MACtE,CAA4C;IAC7C;EACD;EACA,gBACC,SACA,SACC;AACD,WAAO,KAAK;MACX,SAAS;QACR,QAAQ,IAAI,CAAC,QAAQ,KAAK,OAAO,GAAG,CAAC;QACrC,OAAO,YAAY,WAChB,KAAK,KAAK,QAAQ,OAAO,IACzBA,iBAAA,MAAK,wBAAA,+BAAA,EAAL,KAAA,MAAmC,OAAA;MACvC;IACD;EACD;EACA,YAAY;IACX;IACA;EACD,GAGG;AACF,WAAO,KAAK;MACX,SAAS,YAAY;QACpB;QACA,UAAU,SAAS,IAAI,CAAC,QAAQ,KAAK,OAAO,GAAG,CAAC;MACjD,CAAC;IACF;EACD;;;;;EAMA,YAAY;AACX,WAAO,KAAK,UAAU,2BAA2BD,cAAA,MAAK,KAAA,EAAM,SAAS,CAAC,CAAC;EACxE;EAEA,MAAM,OAAO,UAAuC,CAAC,GAAoB;AACxE,UAAM,KAAK,wBAAwB,OAAO;AAC1C,UAAM,gBAAgB,KAAK,gBAAgB;AAC3C,WAAO,KAAK;MACX;QACC;QACA,gBACG;UACA,GAAGA,cAAA,MAAK,KAAA,EAAM,SAAS;UACvB,QAAQA,cAAA,MAAK,KAAA,EAAM,UAAU;QAC9B,IACCA,cAAA,MAAK,KAAA,EAAM,SAAS;MACxB;MACA,CAAC,MAAM,UAAW,OAAO,UAAU,WAAW,MAAM,SAAS,IAAI;MACjE;IACD;EACD;;EAGA,MAAM,KAAK,SAAmD;AAC7D,UAAM,EAAE,QAAQ,GAAG,aAAa,IAAI;AACpC,UAAM,QAAQ,MAAM,KAAK,MAAM,YAAY;AAC3C,WAAO,OAAO,gBAAgB,KAAK;EACpC;;;;;;;;;;;;EAaA,kBAAkB;AACjB,QAAI,CAACA,cAAA,MAAK,KAAA,EAAM,QAAQ;AACvB,aAAO;IACR;AAEA,QAAIA,cAAA,MAAK,gBAAA,EAAiB,OAAO,GAAG;AACnC,aAAO;IACR;AAEA,QAAIA,cAAA,MAAK,KAAA,EAAM,SAAS,KAAK,CAAC,QAAQ,IAAI,OAAO,GAAG;AACnD,aAAO;IACR;AAEA,QAAI,2BAA2BA,cAAA,MAAK,KAAA,GAAO,CAAC,CAAC,GAAG;AAC/C,aAAO;IACR;AAEA,WAAO;EACR;;EAGA,MAAM,MAAM,UAAmC,CAAC,GAAqC;AACpF,UAAM,KAAK,wBAAwB,OAAO;AAC1C,UAAMC,iBAAA,MAAK,wBAAA,eAAA,EAAL,KAAA,MAAmB,OAAA;AACzB,WAAOD,cAAA,MAAK,KAAA,EAAM,MAAM;MACvB,qBAAqB,QAAQ;IAC9B,CAAC;EACF;;EAGA,MAAM,UACL,UAEI,CAAC,GACa;AAClB,UAAM,KAAK,wBAAwB,OAAO;AAC1C,UAAMC,iBAAA,MAAK,wBAAA,eAAA,EAAL,KAAA,MAAmB,OAAA;AACzB,WAAOD,cAAA,MAAK,KAAA,EAAM,UAAU;EAC7B;EAiJA,MAAM,wBAAwB,SAAsC;AACnE,UAAMC,iBAAA,MAAK,wBAAA,sBAAA,EAAL,KAAA,IAAA;AACN,IAAAA,iBAAA,MAAK,wBAAA,wBAAA,EAAL,KAAA,IAAA;AACA,UAAM,UAAU,oBAAI,IAAY;AAChC,eAAW,WAAWD,cAAA,MAAK,KAAA,EAAM,UAAU;AAC1C,UAAI,QAAQ,SAAS;AACpB,gBAAQ,IAAI,QAAQ,QAAQ,IAAI;MACjC;IACD;AAEA,UAAM,QAAQ,CAAC,GAAGA,cAAA,MAAK,qBAAA,CAAqB;AAE5C,eAAW,UAAU,SAAS;AAC7B,UAAI,QAAQ,kBAAkB,SAAS,MAAM,GAAG;AAC/C;MACD;AAEA,UAAI,CAACA,cAAA,MAAK,gBAAA,EAAiB,IAAI,MAAM,GAAG;AACvC,cAAM,IAAI,MAAM,+BAA+B,MAAM,EAAE;MACxD;AAEA,YAAM,KAAKA,cAAA,MAAK,gBAAA,EAAiB,IAAI,MAAM,CAAE;IAC9C;AAEA,UAAM,KAAK,oBAAoB,CAAC;AAEhC,UAAMC,iBAAA,MAAK,wBAAA,aAAA,EAAL,KAAA,MAAiB,OAAO,OAAA;EAC/B;AACD;AArvBC,wBAAA,oBAAA,QAAA;AACA,gBAAA,oBAAA,QAAA;AACA,mBAAA,oBAAA,QAAA;AACA,gBAAA,oBAAA,QAAA;AACA,kBAAA,oBAAA,QAAA;AACA,oBAAA,oBAAA,QAAA;AACA,mBAAA,oBAAA,QAAA;AACA,SAAA,oBAAA,QAAA;AAqIA,QAAA,oBAAA,QAAA;AA7IM,yBAAA,oBAAA,QAAA;AA2QN,UAAK,WAAG;AACP,QAAM,OAAO,IAAI,aAAY;AAE7B,EAAAC,cAAA,MAAK,OAAQF,cAAA,MAAK,KAAA,CAAA;AAClB,EAAAE,cAAA,MAAK,uBAAwBF,cAAA,MAAK,qBAAA,CAAA;AAClC,EAAAE,cAAA,MAAK,eAAgBF,cAAA,MAAK,aAAA,CAAA;AAC1B,EAAAE,cAAA,MAAK,kBAAmBF,cAAA,MAAK,gBAAA,CAAA;AAC7B,EAAAE,cAAA,MAAK,kBAAmBF,cAAA,MAAK,gBAAA,CAAA;AAC7B,EAAAE,cAAA,MAAK,mBAAoB,IAAI,IAAIF,cAAA,MAAK,iBAAA,CAAiB,CAAA;AACvD,EAAAE,cAAA,MAAK,QAASF,cAAA,MAAK,MAAA,CAAA;AACnB,EAAAA,cAAA,MAAK,aAAA,EAAc,KAAKA,cAAA,MAAK,aAAA,CAAa;AAC1C,EAAAA,cAAA,MAAK,eAAA,EAAgB,KAAKA,cAAA,MAAK,eAAA,CAAe;AAE9C,SAAO;AACR;AAqDA,gBAA8B,SAAC,SAAY;AAC1C,QAAM,cAAcA,cAAA,MAAK,KAAA,EAAM,SAAS;AACxC,EAAAA,cAAA,MAAK,eAAA,EAAgB,KAAK,OAAO;AACjC,EAAAA,cAAA,MAAK,iBAAA,EAAkB,IAAI,WAAW;AACtC,EAAAA,cAAA,MAAK,KAAA,EAAM,SAAS,KAAK,OAAO;AAEhC,EAAAA,cAAA,MAAK,KAAA,EAAM,oBAAoB,aAAa,CAAC,QAAQ;AACpD,QAAI,IAAI,UAAU,YAAY,CAACA,cAAA,MAAK,iBAAA,EAAkB,IAAI,IAAI,MAAM,GAAG;AACtE,YAAM,IAAI;QACT,oBAAoB,IAAI,MAAM;MAC/B;IACD;AAEA,QAAI,IAAI,UAAU,kBAAkB,CAACA,cAAA,MAAK,iBAAA,EAAkB,IAAI,IAAI,aAAa,CAAC,CAAC,GAAG;AACrF,YAAM,IAAI;QACT,2BAA2B,IAAI,aAAa,CAAC,CAAC,KAAK,IAAI,aAAa,CAAC,CAAC;MACvE;IACD;AAEA,QAAI,IAAI,UAAU,WAAW,IAAI,SAASA,cAAA,MAAK,KAAA,EAAM,OAAO,QAAQ;AACnE,YAAM,IAAI;QACT,kBAAkB,IAAI,KAAK;MAC5B;IACD;AAEA,WAAO;EACR,CAAC;AAED,SAAO;AACR;AAEA,cAAsC,SAAC,MAAS,OAAgB;AAC/D,EAAAA,cAAA,MAAK,aAAA,EAAc,KAAK,KAAK;AAC7B,SAAOA,cAAA,MAAK,KAAA,EAAM,SAAS,MAAM,KAAK;AACvC;AAEA,kCAA6B,SAAC,KAA+C;AAC5E,MAAI,gBAAgB,GAAG,GAAG;AACzB,WAAO,KAAK,KAAK,GAAG;EACrB;AAEA,SAAOC,iBAAA,MAAK,wBAAA,kBAAA,EAAL,KAAA,MAAsB,GAAA;AAC9B;AAEA,qBAAgB,SAAC,KAAoC;AACpD,MAAI,OAAO,QAAQ,YAAY;AAC9B,UAAM,WAAW,KAAK,IAAI,GAAY;AAEtC,QAAI,OAAO,aAAa,YAAY;AACnC,aAAOA,iBAAA,MAAK,wBAAA,kBAAA,EAAL,KAAA,MAAsB,QAAA;IAC9B;AAEA,WAAO,MAAM,gBAAgB,QAAQ;EACtC;AAEA,SAAO,MAAM,gBAAgB,GAAG;AACjC;AAyMM,kBAAa,eAAC,SAAkC;AACrD,MAAI,CAAC,QAAQ,uBAAuB,CAACD,cAAA,MAAK,KAAA,EAAM,QAAQ;AACvD,UAAM,IAAI,MAAM,4BAA4B;EAC7C;AAEA,QAAMC,iBAAA,MAAK,wBAAA,aAAA,EAAL,KAAA,MAAiB,CAAC,GAAGD,cAAA,MAAK,aAAA,GAAe,wBAAwB,GAAG,OAAA;AAC3E;AAEM,gBAAW,eAAC,SAA8B,SAAsC;AACrF,MAAI;AACH,UAAM,aAAa,CAAC,MAAc;AACjC,UAAI,KAAK,QAAQ,QAAQ;AACxB,eAAO,MAAM;QAAC;MACf;AACA,YAAM,SAAS,QAAQ,CAAC;AAExB,aAAO,YAAY;AAClB,cAAM,OAAO,WAAW,IAAI,CAAC;AAC7B,YAAI,aAAa;AACjB,YAAI,eAAe;AAEnB,cAAM,OAAOA,cAAA,MAAK,KAAA,GAAO,SAAS,YAAY;AAC7C,cAAI,YAAY;AACf,kBAAM,IAAI,MAAM,uDAAuD,CAAC,EAAE;UAC3E;AAEA,uBAAa;AAEb,gBAAM,KAAK;AAEX,yBAAe;QAChB,CAAC;AAED,YAAI,CAAC,YAAY;AAChB,gBAAM,IAAI,MAAM,8CAA8C,CAAC,EAAE;QAClE;AAEA,YAAI,CAAC,cAAc;AAClB,gBAAM,IAAI,MAAM,+CAA+C,CAAC,EAAE;QACnE;MACD;IACD;AAEA,UAAM,WAAW,CAAC,EAAE;EACrB,UAAA;AACC,IAAAE,cAAA,MAAK,eAAgBF,cAAA,MAAK,KAAA,EAAM,OAAO,MAAM,CAAA;AAC7C,IAAAE,cAAA,MAAK,iBAAkBF,cAAA,MAAK,KAAA,EAAM,SAAS,MAAM,CAAA;EAClD;AACD;AAEM,yBAAoB,iBAAG;AAC5B,SAAOA,cAAA,MAAK,gBAAA,EAAiB,OAAO,GAAG;AACtC,UAAM,aAAa,QAAQ,IAAIA,cAAA,MAAK,gBAAA,CAAgB;AACpD,IAAAA,cAAA,MAAK,gBAAA,EAAiB,MAAM;AAC5B,IAAAA,cAAA,MAAK,gBAAA,EAAiB,IAAI,UAAU;AACpC,UAAM;AACN,IAAAA,cAAA,MAAK,gBAAA,EAAiB,OAAO,UAAU;EACxC;AACD;AAEA,2BAAsB,WAAG;AACxB,QAAM,oBAAoBA,cAAA,MAAK,KAAA,EAAM;AACrC,QAAM,kBAAkBA,cAAA,MAAK,KAAA,EAAM;AAEnC,QAAM,kBAAmBA,cAAA,MAAK,eAAA,EAA8B,KAAK,QAAQ;AACzE,QAAM,gBAAiBA,cAAA,MAAK,aAAA,EAA4B,KAAK,QAAQ;AAErE,MAAI,gBAAgB,WAAW,kBAAkB,QAAQ;AACxD,UAAM,IAAI,MAAM,yDAAyD;EAC1E;AAEA,MAAI,cAAc,WAAW,gBAAgB,QAAQ;AACpD,UAAM,IAAI,MAAM,uDAAuD;EACxE;AAEA,QAAM,mBAAmB,gBAAgB;IACxC,CAAC,QAAQ,IAAI,SAAS,SAAS;EAChC;AAEA,EAAAA,cAAA,MAAK,KAAA,EAAM,WAAW;AACtB,EAAAA,cAAA,MAAK,KAAA,EAAM,SAAS;AACpB,EAAAE,cAAA,MAAK,iBAAkB,gBAAA;AACvB,EAAAA,cAAA,MAAK,eAAgB,aAAA;AACrB,EAAAA,cAAA,MAAK,mBAAoB,IAAI,IAAI,iBAAiB,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,CAAA;AAElE,WAAS,iBAAiB,OAAuB;AAChD,UAAM,UAAU,kBAAkB,KAAK;AACvC,QAAI,QAAQ,SAAS,SAAS,yBAAyB;AACtD,YAAM,SAAS,QAAQ,QAAQ,KAAK;AAEpC,UAAI,UAAU,MAAM;AACnB,cAAM,IAAI,MAAM,6CAA6C;MAC9D;AAEA,aAAO,iBAAiB,OAAO,MAAM;IACtC;AAEA,UAAM,UAAU,iBAAiB,QAAQ,OAAO;AAEhD,QAAI,YAAY,IAAI;AACnB,YAAM,IAAI,MAAM,2CAA2C;IAC5D;AAEA,WAAO;EACR;AAEA,EAAAF,cAAA,MAAK,KAAA,EAAM,aAAa,CAAC,QAAQ;AAChC,QAAI,IAAI,UAAU,SAAS;AAC1B,YAAM,UAAU,cAAc,QAAQ,gBAAgB,IAAI,KAAK,CAAC;AAEhE,UAAI,YAAY,IAAI;AACnB,cAAM,IAAI,MAAM,6BAA6B;MAC9C;AAEA,aAAO,EAAE,GAAG,KAAK,OAAO,QAAQ;IACjC,WAAW,IAAI,UAAU,UAAU;AAClC,YAAM,UAAU,iBAAiB,IAAI,MAAM;AAE3C,aAAO,EAAE,GAAG,KAAK,QAAQ,QAAQ;IAClC,WAAW,IAAI,UAAU,gBAAgB;AACxC,YAAM,UAAU,iBAAiB,IAAI,aAAa,CAAC,CAAC;AAEpD,aAAO,EAAE,GAAG,KAAK,cAAc,CAAC,SAAS,IAAI,aAAa,CAAC,CAAC,EAAE;IAC/D;AAEA,WAAO;EACR,CAAC;AAED,aAAW,CAAC,GAAG,GAAG,KAAK,kBAAkB,QAAQ,GAAG;AACnD,QAAI,IAAI,SAAS,SAAS,yBAAyB;AAClD,UAAI;AACH,YAAI,QAAQ,KAAK,cAAc,iBAAiB,CAAC;MAClD,QAAQ;MAER;IACD;EACD;AACD;AAxtBM,IAAM,cAAN;",
  "names": ["base64String", "chunk", "padding", "alphabet", "array", "cacheMap", "vector", "bigint", "_BcsType", "options", "hex", "validate", "toBytes", "name", "variant", "array", "isBytes", "anumber", "abytes", "hasHexBuiltin", "abytes", "hex", "array", "abytes", "isLE", "_32n", "abytes", "anumber", "abytes", "blake2b", "blake2b", "option", "TransactionExpiration", "UpgradePolicy", "ObjectArg", "NormalizedCallArg", "TransactionExpiration", "TypeTag", "StructTag", "blake2b", "resolved", "_ClientCache", "__privateAdd", "__privateSet", "__privateGet", "_cache", "NAME_SEPARATOR", "url", "__privateAdd", "__privateSet", "__privateGet", "Argument", "GasData", "ProgrammableMoveCall", "$Intent", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "chunk", "object", "inputs", "getClient", "object", "_Transaction", "__privateAdd", "__privateGet", "__privateMethod", "__privateSet", "TransactionExpiration", "result"]
}
